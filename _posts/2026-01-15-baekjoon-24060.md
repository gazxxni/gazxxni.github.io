---
layout: post
title: "[백준] 24060번 알고리즘 수업 - 병합 정렬 1 (Python)"
date: 2026-01-15
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "24060", 구현, 정렬, 재귀]
---

## 문제 링크
[https://www.acmicpc.net/problem/24060](https://www.acmicpc.net/problem/24060)

---

## 문제
오늘도 서준이는 병합 정렬 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.

N개의 서로 다른 양의 정수가 저장된 배열 A가 있다. 병합 정렬로 배열 A를 오름차순 정렬할 경우 배열 A에 K 번째 저장되는 수를 구해서 우리 서준이를 도와주자.

크기가 N인 배열에 대한 병합 정렬 의사 코드는 다음과 같다.

merge_sort(A[p..r]) { # A[p..r]을 오름차순 정렬한다.
    if (p < r) then {
        q <- ⌊(p + r) / 2⌋;       # q는 p, r의 중간 지점
        merge_sort(A, p, q);      # 전반부 정렬
        merge_sort(A, q + 1, r);  # 후반부 정렬
        merge(A, p, q, r);        # 병합
    }
}

---

## 입력
첫째 줄에 배열 A의 크기 N(5 ≤ N ≤ 500,000), 저장 횟수 K(1 ≤ K ≤ 108)가 주어진다.

다음 줄에 서로 다른 배열 A의 원소 A1, A2, ..., AN이 주어진다. (1 ≤ Ai ≤ 109)

---

## 출력
배열 A에 K 번째 저장 되는 수를 출력한다. 저장 횟수가 K 보다 작으면 -1을 출력한다.

---

## 성능 요약
메모리: 194992 KB, 시간: 512 ms

---

## 풀이

### 풀이 핵심 로직
문제는 병합 정렬(Merge Sort) 알고리즘을 사용하여 배열을 정렬하는 과정에서 특정 저장 횟수 K에 해당하는 값을 찾는 것입니다. 이때 배열의 특정 인덱스에 저장된 값을 찾기 위해, 병합 과정에서 저장 횟수를 카운트하고 K에 도달했을 때 해당 값을 기록합니다. 이를 통해 정렬이 완료되기 전에 원하는 값을 효율적으로 찾을 수 있습니다.

### 동작 과정
1. **입력 예시**: N = 5, K = 3, 배열 A = [3, 1, 4, 2, 5]
2. **병합 정렬**:
   - `merge_sort(A, 0, 4)` 호출
   - 배열을 두 부분으로 나눔: [3, 1, 4]와 [2, 5]
   - 각 부분에 대해 재귀적으로 `merge_sort`를 호출하여 다시 나누고 정렬.
3. **병합 과정**:
   - [3, 1, 4]의 경우:
     - [3]와 [1, 4]로 나누고, [1, 4]를 다시 [1]과 [4]로 나눔.
     - [1]과 [4]를 병합하여 [1, 4] 생성.
     - 이제 [3]과 [1, 4]를 병합: 
       - 1이 먼저 저장되므로 `cnt`가 1, 다음 3이 저장되어 `cnt`가 2, 마지막으로 4가 저장되어 `cnt`가 3.
       - 이때 `ans`에 3이 저장됨.
   - [2, 5] 부분도 비슷하게 정렬하여 최종적으로 [1, 2, 3, 4, 5]가 됨.
4. **출력**: 저장 횟수 K(3)에 해당하는 값인 3을 출력.

### 시간 복잡도
병합 정렬의 시간 복잡도는 O(N log N)입니다. 여기서 N은 배열의 크기이며, log N은 배열을 나누는 과정에 해당합니다. 이 문제에서도 병합 정렬을 사용하므로 동일한 시간 복잡도를 가집니다.

---

## 코드
```python
def merge_sort(A, p, r):
    if p < r:
        q = (p + r) // 2
        merge_sort(A, p, q)
        merge_sort(A, q + 1, r)
        merge(A, p, q, r)

def merge(A, p, q, r):
    global cnt, ans
    
    i = p
    j = q + 1
    t = 0
    tmp = [0] * (r - p + 1)
    
    while i <= q and j <= r:
        if A[i] <= A[j]:
            tmp[t] = A[i]
            i += 1
        else:
            tmp[t] = A[j]
            j += 1
        t += 1
        
    while i <= q:
        tmp[t] = A[i]
        i += 1
        t += 1
        
    while j <= r:
        tmp[t] = A[j]
        j += 1
        t += 1
        
    i = p
    t = 0
    
    while i <= r:
        A[i] = tmp[t]
        cnt += 1
        
        if cnt == k:
            ans = A[i]
            
        i += 1
        t += 1

n, k = map(int, input().split())
arr = list(map(int, input().split()))

cnt = 0
ans = -1

merge_sort(arr, 0, n - 1)

print(ans)
```