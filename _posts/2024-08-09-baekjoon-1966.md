---
layout: post
title: "[백준] 1966번 (Python)"
date: 2024-08-09
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1966"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1966](https://www.acmicpc.net/problem/1966)

---

## 풀이

### 풀이 핵심 로직
이 문제는 인쇄 대기열에서 특정 문서가 몇 번째로 인쇄되는지를 계산하는 문제입니다. 주어진 문서들 중 가장 높은 우선순위를 가진 문서가 먼저 인쇄되며, 대기열에서 이 문서가 인쇄될 때까지, 대기열의 앞에 있는 문서가 최대 우선순위가 아니라면 뒤로 보내는 방식으로 진행됩니다.

### 동작 과정
예를 들어, 입력이 다음과 같다고 가정합니다:
```
1
5 2
1 2 3 4 5
```
- `n = 5`, `m = 2` 이고, 인쇄 대기열은 `[1, 2, 3, 4, 5]`입니다.
- 초기 상태: `result = 1` (첫 번째 인쇄 카운트).
- 대기열의 첫 번째 문서(1)는 가장 높은 우선순위(5)보다 낮으므로, 대기열의 끝으로 이동: `[2, 3, 4, 5, 1]`.
- 두 번째 문서(2)도 마찬가지로 이동: `[3, 4, 5, 1, 2]`.
- 세 번째 문서(3)도 이동: `[4, 5, 1, 2, 3]`.
- 네 번째 문서(4)도 이동: `[5, 1, 2, 3, 4]`.
- 다섯 번째 문서(5)는 가장 높은 우선순위이므로 인쇄됩니다: 대기열 `[1, 2, 3, 4]`, `result`는 2.
- `m`은 1로 감소합니다.
- 다시 대기열의 첫 번째 문서(1)는 낮은 우선순위이므로 이동: `[2, 3, 4, 1]`.
- 두 번째 문서(2)는 다시 이동: `[3, 4, 1, 2]`.
- 세 번째 문서(3)는 이동: `[4, 1, 2, 3]`.
- 네 번째 문서(4)는 인쇄됩니다: 대기열 `[1, 2, 3]`, `result`는 3.
- `m`은 0으로 감소합니다.
- 다음 인쇄할 문서(1)는 인쇄됩니다: 대기열 `[2, 3]`, `result`는 4.
- 결과적으로 출력되는 값은 4입니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n^2)입니다. 대기열에서 문서를 이동시키는 작업은 최악의 경우 n번 반복되며, 각 반복에서 최대 우선순위를 찾는 데 O(n)이 소요됩니다.

---

## 코드
```python
import sys

t=int(input())

for _ in range(t):
    n,m=map(int,input().split())
    imp=list(map(int, input().split()))

    result=1

    while imp:
        if imp[0]<max(imp):
            imp.append(imp.pop(0))

        else:
            if m==0:
                break

            imp.pop(0)
            result +=1

        m = m - 1 if m > 0 else len(imp) - 1

    print(result)

    
```