---
layout: post
title: "[백준] 14003번 (Python)"
date: 2025-09-21
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "14003"]
---

## 문제 링크
[https://www.acmicpc.net/problem/14003](https://www.acmicpc.net/problem/14003)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 수열에서 가장 긴 증가 부분 수열(LIS)을 찾는 문제입니다. 이 알고리즘은 이분 탐색을 이용하여 LIS의 길이를 효율적으로 계산하고, 추가적으로 이전 인덱스를 기록하여 최종적으로 LIS를 복원합니다.

### 동작 과정
1. **입력 처리**: N개의 정수를 입력받아 `arr` 리스트에 저장합니다.
2. **초기화**: `tails` 리스트는 각 길이의 증가 부분 수열의 최소 끝값을 저장하고, `tails_pos` 리스트는 해당 끝값을 만드는 인덱스를 저장합니다. `prev_idx` 리스트는 각 원소가 LIS에 포함될 때 그 바로 이전 원소의 인덱스를 기록합니다.
3. **LIS 길이 계산**:
   - 각 원소 `x`에 대해 이분 탐색을 통해 `tails`에서 `x`가 들어갈 위치 `j`를 찾습니다.
   - `j`가 `tails`의 길이와 같다면 새로운 길이의 증가 부분 수열을 형성하므로 `tails`와 `tails_pos`에 추가합니다.
   - 그렇지 않다면 현재의 `x`로 `j` 위치의 값을 갱신합니다.
   - 이전 인덱스는 `prev_idx[i]`에 기록하여 LIS 복원에 사용할 수 있도록 합니다.
4. **LIS 복원**: `tails_pos`의 마지막 인덱스에서 시작하여 `prev_idx`를 따라 역추적하여 최종적인 LIS를 생성합니다.
5. **출력**: LIS의 길이와 원소들을 출력합니다.

**예시 입력**: 
```
8
10 20 10 30 20 50
```
**단계별 설명**:
- 첫 번째 원소 10을 `tails`에 추가 (tails = [10]).
- 두 번째 원소 20을 `tails`에 추가 (tails = [10, 20]).
- 세 번째 원소 10을 `tails`의 0번째 위치에 삽입, `tails`는 변하지 않음 (tails = [10, 20]).
- 네 번째 원소 30을 `tails`에 추가 (tails = [10, 20, 30]).
- 다섯 번째 원소 20을 `tails`의 1번째 위치에 삽입, `tails`는 변하지 않음 (tails = [10, 20, 30]).
- 여섯 번째 원소 50을 `tails`에 추가 (tails = [10, 20, 30, 50]).
- 최종적으로 `tails`의 길이는 4이므로 LIS의 길이는 4이고, 원소는 역추적하여 [10, 20, 30, 50]이 됩니다.

### 시간 복잡도
O(N log N) - 이분 탐색을 사용하여 각 원소에 대해 로그 시간 복잡도로 위치를 찾기 때문에 전체 시간 복잡도는 O(N log N)입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
arr = list(map(int, input().split()))

# tails[k] = 길이 (k+1)인 증가 부분수열의 최소 끝값
# tails_pos[k] = 위 tails[k]를 만든 인덱스
tails = []
tails_pos = []

# prev_idx[i] = arr[i]가 LIS에 포함될 때, 그 바로 이전 원소의 인덱스
prev_idx = [-1] * n

def search(a, x):
    lo, hi = 0, len(a)
    while lo < hi:
        mid = (lo + hi) // 2
        if a[mid] < x:
            lo = mid + 1
        else:
            hi = mid
    return lo

for i, x in enumerate(arr):
    j = search(tails, x)

    # j-1 길이의 꼬리에 이어 붙이므로, 그 경로의 마지막 인덱스를 prev로 기록
    prev_idx[i] = tails_pos[j - 1] if j > 0 else -1

    if j == len(tails):  # 길이 확장
        tails.append(x)
        tails_pos.append(i)
    else:    # 꼬리값 갱신
        tails[j] = x
        tails_pos[j] = i

# 실제 LIS 복원: 가장 긴 길이의 마지막 인덱스부터 prev_idx를 따라 역추적
lis_len = len(tails)
k = tails_pos[-1] if tails_pos else -1

seq = []
while k != -1:
    seq.append(arr[k])
    k = prev_idx[k]
seq.reverse()

print(lis_len)
print(*seq)

```