---
layout: post
title: "[백준] 11403번 (Python)"
date: 2024-11-23
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "11403"]
---

## 문제 링크
[https://www.acmicpc.net/problem/11403](https://www.acmicpc.net/problem/11403)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 그래프에서 노드 간의 경로 존재 여부를 확인하는 문제입니다. BFS(너비 우선 탐색)를 사용하여 각 노드에서 출발하여 도달 가능한 모든 노드를 탐색하고, 이를 통해 특정 노드에서 다른 노드로 가는 경로가 있는지를 확인하여 `visited` 배열에 기록합니다.

### 동작 과정
1. **입력 예시**: 
   ```
   4
   0 1 0 0
   0 0 1 0
   1 0 0 1
   0 0 0 0
   ```

2. **그래프 구성**: 
   입력에 따라 4x4 인접행렬 형태의 그래프가 구성됩니다:
   ```
   [[0, 1, 0, 0],
    [0, 0, 1, 0],
    [1, 0, 0, 1],
    [0, 0, 0, 0]]
   ```
   여기서 `grapgh[i][j]`는 노드 i에서 노드 j로 가는 간선이 존재하는지 여부를 나타냅니다.

3. **BFS 수행**:
   - 첫 번째로 노드 0에서 시작하여 BFS를 수행합니다. 노드 0에서 갈 수 있는 노드는 노드 1입니다. 따라서 `visited[0][1] = 1`로 설정됩니다.
   - 노드 1로 이동 후, 노드 1에서 갈 수 있는 노드는 노드 2입니다. `visited[0][2] = 1`로 설정됩니다.
   - 노드 2에서 갈 수 있는 노드는 노드 0과 노드 3입니다. `visited[0][3] = 1`로 설정됩니다.
   - BFS가 종료되면 노드 0에서 도달할 수 있는 모든 노드에 대해 visited 배열이 업데이트됩니다.
   - 이 과정을 모든 노드(0부터 n-1까지)에 반복하여, 모든 쌍의 도달 가능성을 탐색합니다.

4. **결과 출력**: 
   최종적으로 `visited` 배열을 출력하여 각 노드에서 다른 노드로의 경로 존재 여부를 확인할 수 있습니다.

### 시간 복잡도
BFS를 각 노드에 대해 수행하므로, 최악의 경우 O(n^2) 시간이 소요됩니다. 따라서 전체 시간 복잡도는 O(n^3)입니다.

---

## 코드
```python
from collections import deque

n = int(input())
grapgh = [list(map(int, input().split())) for _ in range(n)]
visited = [[0] * n for _ in range(n)]

def bfs(x):
    queue = deque()
    queue.append(x)
    check = [0 for _ in range(n)]    # BFS 중복 방문 방지를 위한 check 배열

    while queue:
        q = queue.popleft()

        for i in range(n):
            # 아직 방문하지 않았고, q에서 i로 가는 길이 있을 때
            if check[i] == 0 and grapgh[q][i] == 1:
                queue.append(i)      # 큐에 i 노드를 추가하고 방문 기록
                check[i] = 1
                # 노드 x에서 노드 i로 가는 경로가 있음을 visited 배열에 기록
                visited[x][i] = 1

for i in range(n):
    bfs(i)

for i in visited:
    print(*i)

```