---
layout: post
title: "[백준] 2096번 (Python)"
date: 2025-02-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2096"]
---

## 문제 링크
[https://www.acmicpc.net/problem/2096](https://www.acmicpc.net/problem/2096)

---

## 풀이

### 풀이 핵심 로직
이 문제는 동적 계획법(Dynamic Programming)을 사용하여 주어진 배열에서 경로의 최대값과 최소값을 구하는 것입니다. 각 칸에서 이전 칸의 값에 따라 최대값과 최소값을 갱신하면서 진행하는 슬라이딩 윈도우 방식으로, 이전 단계의 최대 및 최소값을 기반으로 현재 단계의 값을 계산합니다.

### 동작 과정
1. **입력:** 첫 줄에서 n을 입력받고, 두 번째 줄에서 첫 번째 행의 값을 arr에 저장합니다.
2. **DP 배열 초기화:** maxDP와 minDP를 첫 번째 행의 값으로 초기화합니다. 
3. **점진적 계산:** n-1번 반복하면서 각 행의 값을 입력받고, 다음과 같이 최대값과 최소값을 갱신합니다:
   - 첫 번째 칸의 최대값: 현재 행의 첫 번째 칸 값 + 이전 단계의 첫 번째 또는 두 번째 칸의 최대값
   - 두 번째 칸의 최대값: 현재 행의 두 번째 칸 값 + 이전 단계의 첫 번째, 두 번째, 또는 세 번째 칸의 최대값
   - 세 번째 칸의 최대값: 현재 행의 세 번째 칸 값 + 이전 단계의 두 번째 또는 세 번째 칸의 최대값
   - 최소값도 동일한 로직으로 갱신
4. **결과 출력:** 마지막으로 maxDP와 minDP에서 각각 최대값과 최소값을 출력합니다.

예시 입력:
```
3
1 2 3
4 5 6
7 8 9
```
- 첫 번째 행: maxDP = [1, 2, 3], minDP = [1, 2, 3]
- 두 번째 행: maxDP = [10, 11, 12], minDP = [5, 6, 7]
- 세 번째 행: maxDP = [19, 20, 21], minDP = [12, 13, 14]
- 출력: `21 12`

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n)입니다. 각 행에 대해 상수 시간 내에 최대값과 최소값을 계산하므로, 전체적으로 n개의 행에 대해 반복하더라도 각 행에 대해 수행되는 작업은 일정합니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
arr = list(map(int, input().split()))

# maxDP와 minDP를 초기화 (최대값과 최소값을 저장하는 배열)
maxDP = arr  # 현재까지의 최대값 경로를 저장
minDP = arr  # 현재까지의 최소값 경로를 저장

for _ in range(n-1):
    arr = list(map(int, input().split()))

    # 슬라이딩 윈도우 방식으로 이전 단계의 값(maxDP, minDP)을 사용해 현재 값 계산
    maxDP = [
        arr[0] + max(maxDP[0], maxDP[1]),              # 첫 번째 칸의 최대값
        arr[1] + max(maxDP[0], maxDP[1], maxDP[2]),    # 두 번째 칸의 최대값
        arr[2] + max(maxDP[1], maxDP[2])               # 세 번째 칸의 최대값
    ]
    
    minDP = [
        arr[0] + min(minDP[0], minDP[1]),              # 첫 번째 칸의 최소값
        arr[1] + min(minDP[0], minDP[1], minDP[2]),    # 두 번째 칸의 최소값
        arr[2] + min(minDP[1], minDP[2])               # 세 번째 칸의 최소값
    ]

print(max(maxDP), min(minDP))

```