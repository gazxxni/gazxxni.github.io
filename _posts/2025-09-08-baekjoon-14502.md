---
layout: post
title: "[백준] 14502번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "14502"]
---

## 문제 링크
[https://www.acmicpc.net/problem/14502](https://www.acmicpc.net/problem/14502)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 맵에서 3개의 벽을 세워서 바이러스의 전파를 최소화하는 것입니다. 핵심 아이디어는 깊이 우선 탐색(DFS)을 사용하여 가능한 모든 벽 조합을 탐색한 후, 각 조합마다 바이러스를 전파시키고 안전 영역의 크기를 계산하여 최대 안전 영역을 찾는 것입니다.

### 동작 과정
1. **입력 받기**: 맵의 크기(n, m)와 맵의 상태(arr)를 입력받습니다.
2. **바이러스 전파 함수 정의**: `virus` 함수는 현재 맵에서 바이러스가 전파된 후의 안전 영역을 계산합니다. 큐를 사용하여 BFS 방식으로 바이러스를 전파하며, 전파가 끝나면 안전 영역의 크기를 `cnt`에 저장합니다.
3. **벽 세우는 함수 정의**: `build_walls` 함수는 DFS를 사용하여 3개의 벽을 세우는 모든 조합을 탐색합니다. 벽을 세운 후 `virus` 함수를 호출하여 안전 영역을 계산합니다. 벽을 세운 후에는 원래 상태로 되돌리기 위해 벽을 제거합니다.
4. **최종 결과 출력**: 모든 조합을 탐색한 후 최대 안전 영역의 크기를 출력합니다.

예시 입력:
```
7 7
2 0 0 0 1 1 0
0 0 0 0 1 2 0
0 0 1 0 0 0 0
0 1 1 0 1 1 0
0 0 0 0 0 0 0
0 1 1 0 1 1 0
0 0 0 0 0 0 0
```
- 초기 맵에서 0은 빈 공간, 1은 벽, 2는 바이러스를 나타냄.
- 벽을 세운 후 바이러스가 전파되는 과정을 통해 안전 영역의 크기를 계산합니다.
- 가능한 모든 벽 조합을 탐색하여 최대 안전 영역을 구합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 \(O(n \times m \times \binom{n \times m}{3})\)입니다. \(n \times m\)은 맵의 전체 크기, \(\binom{n \times m}{3}\)은 가능한 벽 조합의 수를 나타냅니다. 각 조합마다 BFS를 통해 바이러스 전파를 확인하므로 최악의 경우 시간 복잡도가 매우 높을 수 있습니다.

---

## 코드
```python
import sys
import copy
from collections import deque
input= sys.stdin.readline

n, m = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(n)]

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

cnt = 0

def virus():
    tmp = copy.deepcopy(arr)  
    q = deque()
    
    for i in range(n):
        for j in range(m):
            if tmp[i][j] == 2:
                q.append((i, j))

    while q:
        x, y = q.popleft()
        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]
            if 0 <= nx < n and 0 <= ny < m and tmp[nx][ny] == 0:
                tmp[nx][ny] = 2 
                q.append((nx, ny))

    global cnt
    safe = sum(row.count(0) for row in tmp)
    cnt = max(cnt, safe)

def build_walls(count):
    if count == 3:  
        virus()
        return
    
    for i in range(n):
        for j in range(m):
            if arr[i][j] == 0: 
                arr[i][j] = 1 
                build_walls(count + 1)  
                arr[i][j] = 0  

build_walls(0)
print(cnt)

```