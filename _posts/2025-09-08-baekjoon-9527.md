---
layout: post
title: "[백준] 9527번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "9527"]
---

## 문제 링크
[https://www.acmicpc.net/problem/9527](https://www.acmicpc.net/problem/9527)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 범위 내에서 1의 개수를 세기 위해 비트 연산을 활용합니다. 각 비트 위치에서의 1의 개수를 계산하기 위해, 0부터 x까지의 수에서 각 비트 위치에 대해 1이 나타나는 패턴을 분석하여 카운트합니다. 최종적으로 \( b \)까지의 1의 개수에서 \( a-1 \)까지의 1의 개수를 빼서 \( [a, b] \) 범위 내의 1의 개수를 구합니다.

### 동작 과정
예를 들어, 입력으로 `a = 3`과 `b = 7`이 주어진다고 가정해봅시다.

1. **search(b)**: `b = 7`인 경우, 0부터 7까지의 수를 고려하여 각 비트에서 1의 개수를 세는 과정을 진행합니다.
   - 각 비트 위치(0부터 63까지)를 순회하며, 해당 비트가 1이 되는 경우의 수를 계산합니다.
   - 예를 들어, 0부터 7까지 수는 `000` (0), `001` (1), `010` (2), `011` (3), `100` (4), `101` (5), `110` (6), `111` (7)로, 이들 중 각 자리에서 1이 몇 번 나타나는지를 분석합니다.
   - 최종적으로 0부터 7까지의 1의 개수를 반환합니다.

2. **search(a - 1)**: `a - 1 = 2`인 경우도 같은 방식으로 0부터 2까지의 수를 분석합니다.
   - 0부터 2까지의 수는 `000` (0), `001` (1), `010` (2)로, 이들 중 각 자리에서 1이 몇 번 나타나는지를 계산합니다.

3. 마지막으로, `search(b) - search(a - 1)`을 통해 `[3, 7]` 범위 내의 1의 개수를 계산합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 \( O(\log n) \)입니다. 여기서 \( n \)은 입력값 \( b \)입니다. 64개의 비트 위치를 순회하면서 각 비트의 1의 개수를 계산하기 때문에, 주어진 \( x \)에 대해 비트 수에 비례한 시간 복잡도를 갖습니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

a, b = map(int, input().split())

def search(x):
    total = 0

    for i in range(64):  
        block_size = 2 ** (i + 1)  
        half_block = 2 ** i           

        full_blocks = (x + 1) // block_size
        remainder = (x + 1) % block_size

        cnt = full_blocks * half_block

        if remainder > half_block:
            cnt += remainder - half_block

        total += cnt

    return total

print(search(b) - search(a - 1))
```