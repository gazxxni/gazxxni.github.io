---
layout: post
title: "[백준] 24060번 (Python)"
date: 2025-10-26
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "24060"]
---

## 문제 링크
[https://www.acmicpc.net/problem/24060](https://www.acmicpc.net/problem/24060)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 배열을 정렬하면서 k번째로 정렬된 수를 찾는 것이 목표입니다. 병합 정렬을 사용하여 배열을 정렬하는 동시에, 정렬된 배열의 원소를 카운트하여 k번째 원소가 무엇인지 추적합니다. 정렬 과정 중에 카운트를 증가시켜 k에 도달할 때 해당 원소의 값을 저장합니다.

### 동작 과정
예를 들어, 입력이 `8 5`와 `3 1 4 1 5 9 2 6`일 경우 다음과 같은 단계로 진행됩니다:

1. 초기 배열: `[3, 1, 4, 1, 5, 9, 2, 6]`
2. 병합 정렬 시작:
   - 배열을 두 부분으로 나눕니다: `[3, 1, 4, 1]`과 `[5, 9, 2, 6]`
   - 첫 번째 부분을 다시 나눕니다: `[3, 1]`과 `[4, 1]` 
   - `[3, 1]`을 정렬: `[1, 3]`
   - `[4, 1]`을 정렬: `[1, 4]`
   - 합쳐서 첫 번째 부분 최종 정렬: `[1, 1, 3, 4]`
3. 두 번째 부분도 정렬: `[5, 9]`와 `[2, 6]`를 정렬하여 최종적으로 `[2, 5, 6, 9]`로 합쳐짐.
4. 두 부분을 합쳐 최종 배열 정렬: `[1, 1, 2, 3, 4, 5, 6, 9]`
5. 이 과정에서 1, 2, 3, 4, 5번째 원소 (0-index) 카운트하며 5번째 원소인 5를 찾아내어 저장.

최종적으로 `ans`에는 5가 저장되어 출력됩니다.

### 시간 복잡도
병합 정렬의 시간 복잡도는 O(n log n)입니다. 이 알고리즘은 배열의 모든 원소를 정렬하면서 k번째 원소를 찾는 과정을 포함하므로, 전체 시간 복잡도 또한 O(n log n)으로 유지됩니다.

---

## 코드
```python
def merge_sort(A, p, r):
    if p < r:
        q = (p + r) // 2
        merge_sort(A, p, q)
        merge_sort(A, q + 1, r)
        merge(A, p, q, r)

def merge(A, p, q, r):
    global cnt, ans
    
    i = p
    j = q + 1
    t = 0
    tmp = [0] * (r - p + 1)
    
    while i <= q and j <= r:
        if A[i] <= A[j]:
            tmp[t] = A[i]
            i += 1
        else:
            tmp[t] = A[j]
            j += 1
        t += 1
        
    while i <= q:
        tmp[t] = A[i]
        i += 1
        t += 1
        
    while j <= r:
        tmp[t] = A[j]
        j += 1
        t += 1
        
    i = p
    t = 0
    
    while i <= r:
        A[i] = tmp[t]
        cnt += 1
        
        if cnt == k:
            ans = A[i]
            
        i += 1
        t += 1

n, k = map(int, input().split())
arr = list(map(int, input().split()))

cnt = 0
ans = -1

merge_sort(arr, 0, n - 1)

print(ans)
```