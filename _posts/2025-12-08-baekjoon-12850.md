---
layout: post
title: "[백준] 12850번 본대 산책2 (Python)"
date: 2025-12-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "12850", 수학, 그래프 이론, 분할 정복을 이용한 거듭제곱]
---

## 문제 링크
[https://www.acmicpc.net/problem/12850](https://www.acmicpc.net/problem/12850)

---

## 문제
숭실 대학교 정보 과학관은 유배를 당해서  캠퍼스의 길 건너편에 있다. 그래서 컴퓨터 학부 학생들은 캠퍼스를 ‘본대’ 라고 부르고 정보 과학관을 ‘정보대’ 라고 부른다. 준영이 또한 컴퓨터 학부 소속 학생이라서 정보 과학관에 박혀있으며 항상 꽃 이 활짝 핀 본 대를 선망한다. 어느 날 준영이는 본 대를 산책하기로 결심하였다. 숭실 대학교 캠퍼스 지도는 아래와 같다.



(편의 상 문제에서는 위 건물만 등장한다고 가정하자)

한 건물에서 바로 인접한 다른 건물로 이동 하는 데 1분이 걸린다. 준영이는 산책 도중에 한번도 길이나 건물에 멈춰서 머무르지 않는다. 준영이는 할 일이 많아서 딱 D분만 산책을 할 것이다. (산책을 시작 한 지 D분 일 때, 정보 과학관에 도착해야 한다.) 이때 가능한 경로의 경우의 수를 구해주자.

---

## 입력
D 가 주어진다 (1 ≤ D ≤ 1,000,000,000)

---

## 출력
가능한 경로의 수를 1,000,000,007로 나눈 나머지를 출력한다.

---

## 성능 요약
메모리: 109544 KB, 시간: 96 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 그래프의 인접 행렬을 사용하여 특정 시간 동안 가능한 경로의 수를 계산하는 문제입니다. 주어진 그래프를 인접 행렬 형태로 표현한 후, 분할 정복을 이용한 행렬 거듭제곱을 통해 D분 후의 경로 수를 구합니다. 이를 통해 시작점에서 끝점까지의 경로 수를 효과적으로 계산할 수 있습니다.

### 동작 과정
1. **그래프의 인접 행렬 정의**: 그래프를 인접 행렬 형태로 정의합니다. 각 행렬의 원소는 두 건물(노드) 사이의 연결 여부를 나타냅니다.
   ```
   graph = [
       [0,1,1,0,0,0,0,0],
       [1,0,1,1,0,0,0,0],
       [1,1,0,1,1,0,0,0],
       [0,1,1,0,1,1,0,0],
       [0,0,1,1,0,1,0,1],
       [0,0,0,1,1,0,1,0],
       [0,0,0,0,0,1,0,1],
       [0,0,0,0,1,0,1,0],
   ]
   ```
2. **행렬 곱셈 함수 정의**: 두 행렬을 곱하는 함수를 정의합니다. 이때 곱셈 결과를 모듈로 연산을 통해 큰 수의 오버플로우를 방지합니다.
3. **행렬 거듭제곱 함수 정의**: 재귀를 사용하여 행렬의 거듭제곱을 계산하는 함수를 정의합니다. 분할 정복을 통해 효율적으로 계산합니다.
4. **결과 출력**: D분 후의 경로 수를 출력합니다. 시작점(정보대)에서 끝점(본대)까지의 경로 수는 행렬의 (0, 0) 원소에 저장됩니다.

예를 들어, D=2인 경우:
- 2분 동안 이동할 수 있는 경로를 찾기 위해 `cal(graph, 2)`를 호출하고, 이 과정에서 행렬의 거듭제곱이 수행됩니다. 최종적으로 (0, 0) 원소의 값을 출력하여 경로 수를 구합니다.

### 시간 복잡도
행렬 곱셈의 시간 복잡도는 \(O(N^3)\)이며, 행렬 거듭제곱을 위해 \(O(\log D)\)의 시간복잡도가 필요합니다. 따라서 전체 시간 복잡도는 \(O(N^3 \cdot \log D)\)입니다. 여기서 N은 그래프의 노드 수입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

MOD = 1_000_000_007

graph = [
    [0,1,1,0,0,0,0,0],
    [1,0,1,1,0,0,0,0],
    [1,1,0,1,1,0,0,0],
    [0,1,1,0,1,1,0,0],
    [0,0,1,1,0,1,0,1],
    [0,0,0,1,1,0,1,0],
    [0,0,0,0,0,1,0,1],
    [0,0,0,0,1,0,1,0],
]

d = int(input().strip())

def multiply(A, B):
    result = [[0] * 8 for i in range(8)]
  
    for i in range(8):
        for j in range(8):
            for k in range(8):
                result[i][j] += A[i][k] * B[k][j]
            result[i][j] %= MOD
      
    return result

def cal(A, n):
    if n == 1:
        return A
    cal2 = cal(A, n//2)
    
    if n % 2 == 0:
        return multiply(cal2, cal2)
    else:
        mul2 = multiply(cal2, cal2)
        return multiply(mul2, A)
    
result = cal(graph, d)
print(result[0][0])
```