---
layout: post
title: "[백준] 12850번 본대 산책2 (Python)"
date: 2025-12-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "12850", 수학, 그래프 이론, 분할 정복을 이용한 거듭제곱]
---

## 문제 링크
[https://www.acmicpc.net/problem/12850](https://www.acmicpc.net/problem/12850)

---

## 문제
숭실 대학교 정보 과학관은 유배를 당해서  캠퍼스의 길 건너편에 있다. 그래서 컴퓨터 학부 학생들은 캠퍼스를 ‘본대’ 라고 부르고 정보 과학관을 ‘정보대’ 라고 부른다. 준영이 또한 컴퓨터 학부 소속 학생이라서 정보 과학관에 박혀있으며 항상 꽃 이 활짝 핀 본 대를 선망한다. 어느 날 준영이는 본 대를 산책하기로 결심하였다. 숭실 대학교 캠퍼스 지도는 아래와 같다.



(편의 상 문제에서는 위 건물만 등장한다고 가정하자)

한 건물에서 바로 인접한 다른 건물로 이동 하는 데 1분이 걸린다. 준영이는 산책 도중에 한번도 길이나 건물에 멈춰서 머무르지 않는다. 준영이는 할 일이 많아서 딱 D분만 산책을 할 것이다. (산책을 시작 한 지 D분 일 때, 정보 과학관에 도착해야 한다.) 이때 가능한 경로의 경우의 수를 구해주자.

---

## 입력
D 가 주어진다 (1 ≤ D ≤ 1,000,000,000)

---

## 출력
가능한 경로의 수를 1,000,000,007로 나눈 나머지를 출력한다.

---

## 성능 요약
메모리: 109544 KB, 시간: 96 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 그래프의 인접 행렬을 이용해 주어진 시간 D 동안의 경로 수를 계산하는 문제입니다. 분할 정복을 이용한 거듭제곱을 사용하여 인접 행렬을 D번 곱하면, 특정 정점에서 다른 정점으로 가는 경로의 수를 구할 수 있습니다. 이때 최종 결과는 모듈로 연산을 통해 1,000,000,007로 나눈 값을 출력합니다.

### 동작 과정
1. **입력**: D의 값을 입력받습니다. 예를 들어, D = 5라고 가정합니다.
2. **그래프 정의**: 8개의 노드(건물) 간의 인접 행렬을 정의합니다. 이 행렬에서 요소가 1인 경우 두 건물 간에 직접 연결이 있음을 나타냅니다.
3. **행렬 제곱**:
   - `cal` 함수는 주어진 행렬 A를 n번 곱하는 함수입니다. 분할 정복을 통해 행렬의 제곱을 효율적으로 계산합니다.
   - n이 홀수인 경우, A를 한번 더 곱해줍니다.
4. **경로 수 추출**: D번 곱한 결과 행렬에서 (0, 0) 위치의 값을 추출합니다. 이는 본대(0번 노드)에서 출발하여 정보대(0번 노드)로 돌아오는 경로 수를 나타냅니다.
5. **출력**: 최종 결과를 1,000,000,007로 나눈 나머지를 출력합니다.

예를 들어, D = 5일 경우:
- `cal(graph, 5)`를 통해 그래프의 제곱을 5번 수행하고,
- `result[0][0]`을 통해 본대에서 다시 본대로 오는 경로의 수를 구하게 됩니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(log D)입니다. 이는 행렬 제곱을 반복하는 과정에서 분할 정복을 사용하기 때문입니다. 각 행렬 곱셈은 O(V^3) (여기서 V는 노드 수, 즉 8) 이지만, D의 값이 최대 1,000,000,000까지 가능하므로 O(log D)로 매우 효율적인 계산이 됩니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

MOD = 1_000_000_007

graph = [
    [0,1,1,0,0,0,0,0],
    [1,0,1,1,0,0,0,0],
    [1,1,0,1,1,0,0,0],
    [0,1,1,0,1,1,0,0],
    [0,0,1,1,0,1,0,1],
    [0,0,0,1,1,0,1,0],
    [0,0,0,0,0,1,0,1],
    [0,0,0,0,1,0,1,0],
]

d = int(input().strip())

def multiply(A, B):
    result = [[0] * 8 for i in range(8)]
  
    for i in range(8):
        for j in range(8):
            for k in range(8):
                result[i][j] += A[i][k] * B[k][j]
            result[i][j] %= MOD
      
    return result

def cal(A, n):
    if n == 1:
        return A
    cal2 = cal(A, n//2)
    
    if n % 2 == 0:
        return multiply(cal2, cal2)
    else:
        mul2 = multiply(cal2, cal2)
        return multiply(mul2, A)
    
result = cal(graph, d)
print(result[0][0])
```