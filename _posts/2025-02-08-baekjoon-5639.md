---
layout: post
title: "[백준] 5639번 (Python)"
date: 2025-02-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "5639"]
---

## 문제 링크
[https://www.acmicpc.net/problem/5639](https://www.acmicpc.net/problem/5639)

---

## 풀이

### 풀이 핵심 로직
이 문제는 이진 탐색 트리(BST)의 후위 순회 결과를 출력하는 문제입니다. 주어진 입력이 BST의 전위 순회 결과로 주어졌을 때, 이를 재귀적으로 탐색하여 후위 순회 순서로 출력합니다. 후위 순회는 왼쪽 서브트리, 오른쪽 서브트리, 그리고 루트의 순서로 진행됩니다.

### 동작 과정
1. **입력**: 사용자가 정수를 입력하고, 이 정수들은 BST의 전위 순회 결과로 해석됩니다. 예를 들어, 입력이 다음과 같다고 가정합니다:
   ```
   30
   20
   10
   25
   40
   35
   50
   ```
   이 경우 BST는 다음과 같이 구성됩니다:
   ```
       30
      /  \
     20   40
    / \   / \
   10 25 35 50
   ```

2. **재귀 함수 호출**: `search(0, len(h) - 1)` 호출로 시작하여 전체 배열에 대한 탐색을 시작합니다. `st`는 시작 인덱스, `ed`는 끝 인덱스입니다.

3. **서브트리 탐색**:
   - 현재 루트 노드의 값(h[st])보다 큰 첫 번째 값을 찾아 오른쪽 서브트리의 시작 인덱스를 `mid`로 설정합니다.
   - 왼쪽 서브트리를 재귀적으로 탐색합니다: `search(st + 1, mid - 1)`.
   - 오른쪽 서브트리를 재귀적으로 탐색합니다: `search(mid, ed)`.
   - 마지막으로 현재 루트 노드의 값을 출력합니다.

4. **출력 순서**: 각 서브트리 탐색이 끝나면 현재 루트의 값을 출력하므로 최종적으로 후위 순회의 결과가 출력됩니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(N)입니다. 여기서 N은 입력으로 주어진 노드의 수입니다. 각 노드를 한 번씩 방문하게 되며, 각 노드에 대해 최대 O(N) 번의 반복이 발생할 수 있지만, 실제로는 BST 특성에 따라 평균적으로 O(log N) 깊이에서 탐색하므로 전체적으로 O(N)으로 고려할 수 있습니다.

---

## 코드
```python
import sys
input = sys.stdin.readline  
sys.setrecursionlimit(10 ** 5)

h = []

while True:
    try:
        h.append(int(input())) 
    except:
        break  

def search(st, ed):
    if st > ed:  # 시작 인덱스가 끝 인덱스를 넘어가면 종료 (기저 조건)
        return
    
    mid = ed + 1  # 오른쪽 서브트리가 없을 경우 대비비

    # 루트 노드보다 큰 첫 번째 값을 찾기 위해 반복
    for i in range(st + 1, ed + 1):
        if h[i] > h[st]:  # 현재 루트(h[st])보다 큰 값을 찾으면
            mid = i  # 오른쪽 서브트리의 시작 위치를 갱신
            break 
    
    # 왼쪽 서브트리 탐색 (현재 루트의 다음 값부터 mid - 1까지)
    search(st + 1, mid - 1)
    # 오른쪽 서브트리 탐색 (mid부터 ed까지)
    search(mid, ed)
    # 현재 루트 노드 출력
    print(h[st])

search(0, len(h) - 1)

```