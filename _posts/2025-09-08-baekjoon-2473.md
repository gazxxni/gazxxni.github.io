---
layout: post
title: "[백준] 2473번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2473"]
---

## 문제 링크
[https://www.acmicpc.net/problem/2473](https://www.acmicpc.net/problem/2473)

---

## 풀이

### 풀이 핵심 로직
주어진 배열에서 세 개의 수를 선택하여 그 합이 0에 가장 가까운 값을 찾는 문제입니다. 이 문제를 해결하기 위해 배열을 정렬한 후, 첫 번째 수를 고정하고 나머지 두 수를 투 포인터 방식으로 탐색하여 합이 0에 가까운지를 확인합니다. 이를 통해 O(N^2) 시간 복잡도로 문제를 해결할 수 있습니다.

### 동작 과정
1. **입력 및 정렬**: 입력을 받아서 배열을 정렬합니다. 예를 들어, 입력이 `5`와 `-2 4 -99 1 3`이라면, 정렬 후 배열은 `[-99, -2, 1, 3, 4]`가 됩니다.

2. **첫 번째 수 고정 및 투 포인터 설정**: 배열의 첫 번째 수부터 차례로 고정하고, 그 다음 두 수를 투 포인터 방식으로 탐색합니다. 예를 들어, 첫 번째 수가 `-99`일 때, 두 번째 수는 `-2`, 세 번째 수는 `4`로 설정합니다.

3. **합 계산 및 비교**:
   - 세 수의 합을 계산합니다: `total = arr[i] + arr[left] + arr[right]`.
   - 이 합의 절대값이 현재 가장 가까운 값보다 작으면, 가장 가까운 값을 업데이트합니다.
   - 만약 `total`이 0보다 작으면, `left` 포인터를 오른쪽으로 이동시켜 더 큰 값을 선택하고,
   - `total`이 0보다 크면, `right` 포인터를 왼쪽으로 이동시켜 더 작은 값을 선택합니다.
   - 만약 `total`이 0인 경우, 최적의 해를 찾은 것이므로 즉시 결과를 반환합니다.

4. **결과 출력**: 모든 조합을 탐색한 후, 가장 가까운 세 수의 조합을 출력합니다.

예시 입력 `5`와 `-2 4 -99 1 3`인 경우, 정렬된 후 가장 가까운 0의 합을 가지는 수는 `-99`, `1`, `4`로, 출력은 `-99 1 4`가 됩니다.

### 시간 복잡도
정렬하는 데 O(N log N) 시간이 소요되고, 각 고정된 수에 대해 투 포인터 탐색을 하므로 O(N^2) 시간이 소요됩니다. 따라서 전체 시간 복잡도는 O(N^2)입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
arr = list(map(int, input().split()))
arr.sort()

def search(arr):
    closest = float('inf')
    result = ()

    for i in range(n - 2):
        left, right = i + 1, n - 1

        while left < right:
            total = arr[i] + arr[left] + arr[right]

            if abs(total) < abs(closest):
                closest = total
                result = (arr[i], arr[left], arr[right])

            if total < 0:
                left += 1
            elif total > 0:
                right -= 1
            else:
                return 0, (arr[i], arr[left], arr[right])

    return closest, result

_, (a, b, c) = search(arr)
print(a, b, c)
```