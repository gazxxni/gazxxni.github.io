---
layout: post
title: "[백준] 9742번 순열 (Python)"
date: 2026-01-16
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "9742", 브루트포스 알고리즘, 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/9742](https://www.acmicpc.net/problem/9742)

---

## 문제
집합의 순열이란 집합의 서로 다른 원소를 모두 사용해 만들 수 있는 순서이다. 예를 들어, {2,3,5}의 순열은 다음과 같다.


	2 3 5
	2 5 3
	3 2 5
	3 5 2
	5 2 3
	5 3 2


각각의 순열은 숫자로 나타낼 수 있다. 위의 순열은 사전순으로 쓰여져 있으며, 등장하는 순서를 이용해 나타낸다. 즉, 3 5 2는 위치 4에 있고, 5 3 2는 마지막 위치인 6에 있다.

{b,e,i,n}으로 만들 수 있는 순열은 다음과 같다.


	b e i n
	b e n i
	b i e n
	b i n e
	b n e i
	b n i e
	e b i n
	e b n i
	e i b n
	e i n b
	e n b i 
	e n i b
	i b e n
	i b n e
	i e b n
	i e n b
	i n b e
	i n e b
	n b e i
	n b i e
	n e b i
	n e i b
	n i b e
	n i e b


서로 다른 숫자와 문자로 이루어진 집합과 위치가 주어졌을 때, 그 집합의 순열 중 주어진 위치의 순열을 구하는 프로그램을 작성하시오.

---

## 입력
입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있다. 첫 번째 문자열은 서로 다른 숫자와 알파벳으로 이루어져 있으며, 길이는 최대 10이다. 또한, 사전순 순서대로 주어진다. 문자열 다음에는 찾아야 하는 위치가 주어지며, 이 값은 3,628,800보다 작거나 같은 자연수이다.

---

## 출력
각각의 테스트 케이스마다, 입력으로 주어진 위치에 해당하는 순열을 공백없이 출력한다. 만약, 해당하는 순열이 없는 경우에는 "No permutation"을 출력한다.

---

## 성능 요약
메모리: 380072 KB, 시간: 2080 ms

---

## 풀이

### 풀이 핵심 로직
주어진 문자열의 순열을 구하고, 특정 위치에 해당하는 순열을 출력하는 문제이다. 입력된 문자열의 길이에 따라 순열의 총 개수를 계산하고, 사전순으로 정렬된 순열 목록에서 원하는 위치의 순열을 찾아 출력한다. 만약 위치가 총 순열 개수를 초과하면 "No permutation"을 출력한다.

### 동작 과정
1. 입력을 받아 문자열과 위치를 분리한다. 예를 들어, 입력이 `b e i n 10`이라면, 문자열은 `beain`이고 위치는 `10`이다.
   
2. 문자열의 길이인 `n`을 계산하고, `n!`을 통해 총 순열의 개수를 계산한다. `4!`는 24이다.

3. 만약 위치 `b`가 총 순열 개수 `total`보다 크면 "No permutation"을 출력한다.

4. 백트래킹을 통해 모든 순열을 생성하고 리스트에 저장한다. 이 과정에서 중복을 피하기 위해 방문 여부를 체크한다.

5. 생성된 순열 리스트를 정렬한 후, 위치 `b`에 해당하는 순열을 찾는다. 만약 `b`가 `total // 2` 이하라면 순열 목록에서 `b-1` 번째 순열을, 초과라면 뒤에서 `total - b` 번째 순열을 선택한다.

6. 최종적으로 결과를 출력한다. 예를 들어, `b e i n 10`의 경우, 10번째 순열은 `i n b e`가 된다.

### 시간 복잡도
전체 알고리즘의 시간 복잡도는 O(n!)이다. 이는 n개의 원소로 이루어진 문자열의 모든 순열을 생성해야 하기 때문에, n이 최대 10일 때도 10! = 3,628,800의 순열을 생성해야 한다는 의미이다. 입력의 개수에 따라 반복문이 추가적으로 실행되지만, 각 테스트 케이스의 순열 생성 시간은 여전히 O(n!)로 유지된다.

---

## 코드
```python
import sys, math
input = sys.stdin.readline

result = [] 
visited = [] 

def backtrack(arr, path):
    if len(path) == len(arr):
        result.append("".join(path))
        return
    
    for i in range(len(arr)):
        if not visited[i]:
            visited[i] = True
            backtrack(arr, path + [arr[i]])
            visited[i] = False

while True:
    try:
        a, b = input().split()
        b = int(b)
        a = list(a)
        n = len(a)
        total = math.factorial(n)

        if b > total:
            print(f"{''.join(a)} {b} = No permutation")
            continue

        result = []
        visited = [False] * n
        backtrack(a, [])

        result.sort()
        if b <= total // 2:
            ans = result[b-1]
        else:
            ans = result[-(total-b+1)]

        print(f"{''.join(a)} {b} = {ans}")
        
    except:
        break

```