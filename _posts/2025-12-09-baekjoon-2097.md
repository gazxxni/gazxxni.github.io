---
layout: post
title: "[백준] 2097번 조약돌 (Python)"
date: 2025-12-09
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2097", 수학, 사칙연산]
---

## 문제 링크
[https://www.acmicpc.net/problem/2097](https://www.acmicpc.net/problem/2097)

---

## 문제
당신은 N개의 조약돌을 가지고 있다. 이 조약돌을 좌표평면의 격자점 위에 아무렇게나 떨어뜨렸다. 격자점이란, x좌표와 y좌표 모두가 정수인 지점을 말한다. 이를테면 (1, 1)이나 (0, -9)는 격자점이며, (-2, 3.5)이나 (π, 7.14)는 격자점이 아니다.

모든 조약돌을 포함하는 가장 작은 직사각형을 생각할 수 있다. 예를 들어 세 개의 조약돌을 (2,4), (4, 8), (5,5)에 떨어뜨렸다면, 이 세 조약돌을 모두 포함하는 가장 작은 직사각형은 가로 3, 세로 4인 직사각형이다. 이 경우 직사각형의 둘레는 14가 된다. 직사각형의 가로와 세로 길이는 반드시 1 이상이어야 한다.

조약돌의 개수 N이 주어졌을 때, 조약돌을 좌표평면의 격자점에 적절히 떨어뜨려서 모든 조약돌을 포함하는 직사각형의 둘레를 최소로 하는 프로그램을 작성하시오.

---

## 입력
첫째 줄에 조약돌의 개수 N(1 ≤ n ≤ 500,000,000)이 주어진다.

---

## 출력
첫째 줄에 최소 둘레를 출력한다.

---

## 성능 요약
메모리: 109544 KB, 시간: 96 ms

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 주어진 조약돌의 개수 \(N\)에 대해 가능한 가장 작은 직사각형의 둘레를 계산하는 것입니다. 이를 위해, \(N\)을 두 개의 자연수 \(i\)와 \(j\)의 곱으로 표현하여 \(i \times j \geq N\)이 되도록 하고, 둘레는 \(2 \times (i + j - 2)\)로 구할 수 있습니다. 이때 \(i\)와 \(j\)는 직사각형의 가로와 세로에 해당하며, 가능한 \(i\)와 \(j\)의 조합 중에서 둘레가 최소가 되도록 선택합니다.

### 동작 과정
1. **입력**: \(N\)을 입력받습니다. 예를 들어 \(N = 10\)이라고 가정합니다.
2. **사각형의 가로**: \(i\)를 \(1\)부터 시작하여 \(i*i < N\) 조건을 만족할 때까지 증가시킵니다. \(i\)는 가능한 가로 길이를 나타냅니다. 여기서 \(i\)는 대략적으로 \(\sqrt{N}\)에 가까운 값을 찾게 됩니다.
3. **사각형의 세로**: \(j\)는 \(j = \lceil N / i \rceil\)로 계산합니다. 이로써 \(N\)을 \(i\)로 나누어 떨어지는 최소의 정수를 찾습니다.
4. **특별한 경우 처리**: 만약 \(N\)이 \(1\)에서 \(4\) 사이의 값이라면, 직사각형의 최소 둘레는 항상 \(4\)로 고정됩니다.
5. **둘레 계산**: 일반적인 경우, 직사각형의 둘레는 \(2 \times (i + j - 2)\)로 계산하여 출력합니다.

예시로 \(N = 10\)일 경우:
- \(i\)를 증가시키면, \(i = 4\)일 때 \(i*i = 16\)이 \(10\)보다 크므로, 이전 값 \(i = 3\)이 적합합니다.
- \(j = \lceil 10 / 3 \rceil = 4\)입니다.
- 둘레는 \(2 \times (3 + 4 - 2) = 14\)입니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 \(O(\sqrt{N})\)입니다. \(i\)를 증가시키는 과정에서 최대 \(\sqrt{N}\)만큼 반복하기 때문입니다.

---

## 코드
```python
import sys, math
input = sys.stdin.readline

n = int(input())
i = 1

while i * i < n:
    i += 1

j = math.ceil(n / i)

if 1 <= n <= 4:
    print(4)
else:
    print(2 * (i + j - 2))
```