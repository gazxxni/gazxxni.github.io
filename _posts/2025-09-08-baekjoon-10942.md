---
layout: post
title: "[백준] 10942번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "10942"]
---

## 문제 링크
[https://www.acmicpc.net/problem/10942](https://www.acmicpc.net/problem/10942)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 수열에서 특정 구간이 팰린드롬인지 확인하기 위해 동적 프로그래밍(DP)을 사용합니다. DP 테이블을 사용하여 각 부분 수열의 팰린드롬 여부를 저장하고, 이를 기반으로 구간 쿼리에서 팰린드롬 여부를 빠르게 판단할 수 있습니다.

### 동작 과정
주어진 수열을 통해 DP 테이블을 구성하는 과정을 살펴보겠습니다. 예를 들어, 입력이 다음과 같다고 가정합니다:

```
7
1 2 1 2 1 2 1
4
1 7
2 5
3 4
4 4
```

1. **DP 테이블 초기화**: 
   - `n = 7`로 주어졌으므로, `dp`는 7x7의 2차원 배열입니다. 
   - 대각선 요소(`dp[i][i]`)를 1로 설정하여 각 문자(길이 1)가 팰린드롬임을 기록합니다.
   - 인접한 두 요소가 같은 경우(`board[i] == board[i + 1]`)도 팰린드롬으로 설정합니다.

2. **길이가 3 이상의 부분 수열 처리**:
   - 길이가 3 이상인 모든 부분 수열에 대해 검사합니다.
   - `board[j]`와 `board[j + i - 1]`가 같고, 내부 부분(`board[j+1]`부터 `board[j+i-2]`까지)도 팰린드롬인지 `dp[j + 1][j + i - 2]`를 통해 확인합니다.
   - 이 과정을 통해 DP 테이블을 완성하게 됩니다.

3. **쿼리 처리**:
   - 입력된 쿼리에 대해 `s`와 `e`를 읽고, `dp[s-1][e-1]` 값을 출력하여 해당 구간이 팰린드롬인지 확인합니다.

최종적으로는 쿼리 처리 결과로 `1` 또는 `0`이 출력되며, 이것은 각각 팰린드롬 여부를 나타냅니다.

### 시간 복잡도
DP 테이블을 구성하는 과정은 O(n^2)이며, 쿼리 처리 과정은 O(1)입니다. 따라서 전체 알고리즘의 시간 복잡도는 O(n^2 + m)로 표현할 수 있습니다. 여기서 `n`은 수열의 길이, `m`은 쿼리의 개수입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
board = list(map(int, input().split()))

dp = [[0] * n for _ in range(n)]
for i in range(n):
    dp[i][i] = 1
for i in range(n - 1):
    if board[i] == board[i + 1]:
        dp[i][i + 1] = 1

for i in range(3, n+1):
    for j in range(n - i + 1):
        if board[j] == board[j + i - 1] and dp[j + 1][j + i - 2]:
            dp[j][j + i - 1] = 1

m = int(input())
for _ in range(m):
    s, e = map(int, input().split())
    print(dp[s - 1][e - 1])
```