---
layout: post
title: "[백준] 25501번 (Python)"
date: 2025-10-26
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "25501"]
---

## 문제 링크
[https://www.acmicpc.net/problem/25501](https://www.acmicpc.net/problem/25501)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 문자열이 회문인지 판별하기 위해 재귀를 사용하는 방법을 적용합니다. 문자열의 양 끝에서부터 문자를 비교하면서, 두 문자가 다르면 회문이 아니라고 판단하고, 같으면 재귀적으로 내부 문자열을 계속 비교합니다. 이 과정에서 비교한 문자 수를 카운트하여 최종 결과와 함께 반환합니다.

### 동작 과정
1. 입력으로 주어진 문자열을 읽어옵니다.
2. `isPalindrome` 함수를 호출하여 문자열의 첫 글자와 마지막 글자를 비교합니다. 
3. 만약 두 글자가 같고, 현재 검사할 범위의 시작 인덱스(l)가 끝 인덱스(r)보다 작을 경우 재귀적으로 내부 문자열에 대해 동일한 작업을 수행합니다.
4. 두 글자가 다를 경우, 회문이 아니므로 0을 반환합니다.
5. 모든 문자를 비교한 후 회문임이 확인되면 1을 반환합니다.
6. 이 과정에서 비교한 문자 수를 카운트하여 결과와 함께 출력합니다.

예를 들어, 입력 문자열이 "abccba"일 경우:
- 처음 `l=0`(a)와 `r=5`(a) 비교: 같음
- `l=1`(b)와 `r=4`(b) 비교: 같음
- `l=2`(c)와 `r=3`(c) 비교: 같음
- `l=3`(r=2)와 `r=2`(l=3)에서 종료: 회문으로 판단하여 1과 카운트(3)를 반환.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n)입니다. 문자열의 길이에 따라 최대 n/2번의 비교가 필요하므로, 최악의 경우는 문자열의 절반에 해당하는 비교 횟수가 발생합니다.

---

## 코드
```python
def recursion(s, l, r, cnt):
    if l >= r:
        return 1, cnt
    elif s[l] != s[r]:
        return 0, cnt
    else:
        return recursion(s, l + 1, r - 1, cnt + 1)

def isPalindrome(s):
    return recursion(s, 0, len(s) - 1, 1)

t = int(input())
for _ in range(t):
    s = input().rstrip()
    print(*isPalindrome(s))

```