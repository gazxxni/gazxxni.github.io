---
layout: post
title: "[백준] 17103번 골드바흐 파티션 (Python)"
date: 2026-01-16
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "17103", 수학, 정수론, 소수 판정, 에라토스테네스의 체]
---

## 문제 링크
[https://www.acmicpc.net/problem/17103](https://www.acmicpc.net/problem/17103)

---

## 문제
골드바흐의 추측: 2보다 큰 짝수는 두 소수의 합으로 나타낼 수 있다.


짝수 N을 두 소수의 합으로 나타내는 표현을 골드바흐 파티션이라고 한다. 짝수 N이 주어졌을 때, 골드바흐 파티션의 개수를 구해보자. 두 소수의 순서만 다른 것은 같은 파티션이다.

---

## 입력
첫째 줄에 테스트 케이스의 개수 T (1 ≤ T ≤ 100)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 N은 짝수이고, 2

---

## 출력
각각의 테스트 케이스마다 골드바흐 파티션의 수를 출력한다.

---

## 성능 요약
메모리: 134592 KB, 시간: 212 ms

---

## 풀이

### 풀이 핵심 로직
문제의 핵심은 주어진 짝수 N을 두 소수의 합으로 표현하는 방법을 찾는 것이다. 이를 위해 에라토스테네스의 체를 사용하여 1,000,000 이하의 모든 소수를 미리 구한 후, 각 소수 i에 대해 N - i가 소수인지 확인하여 골드바흐 파티션의 개수를 센다.

### 동작 과정
1. **입력 받기**: 테스트 케이스의 수 T와 각 케이스에 대한 짝수 N을 입력받는다.
2. **소수 구하기**: `primenum` 함수를 통해 1부터 1,000,000까지의 소수를 구한다. 이때, 소수는 리스트로 저장되고, 집합으로도 저장하여 빠른 조회가 가능하도록 한다.
3. **골드바흐 파티션 찾기**:
   - 각 짝수 N에 대해 2부터 N//2까지의 소수 i를 순회한다.
   - i가 N의 절반을 초과하면 반복을 종료한다.
   - N - i가 소수 집합에 존재하는지 확인하고, 존재한다면 cnt를 증가시킨다.
4. **결과 출력**: 각 테스트 케이스에 대해 계산된 파티션 수를 출력한다.

#### 예시 입력 및 단계별 설명
- 입력:
  ```
  3
  8
  10
  12
  ```
- 처리 과정:
  - **첫 번째 테스트 케이스 (N=8)**:
    - 소수 리스트: [2, 3, 5, 7]
    - i=2일 때, 8-2=6 (소수 아님)
    - i=3일 때, 8-3=5 (소수, cnt=1)
    - i=5일 때, 8-5=3 (소수, cnt=2)
    - i=7일 때, 8-7=1 (소수 초과)
    - 결과: 2
  - **두 번째 테스트 케이스 (N=10)**:
    - i=2일 때, 10-2=8 (소수 아님)
    - i=3일 때, 10-3=7 (소수, cnt=1)
    - i=5일 때, 10-5=5 (소수, cnt=2)
    - i=7일 때, 10-7=3 (소수, cnt=3)
    - 결과: 4
  - **세 번째 테스트 케이스 (N=12)**:
    - i=2일 때, 12-2=10 (소수 아님)
    - i=3일 때, 12-3=9 (소수 아님)
    - i=5일 때, 12-5=7 (소수, cnt=1)
    - i=7일 때, 12-7=5 (소수, cnt=2)
    - i=11일 때, 12-11=1 (소수 초과)
    - 결과: 2
- 출력 결과:
  ```
  2
  4
  2
  ```

### 시간 복잡도
- 소수 구하기: O(n log log n) (에라토스테네스의 체)
- 각 테스트 케이스의 소수 탐색: O(m), 여기서 m은 N/2 이하의 소수 개수
- 전체적으로 T개의 테스트 케이스에 대해 O(T * m) 시간 복잡도를 가진다.

---

## 코드
```python
def primenum(n):
    arr = [True] * (n + 1)
    arr[0] = arr[1] = False
    
    for i in range(2, int(n ** 0.5) + 1):
        if arr[i]:
            for j in range(i * i, n + 1, i):
                arr[j] = False
                
    brr = []
    for i in range(2, n + 1):
        if arr[i]:
            brr.append(i)
            
    return brr

a = primenum(1000000)
b = set(a)
t = int(input())

for _ in range(t):
    n = int(input())

    cnt = 0

    for i in a:
        if i > n // 2:
            break
        
        if (n - i) in b:
            cnt += 1
            
    print(cnt)
```