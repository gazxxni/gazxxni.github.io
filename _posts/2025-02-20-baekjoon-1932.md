---
layout: post
title: "[백준] 1932번 (Python)"
date: 2025-02-20
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1932"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1932](https://www.acmicpc.net/problem/1932)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 삼각형 형태의 숫자 배열에서 최댓값 경로를 찾는 문제입니다. 각 숫자는 그 아래에 위치한 두 숫자 중 하나를 선택하여 더할 수 있으며, 최종적으로 가장 아래층에 도달했을 때의 최대 합을 구합니다. 이 문제는 동적 프로그래밍을 통해 해결되며, 각 위치에서 가능한 최댓값을 업데이트하여 최종 결과를 도출합니다.

### 동작 과정
1. **입력 처리**: 첫 줄에서 삼각형의 높이 `n`을 입력받고, 다음 `n`줄에 걸쳐 각 줄의 숫자를 리스트로 변환하여 `arr`에 저장합니다.
   
   예시 입력:
   ```
   5
   7
   3 8
   8 1 0
   2 7 4 4
   4 5 2 6 5
   ```
   `arr`의 초기 상태:
   ```
   [
       [7],
       [3, 8],
       [8, 1, 0],
       [2, 7, 4, 4],
       [4, 5, 2, 6, 5]
   ]
   ```

2. **동적 프로그래밍 적용**: 각 줄을 순회하며, 현재 위치의 값을 그 위치 위의 두 숫자와 더한 최대값으로 업데이트합니다.
   - 첫 번째 열(`j == 0`)의 경우, 위쪽 숫자만 더합니다.
   - 마지막 열(`j == len(arr[i]) - 1`)의 경우, 바로 왼쪽의 숫자만 더합니다.
   - 중간 열의 경우, 위쪽 두 숫자의 최대값을 더합니다.

   예시 진행 과정:
   - `i = 1`: 
     - `arr[1][0]` = `3 + 7` = `10`
     - `arr[1][1]` = `8 + 7` = `15`
   - `i = 2`:
     - `arr[2][0]` = `8 + 10` = `18`
     - `arr[2][1]` = `1 + max(10, 15)` = `16`
     - `arr[2][2]` = `0 + 15` = `15`
   - `i = 3`:
     - `arr[3][0]` = `2 + 18` = `20`
     - `arr[3][1]` = `7 + max(18, 16)` = `25`
     - `arr[3][2]` = `4 + max(16, 15)` = `20`
     - `arr[3][3]` = `4 + 15` = `19`
   - `i = 4`:
     - `arr[4][0]` = `4 + 20` = `24`
     - `arr[4][1]` = `5 + max(20, 25)` = `30`
     - `arr[4][2]` = `2 + max(25, 20)` = `27`
     - `arr[4][3]` = `6 + 20` = `26`
     - `arr[4][4]` = `5 + 19` = `24`

   최종 `arr` 상태:
   ```
   [
       [7],
       [10, 15],
       [18, 16, 15],
       [20, 25, 20, 19],
       [24, 30, 27, 26, 24]
   ]
   ```

3. **결과 출력**: 마지막 줄의 최댓값을 출력합니다.
   - `print(max(arr[n-1]))` → `max([24, 30, 27, 26, 24])` → `30`

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n^2)입니다. 이는 삼각형의 각 층을 순회하며 각 층의 숫자 수에 비례하여 연산을 수행하기 때문입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
arr = [list(map(int, input().split())) for _ in range(n)]

for i in range(1, n):
    for j in range(len(arr[i])):
        if j == 0:
            arr[i][j] = arr[i][j] + arr[i-1][j]
        elif j == len(arr[i]) - 1:
            arr[i][j] = arr[i][j] + arr[i-1][j-1]
        else:
            arr[i][j] = max(arr[i-1][j-1], arr[i-1][j]) + arr[i][j]

print(max(arr[n-1]))
```