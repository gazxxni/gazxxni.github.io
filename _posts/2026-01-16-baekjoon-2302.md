---
layout: post
title: "[백준] 2302번 극장 좌석 (Python)"
date: 2026-01-16
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2302", 다이나믹 프로그래밍]
---

## 문제 링크
[https://www.acmicpc.net/problem/2302](https://www.acmicpc.net/problem/2302)

---

## 문제
어떤 극장의 좌석은 한 줄로 되어 있으며 왼쪽부터 차례대로 1번부터 N번까지 번호가 매겨져 있다. 공연을 보러 온 사람들은 자기의 입장권에 표시되어 있는 좌석에 앉아야 한다. 예를 들어서, 입장권에 5번이 쓰여 있으면 5번 좌석에 앉아야 한다. 단, 자기의 바로 왼쪽 좌석 또는 바로 오른쪽 좌석으로는 자리를 옮길 수 있다. 예를 들어서, 7번 입장권을 가진 사람은 7번 좌석은 물론이고, 6번 좌석이나 8번 좌석에도 앉을 수 있다. 그러나 5번 좌석이나 9번 좌석에는 앉을 수 없다.

그런데 이 극장에는 “VIP 회원”들이 있다. 이 사람들은 반드시 자기 좌석에만 앉아야 하며 옆 좌석으로 자리를 옮길 수 없다.

오늘 공연은 입장권이 매진되어 1번 좌석부터 N번 좌석까지 모든 좌석이 다 팔렸다. VIP 회원들의 좌석 번호들이 주어졌을 때, 사람들이 좌석에 앉는 서로 다른 방법의 가짓수를 구하는 프로그램을 작성하시오.

예를 들어서, 그림과 같이 좌석이 9개이고, 4번 좌석과 7번 좌석이 VIP석인 경우에 는 물론 가능한 배치이다. 또한  와  도 가능한 배치이다. 그러나  와  는 허용되지 않는 배치 방법이다.

---

## 입력
첫째 줄에는 좌석의 개수 N이 입력된다. N은 1 이상 40 이하이다. 둘째 줄에는 고정석의 개수 M이 입력된다. M은 0 이상 N 이하이다. 다음 M 개의 줄에는 고정석의 번호가 작은 수부터 큰 수의 순서로 한 줄에 하나씩 입력된다.

---

## 출력
주어진 조건을 만족하면서 사람들이 좌석에 앉을 수 있는 방법의 가짓수를 출력한다. 방법의 가짓수는 2,000,000,000을 넘지 않는다. (2,000,000,000 31-1)

---

## 성능 요약
메모리: 108384 KB, 시간: 92 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 동적 계획법(DP)을 사용하여 VIP 회원의 좌석을 기준으로 나머지 좌석에 앉을 수 있는 방법의 가짓수를 계산하는 문제입니다. VIP 좌석 사이의 빈 좌석 그룹을 분리하여 각 그룹의 좌석 배치를 계산하고, 이들을 곱하여 전체 가능한 배치를 구합니다.

### 동작 과정
1. **입력 처리**: 첫째 줄에서 좌석 수 N을, 둘째 줄에서 VIP 좌석 수 M을 읽고, 이어서 M개의 VIP 좌석 번호를 입력받습니다.
   
2. **DP 배열 초기화**: DP 배열 `dp[i]`를 정의하여 i개의 좌석에 사람을 앉힐 수 있는 방법의 수를 저장합니다. 기본적으로 `dp[0] = 1`, `dp[1] = 1`로 초기화하고, `dp[2] = dp[1] + dp[0]`의 점화식을 이용하여 DP 테이블을 채워갑니다.

3. **VIP 좌석 처리**: VIP 좌석 사이의 빈 좌석 수를 계산하고, 그 좌석 수를 이용해 해당 구간에 사람을 앉힐 수 있는 방법의 수를 구합니다. 예를 들어, VIP 좌석 4번과 7번 사이에는 2개의 빈 좌석이 있다면, `dp[2]`의 값을 사용합니다.

4. **결과 계산**: 모든 VIP 좌석 사이의 방법 수를 곱하고, 마지막으로 마지막 VIP 좌석 이후의 좌석 수에 대한 방법 수를 곱하여 최종적으로 가능한 배치의 수를 구합니다.

**예시 입력**:
```
9
2
4
7
```
- 이 경우, VIP 좌석 4와 7 사이의 빈 좌석 수는 각각 3 (1, 2, 3)과 2 (5, 6)입니다.
- DP 테이블에 따라:
  - 3개의 좌석에서의 배치 방법: `dp[3] = dp[2] + dp[1] = 2 + 1 = 3`
  - 2개의 좌석에서의 배치 방법: `dp[2] = 2`
- 전체 배치 방법 수: `3 (1-3 사이) * 1 (4) * 2 (5-6 사이) = 6`

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(N)입니다. DP 테이블을 한 번만 채우고, VIP 좌석 수 만큼의 반복문을 통해 계산하므로 효율적입니다.

---

## 코드
```python
import sys

def solve():
    n = int(sys.stdin.readline())
    m = int(sys.stdin.readline())
    vips = [int(sys.stdin.readline()) for _ in range(m)]

    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1
    if n >= 2:
        for i in range(2, n + 1):
            dp[i] = dp[i-1] + dp[i-2]

    ans = 1
    current_pos = 0

    for vip in vips:
        length = vip - current_pos - 1
        ans *= dp[length]
        current_pos = vip

    ans *= dp[n - current_pos]
    print(ans)

solve()
```