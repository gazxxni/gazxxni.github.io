---
layout: post
title: "[백준] 20303번 (Python)"
date: 2025-09-10
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "20303"]
---

## 문제 링크
[https://www.acmicpc.net/problem/20303](https://www.acmicpc.net/problem/20303)

---

## 풀이

### 풀이 핵심 로직
이 문제는 여러 개의 연결 요소로 나뉜 그래프에서 각 연결 요소의 크기와 사탕의 총합을 구한 후, 0/1 배낭 문제를 사용하여 최대 K-1명의 아이를 선택하여 사탕의 총합을 최대화하는 문제입니다. DFS를 통해 각 연결 요소를 탐색하고, 그 결과를 바탕으로 배낭 DP를 진행하여 최적의 해를 구합니다.

### 동작 과정
1. **입력**: 예를 들어, 입력이 `5 4 3`과 `1 2 3 4 5`일 때, 5명의 아이와 4개의 관계가 주어지고, 최대 K는 3입니다.
2. **그래프 구성**: (1,2), (1,3), (2,4), (3,5)의 관계를 통해 그래프를 구성합니다. 이를 통해 연결 요소를 탐색할 수 있습니다.
3. **DFS 탐색**: DFS를 통해 각 연결 요소를 탐색합니다. 예를 들어, 정점 1에서 시작하여 연결된 정점들을 방문하면서 크기와 사탕의 총합을 계산합니다. 첫 번째 연결 요소에서 (4, 10)과 같이 크기 4와 사탕 합 10을 얻을 수 있습니다.
4. **DP 배열 초기화**: DP 배열을 초기화하고, 각 연결 요소의 크기와 사탕 합을 가지고 0/1 배낭 DP를 수행합니다. 요소의 크기가 3보다 작거나 같은 경우에만 DP 배열을 업데이트합니다.
5. **최대 사탕 합 출력**: DP 배열에서 최대 값을 찾아 출력합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n + m + k)입니다. DFS 탐색이 O(n + m)이고, 배낭 DP 과정이 O(k * c) (c는 연결 요소의 수)로 진행되기 때문에 전체적으로 O(n + m + k)로 표현할 수 있습니다.

---

## 코드
```python
import sys
input = sys.stdin.readline
sys.setrecursionlimit(1000000)

n, m, k = map(int, input().split())
candy = [0] + list(map(int, input().split()))
relation = [[] for _ in range(n + 1)]
for _ in range(m):
    a, b = map(int, input().split())
    relation[a].append(b)
    relation[b].append(a)
    
visited = [False] * (n + 1)

def dfs(v):
    """
    정점 v가 속한 연결요소를 DFS로 탐색하여
    요소의 크기(size: 아이 수)와 사탕 총합(total)을 반환한다.
    """
    visited[v] = True
    size = 1
    total = candy[v]
    
    for next in relation[v]:
        if not visited[next]:
            sub_size, sub_total = dfs(next)
            size += sub_size
            total += sub_total
            
    return size, total

# 모든 연결요소를 (요소 크기, 사탕 합) 형태로 수집
components = []
for i in range(1, n + 1):
    if not visited[i]:
        comp_size, comp_candy = dfs(i)
        components.append((comp_size, comp_candy))

# 0/1 배낭 DP 준비
# 울음 인원 합이 K 이상이 되면 들키므로, 선택 가능한 최대 인원 합은 K-1
capacity = k - 1 
dp = [0] * (capacity + 1)

# 각 연결요소는 "한 번만" 선택 가능 → 0/1 배낭
# weight = 요소 크기(아이 수), value = 요소의 사탕 합
for size, value in components:
    if size > capacity:
        continue
    
    for w in range(capacity, size - 1, -1):
        dp[w] = max(dp[w], dp[w - size] + value)

print(max(dp))
```