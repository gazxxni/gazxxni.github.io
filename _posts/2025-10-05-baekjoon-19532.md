---
layout: post
title: "[백준] 19532번 (Python)"
date: 2025-10-05
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "19532"]
---

## 문제 링크
[https://www.acmicpc.net/problem/19532](https://www.acmicpc.net/problem/19532)

---

## 풀이

### 풀이 핵심 로직
이 코드는 두 개의 선형 방정식 시스템을 해결하기 위해 브루트 포스(완전 탐색) 방법을 사용합니다. 주어진 방정식의 해를 찾기 위해 두 개의 변수 \(x\)와 \(y\)의 가능한 값을 모두 탐색하며, 각 조합이 두 방정식을 만족하는지를 확인합니다.

### 동작 과정
1. **입력**: 정수 \(a, b, c, d, e, f\)를 입력받습니다. 이는 두 방정식 \(ax + by = c\)와 \(dx + ey = f\)의 계수입니다.
2. **변수 초기화**: \(x\)와 \(y\)를 0으로 초기화합니다.
3. **이중 반복문**: 
   - 외부 반복문에서 \(i\)를 \(-999\)부터 \(999\)까지 탐색합니다. 이는 \(x\)의 모든 가능한 값입니다.
   - 내부 반복문에서 \(j\)를 \(-999\)부터 \(999\)까지 탐색합니다. 이는 \(y\)의 모든 가능한 값입니다.
4. **조건 검사**: 각 조합 \((i, j)\)에 대해 두 방정식을 모두 검사합니다.
   - \(a \cdot i + b \cdot j == c\)와 \(d \cdot i + e \cdot j == f\)가 모두 참인지 체크합니다.
5. **해 찾기**: 두 조건을 만족하는 \(i\)와 \(j\)가 발견되면, \(x\)와 \(y\)를 각각 \(i\)와 \(j\)로 업데이트하고 반복문을 종료합니다.
6. **출력**: 최종적으로 \(x\)와 \(y\)의 값을 출력합니다.

#### 예시 입력
예를 들어 입력이 "1 1 1 1 1 1"이라면:
- 방정식은 \(x + y = 1\)과 \(x + y = 1\)입니다.
- \(i\)와 \(j\)를 \(-999\)부터 \(999\)까지 탐색하면서 \(x + y = 1\)을 만족하는 조합을 찾게 됩니다.
- \(i = 0, j = 1\) 또는 \(i = 1, j = 0\)이 조건을 만족하므로, 이에 따라 \(x\)와 \(y\)가 출력됩니다.

### 시간 복잡도
최악의 경우 두 개의 중첩된 반복문이 각각 1999회의 반복을 수행하므로, 전체 시간 복잡도는 \(O(n^2)\)입니다. 여기서 \(n = 1999\)이고, 이는 상수로 간주할 수 있습니다. 따라서, 시간 복잡도는 \(O(1)\)으로 간주될 수 있습니다.

---

## 코드
```python
a, b, c, d, e, f = map(int, input().split())
x = 0
y = 0
for i in range(-999, 1000):
    for j in range(-999, 1000):
        if a * i + b * j == c and d * i + e * j == f:
            x = i
            y = j
            break

print(x, y)
```