---
layout: post
title: "[백준] 12908번 텔레포트 3 (Python)"
date: 2025-12-07
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "12908", 그래프 이론, 브루트포스 알고리즘, 최단 경로, 플로이드–워셜]
---

## 문제 링크
[https://www.acmicpc.net/problem/12908](https://www.acmicpc.net/problem/12908)

---

## 문제
수빈이는 크기가 무한대인 격자판 위에 살고 있다. 격자판의 각 점은 두 정수의 쌍 (x, y)로 나타낼 수 있다.

제일 처음에 수빈이의 위치는 (xs, ys)이고, 집이 위치한 (xe, ye)로 이동하려고 한다.

수빈이는 두 가지 방법으로 이동할 수 있다. 첫 번째 방법은 점프를 하는 것이다. 예를 들어 (x, y)에 있는 경우에 (x+1, y), (x-1, y), (x, y+1), (x, y-1)로 이동할 수 있다. 점프는 1초가 걸린다.

두 번째 방법은 텔레포트를 사용하는 것이다. 텔레포트를 할 수 있는 방법은 총 세 가지가 있으며, 미리 정해져 있다. 텔레포트는 네 좌표 (x1, y1), (x2, y2)로 나타낼 수 있으며, (x1, y1)에서 (x2, y2)로 또는 (x2, y2)에서 (x1, y1)로 이동할 수 있다는 것이다. 텔레포트는 10초가 걸린다.

수빈이의 위치와 집의 위치가 주어졌을 때, 집에 가는 가장 빠른 시간을 구하는 프로그램을 작성하시오.

---

## 입력
첫째 줄에 xs와 ys가, 둘째 줄에 xe, ye가 주어진다. (0 ≤ xs, ys, xe, ye ≤ 1,000,000,000)

셋째 줄부터 세 개의 줄에는 텔레포트의 정보 x1, y1, x2, y2가 주어진다. (0 ≤ x1, y1, x2, y2 ≤ 1,000,000,000)

입력으로 주어지는 모든 좌표 8개는 서로 다르다.

---

## 출력
수빈이가 집에 가는 가장 빠른 시간을 출력한다.

---

## 성능 요약
메모리: 111284 KB, 시간: 120 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 수빈이가 주어진 위치에서 집까지 가는 최단 경로를 찾는 문제로, 주어진 텔레포트 지점을 활용하여 이동 시간을 최소화해야 한다. 수빈이는 두 가지 이동 방법(점프와 텔레포트)을 사용할 수 있으며, 이를 다익스트라 알고리즘을 통해 최단 경로를 계산한다. 기본적으로는 점프를 통해 집까지의 거리를 계산하고, 텔레포트를 활용하여 더 빠른 경로를 탐색한다.

### 동작 과정
1. **입력 받기**: 수빈이의 시작 위치 `(xs, ys)`와 집의 위치 `(xe, ye)`를 입력받는다. 이후 3개의 텔레포트 정보도 입력받는다.
   
2. **기본 거리 계산**: 점프를 통해 집까지 가는 기본 거리는 `abs(xs - xe) + abs(ys - ye)`로 계산한다.

3. **그래프 구조 설정**: 텔레포트 정보를 기반으로 연결된 노드(좌표)를 딕셔너리 형태로 저장한다. 각 노드는 텔레포트 연결과 함께 이동 시간을 저장한다.

4. **다익스트라 알고리즘 수행**:
   - 시작 노드에서 다른 노드로의 최단 경로를 계산하기 위해 우선순위 큐를 사용한다.
   - 현재 위치에서 집까지의 거리와 텔레포트로 이동 가능한 노드들을 탐색한다.
   - 각 노드에 대해 점프를 통해 갈 수 있는 거리를 계산하고, 텔레포트를 통해 이동할 수 있는 노드를 탐색하여 새로운 경로를 업데이트한다.

5. **최소 시간 출력**: 다익스트라 알고리즘이 완료되면 계산된 최소 시간을 출력한다.

**예시 입력**:
```
0 0
1 1
0 1 1 0
0 1 1 1
1 0 1 1
```
- 시작 위치는 `(0, 0)`, 집은 `(1, 1)`이다.
- 첫 번째 텔레포트는 `(0, 1)`과 `(1, 0)` 간의 연결, 두 번째와 세 번째 텔레포트도 각각 두 점 간의 연결을 제공한다.

**단계별 설명**:
- 기본 점프를 통해 집까지 가는 거리는 `2초`.
- 첫 번째 텔레포트를 사용하여 `(0, 0)`에서 `(0, 1)`로 이동 후, `(1, 1)`로 점프하면 `1초 + 10초 = 11초`가 소요된다.
- 두 번째 텔레포트를 사용하여 `(0, 0)`에서 `(1, 0)`으로 이동 후, `(1, 1)`로 점프하면 `1초 + 10초 = 11초`가 소요된다.
- 결론적으로, 집까지 가는 가장 빠른 방법은 기본 점프를 이용한 `2초`이다.

### 시간 복잡도
- 다익스트라 알고리즘의 시간 복잡도는 `O((E + V) log V)`이다. 여기서 `E`는 엣지의 수, `V`는 정점의 수를 의미한다. 이 문제에서는 최대 5개의 노드(시작점 + 3 텔레포인트 + 집)로 제한되므로, 최악의 경우에도 적은 수의 계산만을 수행한다.

---

## 코드
```python
import sys, heapq
from collections import defaultdict
'''
BFS로 풀면 모든 지점을 다 돌아야해서 시간초과
-> 다익스트라로 텔레포트 사용 구간만 검사, 텔레포트 안 쓰면 그냥 긴 거리가 답
'''
input = sys.stdin.readline

xs, ys = map(int, input().split())
xe, ye = map(int, input().split())

start_node = (xs, ys)
end_node = (xe, ye)

tp_dic = defaultdict(list)
tp_node = set()

for _ in range(3):
    x1, y1, x2, y2 = map(int, input().split())
    node1 = (x1, y1)
    node2 = (x2, y2)
    
    tp_node.add(node1)
    tp_node.add(node2)

    tp_dic[node1].append((node2, 10))
    tp_dic[node2].append((node1, 10))

key_nodes = list(tp_node)
key_nodes.append(start_node)

distances = {node: float('inf') for node in key_nodes}
distances[start_node] = 0

pq = [(0, start_node)]

# 시작점에서 도착점까지 가는 비용 (이게 기본 답)
min_cost = abs(xs - xe) + abs(ys - ye)

while pq:
    current_cost, current_node = heapq.heappop(pq)

    if current_cost > distances[current_node]:
        continue

    # 현재 위치에서 도착점까지 비용
    # (현재까지 비용 + 지금 위치에서 도착점까지 걷는 비용)
    cost_via_current = current_cost + abs(current_node[0] - end_node[0]) + abs(current_node[1] - end_node[1])
    min_cost = min(min_cost, cost_via_current)
    
    # 텔레포트 
    if current_node in tp_dic:
        for next_node, tele_cost in tp_dic[current_node]:
            new_cost = current_cost + tele_cost
            if new_cost < distances[next_node]:
                distances[next_node] = new_cost
                heapq.heappush(pq, (new_cost, next_node))

    # 현재 위치에서 모든 텔레포트 지점까지 비용 계산
    for next_tp_node in tp_node:
        if current_node == next_tp_node:
            continue
            
        walk_cost = abs(current_node[0] - next_tp_node[0]) + abs(current_node[1] - next_tp_node[1])
        new_cost = current_cost + walk_cost
        
        if new_cost < distances[next_tp_node]:
            distances[next_tp_node] = new_cost
            heapq.heappush(pq, (new_cost, next_tp_node))

print(min_cost)
```