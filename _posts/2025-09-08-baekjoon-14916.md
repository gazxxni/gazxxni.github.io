---
layout: post
title: "[백준] 14916번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "14916"]
---

## 문제 링크
[https://www.acmicpc.net/problem/14916](https://www.acmicpc.net/problem/14916)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 주어진 금액 `n`을 5원과 2원 동전으로 최소한의 개수로 만들기 위해, 먼저 가능한 최대한의 5원 동전을 사용하고 남은 금액을 2원 동전으로 처리하는 것입니다. 만약 5원 동전의 개수를 줄여가면서 남은 금액이 2원으로 나누어 떨어질 때까지 반복하며, 그 결과로 최소 동전 개수를 구합니다.

### 동작 과정
1. **입력**: `n`을 입력받습니다. 예를 들어, `n = 11`이라고 가정합시다.
2. **5원 동전 계산**: `five`는 5원 동전의 최대 개수를 계산합니다. `five = n // 5` → `five = 11 // 5 = 2`.
3. **반복문 시작**: `while True`로 무한 루프를 시작합니다.
   - `money = n - 5 * five` → `money = 11 - 5 * 2 = 1`.
4. **2원 동전으로 나누기**: `if money % 2 == 0`를 검사합니다. 이 경우 `1 % 2`는 1이므로 조건을 만족하지 않습니다.
5. **5원 동전 개수 줄이기**: `five -= 1` → `five = 1`.
6. **다시 계산**: `money = 11 - 5 * 1 = 6`.
7. **2원 동전으로 나누기**: `6 % 2 == 0`이므로 조건을 만족합니다. `two = money // 2` → `two = 6 // 2 = 3`.
8. **결과 출력**: `print(five + two)`를 실행하여 `1 + 3 = 4`를 출력합니다.
9. **종료**: `break`로 루프를 종료합니다.
10. **예외 처리**: 만약 `five`가 0보다 작아지면 `print(-1)`로 결과를 출력하고 종료합니다.

### 시간 복잡도
이 알고리즘은 최악의 경우 5원 동전의 개수를 줄여가는 과정을 간단한 반복문으로 해결하므로, 시간 복잡도는 O(n/5)로 간주할 수 있습니다. 그러나 실제로는 동전 개수를 줄이는 것이 한정적이므로, 전체적으로 상수 시간 O(1)에 가까운 성능을 보입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n = int(input())

five = n // 5

while True:
    money = n - 5 * five
    
    if money % 2 == 0:
        two = money // 2
        print(five + two)
        break
    
    else:
        five -= 1
        
        if five < 0:
            print(-1)
            break
```