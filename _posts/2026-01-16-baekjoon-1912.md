---
layout: post
title: "[백준] 1912번 연속합 (Python)"
date: 2026-01-16
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1912", 다이나믹 프로그래밍, 최대 부분 배열 문제]
---

## 문제 링크
[https://www.acmicpc.net/problem/1912](https://www.acmicpc.net/problem/1912)

---

## 문제
n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.

예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.

---

## 입력
첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다. 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.

---

## 출력
첫째 줄에 답을 출력한다.

---

## 성능 요약
메모리: 121976 KB, 시간: 104 ms

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 동적 프로그래밍을 사용하여 연속된 부분 배열의 최대 합을 구하는 것이다. 현재 원소를 포함한 연속합이 이전 원소의 연속합에 더한 것보다 더 크다면 그 값을 선택하고, 그렇지 않으면 현재 원소만을 선택하여 새로운 연속합을 시작한다. 이를 통해 각 원소에 대해 최대 연속합을 갱신해 나가며 최종적으로 최대 값을 구한다.

### 동작 과정
주어진 수열이 `10, -4, 3, 1, 5, 6, -35, 12, 21, -1`이라고 가정하자.

1. **초기화**: 
   - `n = 10` (원소의 개수)
   - `arr = [10, -4, 3, 1, 5, 6, -35, 12, 21, -1]`
   - `dp[0] = arr[0]` → `dp[0] = 10`
   - `ans = arr[0]` → `ans = 10`

2. **첫 번째 반복 (i = 1)**:
   - `dp[1] = max(arr[1], dp[0] + arr[1]) = max(-4, 10 - 4) = max(-4, 6) = 6`
   - `ans = max(ans, dp[1]) = max(10, 6) = 10`

3. **두 번째 반복 (i = 2)**:
   - `dp[2] = max(arr[2], dp[1] + arr[2]) = max(3, 6 + 3) = max(3, 9) = 9`
   - `ans = max(ans, dp[2]) = max(10, 9) = 10`

4. **세 번째 반복 (i = 3)**:
   - `dp[3] = max(arr[3], dp[2] + arr[3]) = max(1, 9 + 1) = max(1, 10) = 10`
   - `ans = max(ans, dp[3]) = max(10, 10) = 10`

5. **네 번째 반복 (i = 4)**:
   - `dp[4] = max(arr[4], dp[3] + arr[4]) = max(5, 10 + 5) = max(5, 15) = 15`
   - `ans = max(ans, dp[4]) = max(10, 15) = 15`

6. **다섯 번째 반복 (i = 5)**:
   - `dp[5] = max(arr[5], dp[4] + arr[5]) = max(6, 15 + 6) = max(6, 21) = 21`
   - `ans = max(ans, dp[5]) = max(15, 21) = 21`

7. **여섯 번째 반복 (i = 6)**:
   - `dp[6] = max(arr[6], dp[5] + arr[6]) = max(-35, 21 - 35) = max(-35, -14) = -14`
   - `ans = max(ans, dp[6]) = max(21, -14) = 21`

8. **일곱 번째 반복 (i = 7)**:
   - `dp[7] = max(arr[7], dp[6] + arr[7]) = max(12, -14 + 12) = max(12, -2) = 12`
   - `ans = max(ans, dp[7]) = max(21, 12) = 21`

9. **여덟 번째 반복 (i = 8)**:
   - `dp[8] = max(arr[8], dp[7] + arr[8]) = max(21, 12 + 21) = max(21, 33) = 33`
   - `ans = max(ans, dp[8]) = max(21, 33) = 33`

10. **아홉 번째 반복 (i = 9)**:
    - `dp[9] = max(arr[9], dp[8] + arr[9]) = max(-1, 33 - 1) = max(-1, 32) = 32`
    - `ans = max(ans, dp[9]) = max(33, 32) = 33`

최종적으로 `ans`의 값이 33이므로, 주어진 수

---

## 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
arr = list(map(int, input().split()))

dp = [0] * (n + 1)
dp[0] = arr[0]
ans = arr[0]

for i in range(1, n):
    dp[i] = max(arr[i], dp[i - 1] + arr[i])
    ans = max(ans, dp[i])


print(ans)
```