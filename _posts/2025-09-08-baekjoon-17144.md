---
layout: post
title: "[백준] 17144번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "17144"]
---

## 문제 링크
[https://www.acmicpc.net/problem/17144](https://www.acmicpc.net/problem/17144)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 공기청정기의 위치를 기준으로 미세먼지를 확산시키고, 그 후 청정기를 활성화하여 미세먼지를 제거하는 것이다. 매 시간마다 미세먼지가 주변으로 확산된 후 공기청정기가 작동하여 위와 아래에서 각각 미세먼지를 순환시키며 청소하게 된다.

### 동작 과정
주어진 입력 예시인 `5 5 1`과 아래의 `board`를 사용하여 단계별로 설명해 보겠습니다:

```
0 0 0 0 0
0 0 0 0 0
0 -1 0 0 0
0 0 0 0 0
0 0 0 0 0
```

1. **미세먼지 확산**:
   - 각 칸의 미세먼지 양을 5로 나누어 주변 4방향에 확산할 수 있는 양을 계산합니다.
   - 예를 들어, `(2, 1)` 위치는 -1 (공기청정기)로 미세먼지 확산이 이루어지지 않으며, 나머지 칸은 0이므로 아무것도 확산되지 않습니다.
   - 따라서 `updated` 보드는 여전히 모든 칸이 0이 됩니다.

2. **공기청정기 활성화**:
   - `activate` 함수가 호출되면, 공기청정기가 있는 위치를 기준으로 위쪽(2, 1)과 아래쪽(3, 1)에서 미세먼지를 순환시킵니다.
   - 위쪽 청정기는 (0, 0), (0, 1), (0, 2), (0, 3), (0, 4)에서 미세먼지를 왼쪽으로 이동시키고, 아래쪽 청정기는 (4, 0), (4, 1), ..., (4, 4)에서 미세먼지를 왼쪽으로 이동시킵니다.
   - 청정기 바로 다음 칸(1, 1)과 (3, 1)은 0으로 설정하여 청정기가 있는 공간을 비웁니다.

3. **미세먼지 합산**:
   - `sum_dust` 함수가 호출되어 보드의 모든 칸을 합산하여 최종적으로 남아 있는 미세먼지를 계산합니다. 
   - 위 예시에서는 모든 칸이 0이므로 결과는 2 (두 개의 청정기)입니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(t * r * c)입니다. 여기서 `t`는 시간(step) 수, `r`은 행(row)의 수, `c`는 열(column)의 수입니다. 각 시간에 대해 미세먼지 확산과 공기청정기 작동을 위해 전체 보드를 한 번씩 순회하기 때문에 이와 같이 계산됩니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

r, c, t = map(int, input().split())
board = [list(map(int, input().split())) for _ in range(r)]

def diffuse():
    directions = [(1, 0), (-1, 0), (0, -1), (0, 1)]

    amount = [[board[i][j] // 5 for j in range(c)] for i in range(r)]
    updated = [[0] * c for _ in range(r)]

    filter = []
    for i in range(r):
        for j in range(c):
            if board[i][j] == -1:
                filter.append(i)
                updated[i][j] = -1
                continue

            count = 4
            added = 0
            for d in directions:
                x, y = i + d[0], j + d[1]

                if x < 0 or x >= r or y < 0 or y >= c or board[x][y] == -1:
                    count -= 1
                else:
                    added += amount[x][y]

            updated[i][j] = board[i][j] - (amount[i][j] * count) + added

    return filter[0], filter[1], updated

def activate(f_x, f_y):

    for row in range(f_x - 1, 0, -1):
        board[row][0] = board[row - 1][0]
    for col in range(c - 1):
        board[0][col] = board[0][col + 1]
    for row in range(f_x):
        board[row][-1] = board[row + 1][-1]
    for col in range(c - 1, 0, -1):
        board[f_x][col] = board[f_x][col - 1]
    board[f_x][1] = 0

    for row in range(f_y + 1, r - 1):
        board[row][0] = board[row + 1][0]
    for col in range(c - 1):
        board[-1][col] = board[-1][col + 1]
    for row in range(r - 1, f_y, -1):
        board[row][-1] = board[row - 1][-1]
    for col in range(c - 1, 0, -1):
        board[f_y][col] = board[f_y][col - 1]
    board[f_y][1] = 0

def sum_dust():
    result = 0
    for row in board:
        result += sum(row)
    return result + 2 

for _ in range(t):
    x, y, board = diffuse()
    activate(x, y)

print(sum_dust())

```