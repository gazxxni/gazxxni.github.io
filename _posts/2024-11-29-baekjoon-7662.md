---
layout: post
title: "[백준] 7662번 (Python)"
date: 2024-11-29
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "7662"]
---

## 문제 링크
[https://www.acmicpc.net/problem/7662](https://www.acmicpc.net/problem/7662)

---

## 풀이

### 풀이 핵심 로직
이 문제는 이중 힙을 이용하여 삽입 및 삭제 연산을 효율적으로 처리하는 방식으로 해결합니다. 최소 힙과 최대 힙을 각각 사용하여 최솟값과 최댓값을 빠르게 추출할 수 있도록 하며, 삭제된 원소를 추적하기 위해 추가적인 배열을 활용합니다. 이를 통해 삽입과 삭제가 동시에 이루어질 때도 올바른 최솟값과 최댓값을 유지할 수 있습니다.

### 동작 과정
1. **입력**: 여러 테스트 케이스가 주어지며, 각 테스트 케이스마다 'I'와 숫자 혹은 'D'와 숫자가 주어집니다.
2. **예시 입력**:
   ```
   1          # 테스트 케이스 수
   7          # 명령 수
   I 5        # 5 삽입
   I 3        # 3 삽입
   I 7        # 7 삽입
   D 1        # 최대값 삭제
   D -1       # 최소값 삭제
   I 2        # 2 삽입
   D 1        # 최대값 삭제
   ```
3. **처리 과정**:
   - `I 5`: 최소 힙에 (5, 0), 최대 힙에 (-5, 0) 추가
   - `I 3`: 최소 힙에 (3, 1), 최대 힙에 (-3, 1) 추가
   - `I 7`: 최소 힙에 (7, 2), 최대 힙에 (-7, 2) 추가
   - `D 1`: 최대 힙에서 (-7, 2) 제거, `check` 배열에서 삭제된 인덱스 표시
   - `D -1`: 최소 힙에서 (3, 1) 제거, `check` 배열에서 삭제된 인덱스 표시
   - `I 2`: 최소 힙에 (2, 3), 최대 힙에 (-2, 3) 추가
   - `D 1`: 최대 힙에서 (-5, 0) 제거, `check` 배열에서 삭제된 인덱스 표시
4. **결과**: 최종적으로 남아있는 원소들을 기준으로 최댓값과 최솟값을 출력하며, 만약 힙이 비어있다면 "EMPTY"를 출력합니다.

### 시간 복잡도
각 테스트 케이스의 시간 복잡도는 O(k log k)입니다. 여기서 k는 명령의 수로, 각 삽입 및 삭제 연산이 로그 시간에 이루어지기 때문입니다. 추가적으로, 동기화 과정에서 힙에서 삭제된 원소를 제거하는 작업이 포함되어 있지만, 전체적으로 이중 힙을 통해 효율적으로 관리되므로 여전히 O(k log k)로 평가할 수 있습니다.

---

## 코드
```python
import sys
import heapq

input = sys.stdin.readline

T = int(input()) 

for _ in range(T):
    min_heap = [] 
    max_heap = [] 
    k = int(input())  
    check = [1] * k  # 삽입된 숫자의 유효성 여부를 저장 (1: 유효, 0: 삭제됨)

    for i in range(k):
        cal, num = input().split()  
        num = int(num)  

        if cal == "I": 
            heapq.heappush(min_heap, (num, i))
            heapq.heappush(max_heap, (-num, i))

        else:  
            if num == -1:
                if min_heap:  # 최소 힙이 비어 있지 않은 경우
                    # 최소 힙에서 가장 작은 값을 제거하고 해당 인덱스를 `check`에서 0으로 표시
                    check[heapq.heappop(min_heap)[1]] = 0
            elif num == 1:
                if max_heap:  # 최대 힙이 비어 있지 않은 경우
                    # 최대 힙에서 가장 큰 값을 제거하고 해당 인덱스를 `check`에서 0으로 표시
                    check[heapq.heappop(max_heap)[1]] = 0

        # 최소 힙에서 이미 삭제된 원소를 제거 (동기화)
        while min_heap and check[min_heap[0][1]] == 0:
            heapq.heappop(min_heap)

        # 최대 힙에서 이미 삭제된 원소를 제거 (동기화)
        while max_heap and check[max_heap[0][1]] == 0:
            heapq.heappop(max_heap)

    if not min_heap: 
        print("EMPTY")
    else:
        print(-max_heap[0][0], min_heap[0][0])

```