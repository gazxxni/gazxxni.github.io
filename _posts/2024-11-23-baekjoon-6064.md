---
layout: post
title: "[백준] 6064번 (Python)"
date: 2024-11-23
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "6064"]
---

## 문제 링크
[https://www.acmicpc.net/problem/6064](https://www.acmicpc.net/problem/6064)

---

## 풀이

### 풀이 핵심 로직
이 문제는 두 개의 주기가 있는 수열에서 특정 조건을 만족하는 숫자를 찾는 문제입니다. 주기 m과 n을 가진 수열에서 각각의 주기에서 x와 y에 해당하는 값을 찾는 것이 목표입니다. 이를 위해 x에서 시작하여 m씩 증가시키면서, 해당 값이 n에 대해 조건을 만족하는지를 확인합니다.

### 동작 과정
예를 들어, 입력으로 `3 4 2 3`이 주어진다고 가정해 보겠습니다. (m=3, n=4, x=2, y=3)

1. **초기 설정**: `k`를 x로 초기화합니다. 따라서 `k = 2`.
2. **조건 체크**:
   - `k`에 대해 `(k-x) % m == 0`과 `(k-y) % n == 0`을 체크합니다.
   - 첫 번째 조건: `(2-2) % 3 == 0` → True
   - 두 번째 조건: `(2-3) % 4 == -1 % 4 == 3` → False
3. **k 증가**: k에 m을 더해 줍니다. 이제 `k = 5`.
4. **조건 체크**:
   - 첫 번째 조건: `(5-2) % 3 == 3 % 3 == 0` → True
   - 두 번째 조건: `(5-3) % 4 == 2 % 4 == 2` → False
5. **k 증가**: k에 m을 다시 더해 줍니다. `k = 8`.
6. **조건 체크**:
   - 첫 번째 조건: `(8-2) % 3 == 6 % 3 == 0` → True
   - 두 번째 조건: `(8-3) % 4 == 5 % 4 == 1` → False
7. **k 증가**: k를 또 더해 줍니다. `k = 11`.
8. **조건 체크**:
   - 첫 번째 조건: `(11-2) % 3 == 9 % 3 == 0` → True
   - 두 번째 조건: `(11-3) % 4 == 8 % 4 == 0` → True
9. **결과**: 두 조건을 모두 만족했으므로, `11`을 반환합니다.

이 과정을 반복하며 `k`가 `m*n`을 초과하는 경우에 도달하면 -1을 반환합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n)입니다. 최악의 경우 k가 m*n에 도달할 때까지 반복하므로, n의 크기에 비례하는 시간 복잡도를 가집니다.

---

## 코드
```python
import sys

t = int(input())


def calculate(m, n, x, y):
    k = x
    while k <= m * n:
        if (k-x) % m == 0 and (k-y) % n == 0:
            return k
        k += m
    
    return -1

for _ in range(t):  
    m, n, x, y = map(int, input().split())
    
    print(calculate(m, n, x, y))
```