---
layout: post
title: "[백준] 11049번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "11049"]
---

## 문제 링크
[https://www.acmicpc.net/problem/11049](https://www.acmicpc.net/problem/11049)

---

## 풀이

### 풀이 핵심 로직
이 문제는 행렬 곱셈의 최소 비용을 계산하는 동적 프로그래밍 문제입니다. 주어진 행렬들의 차원 정보를 이용해 최적의 곱셈 순서를 찾아 최소 곱셈 횟수를 계산합니다. 동적 프로그래밍을 통해 부분 문제의 최적 해를 저장하고 이를 이용하여 더 큰 문제를 해결합니다.

### 동작 과정
1. **입력 처리**: 주어진 행렬의 크기를 입력받아 `size` 리스트에 저장합니다. 각 행렬의 차원은 `size[i]`와 `size[i+1]`로 정의됩니다.
   
   예를 들어, 입력이 다음과 같다면:
   ```
   3
   10 20
   20 30
   30 40
   ```
   `size` 리스트는 `[10, 20, 30, 40]`가 됩니다.

2. **DP 테이블 초기화**: `dp` 리스트를 생성하여 각 행렬 곱셈의 최소 비용을 저장합니다. `dp[i][j]`는 행렬 `i`부터 `j`까지의 최소 곱셈 횟수를 의미합니다. 처음에는 모든 값을 0으로 초기화합니다.

3. **동적 프로그래밍 반복**: 길이를 2부터 n까지 증가시키면서 각 서브문제의 최소 비용을 계산합니다.
   - 각 서브문제에 대해 시작 인덱스 `i`와 끝 인덱스 `j`를 설정하고, 가능한 모든 분할 지점 `k`를 통해 최소 비용을 계산합니다.
   - `dp[i][j]`는 `dp[i][k]`와 `dp[k+1][j]`의 합과 행렬 곱셈 비용(`size[i] * size[k+1] * size[j+1]`)을 더한 값 중 최소값으로 갱신됩니다.

4. **결과 출력**: 최종적으로 `dp[0][n-1]`에는 모든 행렬을 곱셈하는 최소 비용이 저장되어 출력됩니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 \(O(n^3)\)입니다. 이는 3중 반복문(길이, 시작 인덱스, 분할 지점)을 사용하여 모든 서브문제를 해결하기 때문입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
arr = []
size = []

for i in range(n):
    r, c = map(int, input().split())
    
    if i == 0:
        size.append(r)
        
    size.append(c)
    
dp = [[0] * n for _ in range(n)]

for length in range(2, n + 1):
    for i in range(n - length + 1):
        j = i + length - 1
        dp[i][j] = float('inf')
        
        for k in range(i, j):
            c = dp[i][k] + dp[k + 1][j] + size[i] * size[k + 1] * size[j + 1]
            dp[i][j] = min(dp[i][j], c)
            
print(dp[0][n - 1])
```