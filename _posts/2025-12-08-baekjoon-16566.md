---
layout: post
title: "[백준] 16566번 카드 게임 (Python)"
date: 2025-12-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "16566", 자료 구조, 이분 탐색, 분리 집합]
---

## 문제 링크
[https://www.acmicpc.net/problem/16566](https://www.acmicpc.net/problem/16566)

---

## 문제
철수와 민수는 카드 게임을 즐겨한다. 이 카드 게임의 규칙은 다음과 같다.


	N개의 빨간색 카드가 있다. 각각의 카드는 순서대로 1부터 N까지 번호가 매겨져 있다. 이 중에서 M개의 카드를 고른다.
	N개의 파란색 카드가 있다. 각각의 카드는 순서대로 1부터 N까지 번호가 매겨져 있다. 이 중에서 빨간색에서 고른 번호와 같은 파란색 카드 M개를 고른다.
	철수는 빨간색 카드를 가지고 민수는 파란색 카드를 가진다.
	철수와 민수는 고른 카드 중에 1장을 뒤집어진 상태로 낸다. 그리고 카드를 다시 뒤집어서 번호가 큰 사람이 이긴다. 이 동작을 K번 해서 더 많이 이긴 사람이 최종적으로 승리한다. 한 번 낸 카드는 반드시 버려야 한다.


철수는 뛰어난 마술사이기 때문에 본인이 낼 카드를 마음대로 조작할 수 있다. 즉, 카드를 버리고 민수 몰래 다시 들고 온다거나 민수한테 없는 카드를 내기도 한다.

민수는 뛰어난 심리학자이기 때문에 철수가 낼 카드를 알아낼 수 있다. 그래서 민수는 철수가 낼 카드보다 큰 카드가 있다면 그 카드들 중 가장 작은 카드를 내기로 했다.

K번 동안 철수가 낼 카드가 입력으로 주어진다. 그렇다면 민수가 어떤 카드를 낼지 출력하라. 단, 민수가 카드를 내지 못하는 경우는 없다고 가정한다.

---

## 입력
첫째 줄에 세 개의 자연수 N, M, K가 주어진다. (1 ≤ M ≤ N ≤ 4,000,000, 1 ≤ K ≤ min(M, 10,000))

다음 줄에 카드의 번호를 나타내는 M개의 자연수가 주어진다. 각각의 수들은 1 이상이고 N 이하이며 서로 다르다.

다음 줄에 K개의 자연수가 주어진다. i번째 수는 철수가 i번째로 내는 카드의 번호이다. 철수가 내는 카드 역시 1 이상 N 이하이다.

---

## 출력
K줄에 걸쳐서 수를 출력한다. i번째 줄에는 민수가 i번째로 낼 카드의 번호가 출력되어야 한다.

---

## 성능 요약
메모리: 530328 KB, 시간: 1768 ms

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 민수가 철수가 낼 카드보다 큰 카드 중에서 가장 작은 카드를 선택하는 것이다. 이를 위해 먼저 빨간색 카드 번호 목록을 정렬하고, 이분 탐색을 통해 철수가 낼 카드보다 큰 카드의 위치를 찾아 해당 카드 번호를 선택한다. 민수가 이미 선택한 카드는 다시 선택할 수 없기 때문에, 선택한 카드를 버리는 방식으로 다음 선택에 영향을 주도록 한다.

### 동작 과정
1. **입력 및 초기화**:
   - 총 카드 수 `N`, 고른 카드 수 `M`, 게임 횟수 `K`를 입력받고, 민수가 고른 빨간색 카드 번호 목록을 `card_num` 배열에 저장합니다.
   - 철수가 낼 카드 번호를 `chulsu` 배열에 저장합니다.
   - `card_num`을 정렬합니다.

2. **이분 탐색 함수**:
   - `upper_bound` 함수를 사용하여 주어진 카드 번호보다 큰 카드 중 가장 작은 카드의 인덱스를 찾습니다.

3. **선택 및 업데이트**:
   - 각 게임마다 철수가 낼 카드 번호를 순서대로 확인합니다.
   - `upper_bound`를 통해 철수가 낼 카드보다 큰 카드의 인덱스를 찾고, 그 인덱스에 해당하는 민수의 카드를 선택합니다.
   - 선택한 카드는 다음 게임에서 사용하지 않도록 해당 인덱스를 업데이트 합니다.

4. **출력**:
   - 민수가 선택한 카드 번호를 순서대로 출력합니다.

**예시 입력**:
```
5 3 4
1 3 4
2 3 5 1
```

**단계별 설명**:
- 카드 번호는 [1, 3, 4]이며, 철수가 낼 카드는 [2, 3, 5, 1]입니다.
- 첫 번째로 철수가 2를 낼 때, 민수는 3을 선택합니다 (3 > 2).
- 두 번째로 철수가 3을 낼 때, 민수는 4를 선택합니다 (4 > 3).
- 세 번째로 철수가 5를 낼 때, 민수는 1을 선택합니다 (1은 선택할 수 없음).
- 네 번째로 철수가 1을 낼 때, 민수는 3을 선택합니다 (3 > 1).

**출력**:
```
3
4
1
3
```

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(M log M + K), 여기서 M log M은 카드 번호 정렬에 필요한 시간, K는 각 카드에 대해 이분 탐색을 수행하는 시간입니다. 이로 인해 전체 시간 복잡도는 K번 이분 탐색을 수행하여 O(K log M) 시간 복잡도를 가집니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n, m, k = map(int, input().split())
card_num = list(map(int, input().split()))
chulsu = list(map(int, input().split()))

card_num.sort()

def upper_bound(arr, x):
    st, ed = 0, len(arr)
    
    while st < ed:
        mid = (st + ed) // 2
        
        if arr[mid] <= x:
            st = mid + 1
        else:
            ed = mid
            
    return st

parent = list(range(m + 1))

def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
        
    return parent[x]

ans = []

for i in chulsu:
    pos = upper_bound(card_num, i)
    pos = find(pos)  
    
    ans.append(card_num[pos])
    parent[pos] = find(pos + 1)
    
for i in ans:
    print(i)
```