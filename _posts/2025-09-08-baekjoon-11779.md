---
layout: post
title: "[백준] 11779번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "11779"]
---

## 문제 링크
[https://www.acmicpc.net/problem/11779](https://www.acmicpc.net/problem/11779)

---

## 풀이

### 풀이 핵심 로직
이 문제는 최단 경로를 찾기 위한 다익스트라 알고리즘을 사용하여, 주어진 도시와 버스 정보를 바탕으로 출발 도시에서 도착 도시까지의 최단 거리를 계산하고, 그 경로를 추적하여 출력하는 방식으로 해결합니다. 다익스트라 알고리즘을 사용하면 가중치가 있는 그래프에서 최단 경로를 효율적으로 찾을 수 있습니다.

### 동작 과정
1. **입력 처리**:
   - 도시의 수 `n`과 버스의 수 `m`을 입력받습니다.
   - 각 버스 정보를 읽어와 인접 리스트 `arr`에 저장합니다. `arr[a]`는 도시 `a`에서 갈 수 있는 도시와 해당 비용을 저장합니다.
   
2. **다익스트라 알고리즘 실행**:
   - 출발 도시 `st`에서 도착 도시 `ed`까지의 최단 경로를 찾기 위해 `dijkstra` 함수를 호출합니다.
   - 우선순위 큐를 사용하여 현재까지의 최단 거리와 해당 도시를 저장합니다.
   - 현재 도시에서 갈 수 있는 모든 도시를 탐색하며, 새로운 비용이 기존 비용보다 작으면 업데이트하고 우선순위 큐에 추가합니다.

3. **결과 출력**:
   - 최단 거리 `distance[ed]`를 출력합니다.
   - `brr` 배열을 이용해 경로를 추적하여 출발 도시부터 도착 도시까지의 경로를 생성하고 출력합니다.

예시 입력:
```
5
6
1 2 2
1 3 3
2 3 1
2 4 4
3 5 1
4 5 5
1 5
```

- 입력에서 5개의 도시와 6개의 버스 정보가 주어집니다.
- 출발 도시 `1`에서 도착 도시 `5`까지의 최단 경로를 계산합니다.
- 최단 경로는 `1 -> 2 -> 3 -> 5`이며, 최단 거리 `4`가 출력됩니다. 경로의 길이는 `3`이고, 경로는 `1 2 3 5`로 출력됩니다.

### 시간 복잡도
다익스트라 알고리즘의 시간 복잡도는 `O((V + E) log V)`입니다. 여기서 `V`는 정점(도시)의 수, `E`는 간선(버스)의 수입니다. 입력 데이터에 따라 `V`와 `E`는 각각 `n`과 `m`에 해당하므로, 최악의 경우 시간 복잡도는 `O((n + m) log n)`입니다.

---

## 코드
```python
import sys, heapq
input = sys.stdin.readline
INF = int(1e9)

n = int(input())
m = int(input())

arr = [[] for _ in range(n+1)] 
distance = [INF] * (n+1)
brr = [0] * (n+1)

for _ in range(m):
    a, b, c = map(int, input().split())
    arr[a].append((b, c)) 

st, ed = map(int, input().split())

def dijkstra(s):
    q = []
    heapq.heappush(q, (0, s)) 
    distance[s] = 0  

    while q:
        dist, now = heapq.heappop(q)

        if distance[now] < dist:
            continue

        for i in arr[now]:
            cost = dist + i[1]
            if cost < distance[i[0]]:
                distance[i[0]] = cost
                brr[i[0]] = now  
                heapq.heappush(q, (cost, i[0]))

dijkstra(st)
print(distance[ed])

ans = [ed]
a = ed
while a != st:
    a = brr[a]
    ans.append(a)

ans.reverse() 
print(len(ans))
print(*ans)
```