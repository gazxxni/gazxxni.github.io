---
layout: post
title: "[백준] 17404번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "17404"]
---

## 문제 링크
[https://www.acmicpc.net/problem/17404](https://www.acmicpc.net/problem/17404)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 집들을 세 가지 색으로 칠할 때, 첫 번째와 마지막 집의 색깔이 동일하지 않도록 하면서 최소 비용으로 칠하는 방법을 찾는 것이다. 이를 위해 동적 프로그래밍을 사용하여 각 집의 색깔별 최소 비용을 계산하고, 첫 번째 집의 색깔을 고정한 후 마지막 집의 색깔이 첫 번째 집의 색깔과 다를 경우의 최소 비용을 구한다.

### 동작 과정
1. **입력 예시**: 
   ```
   3
   26 40 83
   49 60 57
   13 89 99
   ```
   여기서 `n=3`이며, 각 집의 색깔 비용은 주어진 배열로 나타낸다.

2. **첫 번째 집 색깔 고정**: `first_color`를 0(빨강)으로 고정한다고 가정.
   - `dp[0][0] = cost[0][0] = 26` (첫 번째 집이 빨강일 때의 비용)
   - 나머지 `dp[0][1]`과 `dp[0][2]`는 INF로 초기화.

3. **동적 프로그래밍 진행**:
   - **두 번째 집** (i=1):
     - 빨강: `dp[1][0] = cost[1][0] + min(dp[0][1], dp[0][2]) = 49 + min(40, 83) = 49 + 40 = 89`
     - 초록: `dp[1][1] = cost[1][1] + min(dp[0][0], dp[0][2]) = 60 + min(26, 83) = 60 + 26 = 86`
     - 파랑: `dp[1][2] = cost[1][2] + min(dp[0][0], dp[0][1]) = 57 + min(26, 40) = 57 + 26 = 83`
   - **세 번째 집** (i=2):
     - 빨강: `dp[2][0] = cost[2][0] + min(dp[1][1], dp[1][2]) = 13 + min(86, 83) = 13 + 83 = 96`
     - 초록: `dp[2][1] = cost[2][1] + min(dp[1][0], dp[1][2]) = 89 + min(89, 83) = 89 + 83 = 172`
     - 파랑: `dp[2][2] = cost[2][2] + min(dp[1][0], dp[1][1]) = 99 + min(89, 86) = 99 + 86 = 185`

4. **마지막 집 색깔 체크**: 
   - 마지막 집의 색깔을 빨강(0), 초록(1), 파랑(2)으로 테스트하면서 첫 집의 색깔이 빨강(0)이 아닌 경우의 최소 비용을 계산.
   - 예를 들어, 마지막 집이 초록이면 `result = min(result, dp[2][1])`를 통해 계산.

5. **반복**: 
   - 이 과정을 `first_color`를 1(초록), 2(파랑)로 바꿔가며 반복하여 최종 최소 비용을 찾는다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n)이다. 각 집에 대해 3가지 색깔을 고려하여 DP 테이블을 채우고, 마지막에 두 가지 색깔을 비교하므로 선형 시간 복잡도를 가지게 된다.

---

## 코드
```python
import sys
input = sys.stdin.readline

INF = int(1e9)

n = int(input())
cost = [list(map(int, input().split())) for _ in range(n)]

result = INF

for first_color in range(3):  # 0: 빨강, 1: 초록, 2: 파랑
    dp = [[INF]*3 for _ in range(n)]
    
    # 1번 집의 색을 고정
    dp[0][first_color] = cost[0][first_color]

    for i in range(1, n):
        dp[i][0] = cost[i][0] + min(dp[i-1][1], dp[i-1][2])  # 빨강
        dp[i][1] = cost[i][1] + min(dp[i-1][0], dp[i-1][2])  # 초록
        dp[i][2] = cost[i][2] + min(dp[i-1][0], dp[i-1][1])  # 파랑

    # 마지막 집의 색이 첫 번째 집의 색과 같지 않은 경우만 고려
    for last_color in range(3):
        if last_color != first_color:
            result = min(result, dp[n-1][last_color])

print(result)

```