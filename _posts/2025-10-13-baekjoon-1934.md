---
layout: post
title: "[백준] 1934번 (Python)"
date: 2025-10-13
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1934"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1934](https://www.acmicpc.net/problem/1934)

---

## 풀이

### 풀이 핵심 로직
이 코드는 주어진 두 수의 최소공배수(LCM)를 구하기 위해 최대공약수(GCD)를 활용합니다. 두 수의 LCM은 두 수의 곱을 GCD로 나눈 값으로 정의되며, 이를 통해 LCM을 효율적으로 계산할 수 있습니다.

### 동작 과정
1. 첫 번째로, 사용자로부터 테스트 케이스의 개수 `t`를 입력받습니다.
2. `gcd`라는 함수를 정의하여 두 수의 최대공약수를 계산합니다. 이 함수는 유클리드 호제법을 사용하여 반복적으로 GCD를 구합니다.
3. `lcm` 함수를 정의하여 두 수의 최소공배수를 계산합니다. 이 함수는 두 수의 곱을 GCD로 나눈 값을 반환합니다.
4. `for` 루프를 통해 `t`만큼 반복하며 각 반복마다 두 수 `a`와 `b`를 입력받고, 해당 수의 LCM을 계산하여 출력합니다.

예시 입력: 
```
3
4 5
3 6
8 12
```
입력의 각 줄에 대해 다음과 같은 과정을 거칩니다:
- 첫 번째 입력 `4, 5`의 GCD는 `1`, LCM은 `4 * 5 / 1 = 20`입니다.
- 두 번째 입력 `3, 6`의 GCD는 `3`, LCM은 `3 * 6 / 3 = 6`입니다.
- 세 번째 입력 `8, 12`의 GCD는 `4`, LCM은 `8 * 12 / 4 = 24`입니다.

결과 출력:
```
20
6
24
```

### 시간 복잡도
- GCD 계산은 유클리드 알고리즘을 사용하므로, 두 수의 크기에 따라 O(log(min(a, b)))의 시간 복잡도를 가집니다.
- LCM 계산은 GCD를 이용해 이루어지므로, 전체 알고리즘의 시간 복잡도는 O(t * log(min(a, b)))입니다. 여기서 `t`는 테스트 케이스의 수입니다.

---

## 코드
```python
t = int(input())

def gcd(a, b):
    while b > 0:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a * b / gcd(a, b)

for _ in range(t):
    a, b = map(int, input().split())
    
    print(int(lcm(a, b)))
```