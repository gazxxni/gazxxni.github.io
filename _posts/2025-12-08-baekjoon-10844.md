---
layout: post
title: "[백준] 10844번 쉬운 계단 수 (Python)"
date: 2025-12-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "10844", 다이나믹 프로그래밍]
---

## 문제 링크
[https://www.acmicpc.net/problem/10844](https://www.acmicpc.net/problem/10844)

---

## 문제
45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.

---

## 입력
첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

---

## 출력
첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

---

## 성능 요약
메모리: 108384 KB, 시간: 84 ms

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심은 계단 수의 성질을 이용하여 동적 프로그래밍(DP) 테이블을 구성하는 것입니다. 각 자리의 숫자가 이전 자리의 숫자와 1차이 나는 수를 계단 수라고 정의하므로, DP 테이블에서 길이가 `i`인 계단 수의 마지막 자리 숫자에 따라 이전 자리 숫자에서 올 수 있는 경우의 수를 더하여 계산합니다.

### 동작 과정
1. **입력**: N=3인 경우를 생각해봅시다.
2. **초기화**: 길이 1인 계단 수는 1~9까지의 숫자이므로 `dp[1][1]`부터 `dp[1][9]`까지 1로 초기화하고, 나머지 `dp[1][0]`과 `dp[1][10]`은 0으로 둡니다.
   ```
   dp[1] = [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]
   ```
3. **DP 테이블 업데이트**: 다음 길이로 넘어가면서 각 자리 숫자에 대해 가능한 이전 자리 숫자에서의 경우의 수를 더합니다.
   - 예를 들어, 길이 2에서 `j=1`일 때는 `j+1=2`로 올 수 있고, `j-1=0`으로는 올 수 없으므로 `dp[2][1] = dp[1][0] + dp[1][2] = 0 + 1 = 1`.
   - 이와 같은 방식으로 2, 3, ... N까지 반복합니다.
4. **결과 도출**: 마지막으로 `dp[n]`의 모든 값을 합산하여 N자리 계단 수의 개수를 구하고 1,000,000,000으로 나눈 나머지를 출력합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(N)입니다. N에 대해 각 자리 숫자(1~10)에 대해 상수 시간 내에 계산이 이루어지기 때문입니다.

---

## 코드
```python
n = int(input())

dp = [[0] * 12 for _ in range(n + 1)]
dp[1][2:11] = [1] * 9

for i in range(2, n + 1):
    for j in range(1, 11):
        dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]
        
ans = sum(dp[n])
print(ans % 1000000000)
```