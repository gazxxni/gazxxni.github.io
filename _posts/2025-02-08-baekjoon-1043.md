---
layout: post
title: "[백준] 1043번 (Python)"
date: 2025-02-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1043"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1043](https://www.acmicpc.net/problem/1043)

---

## 풀이

### 풀이 핵심 로직
이 문제는 진실을 아는 사람들이 참석하는 파티의 수를 계산하는 문제입니다. 핵심 아이디어는, 진실을 아는 사람이 있는 모든 파티에 대해 진실을 아는 사람의 집합을 업데이트하고, 최종적으로 진실을 모르는 사람들이 참석할 수 있는 파티의 수를 세는 것입니다.

### 동작 과정
1. 입력 예시: 
   ```
   4 3
   1 4
   3 1 2 3
   2 3 4
   1 2
   ```
   - `n = 4` (사람 수), `m = 3` (파티 수)
   - 진실을 아는 사람: `4`
   - 파티 참석자 목록:
     - 파티 1: `1, 2, 3`
     - 파티 2: `3, 4`
     - 파티 3: `1, 2`

2. 초기 상태에서 진실을 아는 사람은 `{4}`이고, 각 파티는 다음과 같이 저장됩니다:
   ```
   party = [{1, 2, 3}, {3, 4}, {1, 2}]
   ```

3. 첫 번째 반복:
   - 파티 1 (`{1, 2, 3}`)과 진실을 아는 사람 `{4}`의 교집합이 없으므로 변화 없음.
   - 파티 2 (`{3, 4}`)와 `{4}`의 교집합이 `{4}`와 `{3}`이므로, 진실을 아는 사람 집합이 `{3, 4}`로 업데이트됨.
   - 파티 3 (`{1, 2}`)와 `{3, 4}`의 교집합이 없으므로 변화 없음.

4. 두 번째 반복에서 진실을 아는 사람이 `{3, 4}`가 되었으므로, 다시 파티를 조사합니다:
   - 파티 1 (`{1, 2, 3}`)은 `{3, 4}`와 교집합이 `{3}`으로 교집합이 있어 변함이 없고,
   - 파티 2 (`{3, 4}`)는 진실을 아는 사람이 포함되어 있으므로,
   - 파티 3 (`{1, 2}`)는 진실을 아는 사람이 포함되어 있지 않으므로 카운트 증가.

5. 최종적으로 진실을 모르는 사람들이 참석할 수 있는 파티의 수는 1입니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(m * n)입니다. 여기서 m은 파티의 수, n은 각 파티의 최대 참석자 수입니다. 두 개의 중첩된 반복문으로 인해 최악의 경우 모든 파티와 모든 참가자를 확인해야 할 수 있기 때문입니다.

---

## 코드
```python
import sys 

n, m = map(int, input().split())
truth = set(input().split()[1:])  # 앞 1개의 원소를 빼고 저장장
party = []

for _ in range(m):
    party.append(set(input().split()[1:]))

for _ in range(m):
    for i in party: 
        if i & truth:  # 파티 참석자가 있고 진실을 아는 사람이 있을 때
            truth = truth.union(i)  # truth와 i의 합집합 반환환

cnt = 0

for i in party:
    if i & truth:  # 현재 파티에 진실을 아는 사람이 포함된 경우
        continue 
    cnt += 1  # 진실을 모르는 사람들이 즐길 수 있는 파티일 경우 카운트 증가

print(cnt)

```