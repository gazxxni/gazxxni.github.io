---
layout: post
title: "[백준] 10775번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "10775"]
---

## 문제 링크
[https://www.acmicpc.net/problem/10775](https://www.acmicpc.net/problem/10775)

---

## 풀이

### 풀이 핵심 로직
이 문제는 비행기가 착륙할 수 있는 게이트를 관리하는 문제로, 유니온-파인드(Union-Find) 자료구조를 사용하여 각 게이트의 연결 상태를 관리한다. 각 게이트는 자신의 부모 노드를 가지며, 비행기가 착륙할 수 있는 가장 높은 게이트부터 확인하여 착륙 가능 여부를 판단하고, 착륙 후에는 해당 게이트의 부모를 하나 낮춘다.

### 동작 과정
1. 입력으로 총 게이트 수(g)와 비행기 수(p)를 받는다.
2. 각 비행기가 착륙하고자 하는 게이트 번호를 리스트로 저장한다.
3. 각 게이트에 대해 자신의 부모 노드를 초기화한다. (각 게이트는 자기 자신을 부모로 가짐)
4. 비행기 번호를 순서대로 처리한다.
   - 현재 비행기가 착륙하고자 하는 게이트의 부모를 찾는다.
   - 만약 부모가 0이라면 더 이상 착륙할 수 있는 게이트가 없으므로 반복을 종료한다.
   - 착륙이 가능하면 카운트를 증가시키고, 해당 게이트의 부모를 하나 낮춘다.
5. 최종적으로 착륙한 비행기 수를 출력한다.

예시로, 
- 총 게이트(g) = 4, 비행기(p) = 3, 비행기 착륙 시도 게이트 = [4, 1, 1]인 경우:
  1. 첫 번째 비행기는 4번 게이트에 착륙, 4번 게이트의 부모를 3으로 설정.
  2. 두 번째 비행기는 1번 게이트에 착륙, 1번 게이트의 부모를 0으로 설정.
  3. 세 번째 비행기는 1번 게이트에 착륙하려 하지만 부모가 0이므로 착륙 불가.
  4. 최종적으로 2대의 비행기가 착륙에 성공.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(p * α(g)), 여기서 α는 아커만 함수의 역함수로 매우 느리게 증가하는 함수이다. 따라서 실질적으로 거의 상수 시간에 가까운 성능을 보인다.

---

## 코드
```python
import sys
input = sys.stdin.readline

g = int(input())
p = int(input())
arr = [int(input()) for _ in range(p)]
parent = [i for i in range(g + 1)]

def find(x, parent):
    if parent[x] != x:
        parent[x] = find(parent[x], parent)
    return parent[x]

def union(a, b, parent):
    rootA = find(a, parent)
    rootB = find(b, parent)
    
    parent[rootA] = rootB

cnt = 0
for i in arr:
    gate = find(i, parent)
    
    if gate == 0:
        break
    else:
        cnt += 1
        union(gate, gate - 1, parent)
        
print(cnt)
```