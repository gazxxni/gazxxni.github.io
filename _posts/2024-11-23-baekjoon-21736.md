---
layout: post
title: "[백준] 21736번 (Python)"
date: 2024-11-23
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "21736"]
---

## 문제 링크
[https://www.acmicpc.net/problem/21736](https://www.acmicpc.net/problem/21736)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 BFS(너비 우선 탐색) 알고리즘을 사용하여 도연이('I')의 위치에서 시작해 캠퍼스 맵을 탐색하며 만나는 사람('P')의 수를 세는 것입니다. 탐색 과정에서 벽('X')을 만나면 진행할 수 없고, 이미 방문한 위치는 다시 방문하지 않도록 처리합니다.

### 동작 과정
1. 입력으로 주어진 캠퍼스 맵을 2차원 리스트로 저장하며, 도연이의 위치를 찾는다. 도연이의 위치를 큐에 추가하고 방문 표시를 한다.
2. BFS를 시작하여 큐에서 좌표를 꺼내고 상하좌우 방향으로 탐색한다.
3. 탐색하는 각 방향에서 새로운 좌표가 캠퍼스 범위 내에 있고, 방문하지 않았으며 벽이 아닌 경우에만 진행한다.
4. 만약 사람('P')을 만난 경우, 카운터를 증가시키고 해당 위치를 방문한 것으로 표시한 후 큐에 추가한다.
5. BFS가 끝난 후, 만난 사람 수를 출력하며, 만난 사람이 없으면 "TT"를 출력한다.

#### 예시 입력
```
3 4
I..P
...X
P...
```
- 도연이의 위치는 (0, 0)이다.
- BFS를 시작하여 (0, 0)에서 탐색을 시작한다.
- (0, 1), (1, 0)으로 이동하고 (0, 1)에서 (0, 2)로 이동하여 (0, 2)에서 사람('P')을 발견한다. 카운트는 1 증가한다.
- (1, 0)으로 이동하여 (2, 0)에서 또 다른 사람('P')을 발견하여 카운트가 2가 된다.
- 더 이상 탐색할 수 있는 위치가 없으므로 종료하고 카운트를 출력한다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(N * M)입니다. 여기서 N은 캠퍼스 맵의 행 수, M은 열 수로, 캠퍼스를 모든 칸을 한 번씩 방문하게 되므로 이 복잡도를 가집니다.

---

## 코드
```python
import sys
from collections import deque

n, m = map(int, sys.stdin.readline().strip().split())

# 상, 하, 좌, 우 방향을 나타내는 배열 (dx는 행 변화, dy는 열 변화)
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

# 방문 여부를 기록하는 배열
visited = [[0] * m for _ in range(n)]

# 캠퍼스 정보를 저장할 리스트
campus = []
Q = deque()

# 캠퍼스 맵 입력과 동시에 도연이의 위치 찾기
for i in range(n):
    campus.append(list(map(str, sys.stdin.readline().strip())))

    for j in range(len(campus[i])):
        if campus[i][j] == 'I':  # 도연이의 위치를 찾으면
            Q.append([i, j])  # 큐에 추가
            visited[i][j] = 1  # 방문 표시

answer = 0   # 도연이가 만난 사람 수

while Q:
    for _ in range(len(Q)):
        x, y = Q.popleft()  # 현재 좌표 (x, y)를 큐에서 꺼냄

        # 상, 하, 좌, 우 방향으로 탐색
        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]  # 새로운 좌표 (nx, ny)

            # 캠퍼스 범위를 벗어나지 않고, 아직 방문하지 않았으며, 벽이 아닌 경우 이동
            if 0 <= nx < n and 0 <= ny < m and visited[nx][ny] == 0 and campus[nx][ny] != 'X':
                if campus[nx][ny] == 'P':  # 사람을 만났다면
                    answer += 1  # 만난 사람 수 증가

                visited[nx][ny] = 1  # 방문했다고 표시
                Q.append([nx, ny])  # 큐에 좌표 추가

if answer:  # 만난 사람이 있으면 그 수를 출력
    print(answer)
else:  # 만난 사람이 없으면 "TT" 출력
    print('TT')

```