---
layout: post
title: "[백준] 1475번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1475"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1475](https://www.acmicpc.net/problem/1475)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 숫자에서 각 숫자의 개수를 세고, 숫자 6과 9는 서로 교환 가능하다는 점을 이용하여 최소한의 세트로 모든 숫자를 만들 수 있는지를 판별합니다. 6과 9의 개수를 합산하여 반으로 나누고, 나머지 숫자 중에서 가장 많이 등장하는 숫자의 개수와 비교하여 최종 결과를 도출합니다.

### 동작 과정
1. **입력 처리**: 사용자로부터 입력된 숫자를 문자열로 받고, 이를 리스트 형태로 변환하여 각 자리의 숫자를 정수형으로 변환합니다.
   - 예시 입력: `9966`
   - 변환 결과: `arr = [9, 9, 6, 6]`

2. **숫자 개수 세기**: 각 숫자(0부터 9까지)의 개수를 세기 위해 딕셔너리 `dic`를 초기화하고, 입력된 숫자 배열을 순회하며 각 숫자의 개수를 카운트합니다.
   - `dic` 초기화: `{0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0}`
   - 카운트 후 `dic`: `{0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 2, 7: 0, 8: 0, 9: 2}`

3. **최대 개수 찾기**: 0부터 5까지의 숫자에 대해 각 숫자의 개수를 확인하고, 최대 개수를 `ans`에 저장합니다. 6과 9는 따로 처리합니다.
   - `ans` 업데이트: 숫자 0에서 5까지의 개수 중 최대값을 찾기 때문에 `ans`는 2가 됩니다.

4. **6과 9 처리**: 6과 9의 개수를 합산한 후 2로 나누고 올림 처리를 하여 필요한 세트를 계산합니다.
   - `a = int(math.ceil((dic[6] + dic[9]) / 2))` → `a = int(math.ceil((2 + 2) / 2))` → `a = 2`

5. **최종 결과 출력**: `ans`와 `a` 중 큰 값을 출력합니다.
   - 결과: `max(ans, a)` → `max(2, 2)` → `2`가 출력됩니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n)입니다. 여기서 n은 입력된 숫자의 자리 수입니다. 각 자리 숫자를 처리하고 카운트하는 과정이 모두 선형적으로 진행되기 때문입니다.

---

## 코드
```python
import sys, math
input = sys.stdin.readline

n = input().rstrip()
arr = list(map(int, n)) 
dic = {i:0 for i in range(10)}

for i in arr:
    dic[i] += 1

ans = 0 
for k, v in dic.items():
    if k == 6 or k == 9:
        continue
    
    ans = max(ans, v)

a = int(math.ceil((dic[6] + dic[9]) / 2))
print(max(ans, a))
```