---
layout: post
title: "[백준] 1799번 비숍 (Python)"
date: 2026-01-15
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1799", 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/1799](https://www.acmicpc.net/problem/1799)

---

## 문제
서양 장기인 체스에는 대각선 방향으로 움직일 수 있는 비숍(bishop)이 있다. 과 같은 정사각형 체스판 위에 B라고 표시된 곳에 비숍이 있을 때 비숍은 대각선 방향으로 움직여 O로 표시된 칸에 있는 다른 말을 잡을 수 있다.





그런데 체스판 위에는 비숍이 놓일 수 없는 곳이 있다. 에서 체스판에 색칠된 부분은 비숍이 놓일 수 없다고 하자. 이와 같은 체스판에 서로가 서로를 잡을 수 없도록 하면서 비숍을 놓는다면 과 같이 최대 7개의 비숍을 놓을 수 있다.  색칠된 부분에는 비숍이 놓일 수 없지만 지나갈 수는 있다.









정사각형 체스판의 한 변에 놓인 칸의 개수를 체스판의 크기라고 한다. 체스판의 크기와 체스판 각 칸에 비숍을 놓을 수 있는지 없는지에 대한 정보가 주어질 때, 서로가 서로를 잡을 수 없는 위치에 놓을 수 있는 비숍의 최대 개수를 구하는 프로그램을 작성하시오.

---

## 입력
첫째 줄에 체스판의 크기가 주어진다. 체스판의 크기는 10이하의 자연수이다. 둘째 줄부터 아래의 예와 같이 체스판의 각 칸에 비숍을 놓을 수 있는지 없는지에 대한 정보가 체스판 한 줄 단위로 한 줄씩 주어진다. 비숍을 놓을 수 있는 곳에는 1, 비숍을 놓을 수 없는 곳에는 0이 빈칸을 사이에 두고 주어진다.

---

## 출력
첫째 줄에 주어진 체스판 위에 놓을 수 있는 비숍의 최대 개수를 출력한다.

---

## 성능 요약
메모리: 144356 KB, 시간: 2452 ms

---

## 풀이

### 풀이 핵심 로직
문제는 서로 공격할 수 없는 비숍을 최대한 배치하는 것으로, 체스판의 색상에 따라 비숍을 나누어 배치하는 방법을 사용합니다. 비숍은 대각선으로만 공격할 수 있으므로, 각 대각선에 비숍이 하나만 있도록 조건을 설정하여 백트래킹을 이용해 최적의 해를 찾습니다.

### 동작 과정
1. **입력 처리**: 체스판의 크기와 각 칸에 비숍을 놓을 수 있는지를 입력받습니다. 비숍을 놓을 수 있는 칸은 `1`, 놓을 수 없는 칸은 `0`으로 표시됩니다.
   
2. **색상 분리**: 보드의 각 칸을 행과 열의 합에 따라 흰색 및 검은색 셀로 나눕니다. `(r + c) % 2`가 0이면 흰색, 1이면 검은색으로 간주합니다.

3. **백트래킹 함수 정의**: `solve`라는 재귀 함수를 정의하여, 현재 비숍을 놓을 수 있는 칸의 리스트와 인덱스를 받아서 최대 비숍 개수를 계산합니다. 
   - 현재 칸에 비숍을 놓지 않는 경우와 놓는 경우를 모두 고려하여 최대값을 반환합니다.
   - 비숍을 놓을 때는 해당 대각선이 비어 있어야 하며, 놓은 후에는 대각선 상태를 업데이트하여 다음 호출에서 중복 배치를 방지합니다.

4. **흰색 및 검은색 칸 각각 처리**: 두 색상의 셀에 대해 `solve` 함수를 호출하여 각각 최대 비숍 개수를 구한 후 합산하여 최종 결과를 출력합니다.

**예시 입력**:
```
4
0 1 0 1
1 0 1 0
0 1 0 1
1 0 1 0
```

**단계별 설명**:
- **입력 처리**: 4x4 체스판에서 비숍을 놓을 수 있는 위치는 (0,1), (0,3), (1,0), (1,2), (2,1), (2,3), (3,0), (3,2)입니다.
- **흰색 셀**: 흰색 셀은 (0, 0), (1, 1), (2, 2), (3, 3)에서 비숍을 놓을 수 없습니다.
- **검은색 셀**: 검은색 셀에 대해 비숍을 놓으며 가능한 경우를 모두 탐색합니다. 놓지 않을 경우와 놓을 경우 각각의 결과를 비교하여 최대 개수를 갱신합니다.
- 두 색상 모두 탐색 후 최대 개수를 더하여 결과를 출력합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(2^(N^2))입니다. 최악의 경우 모든 조합을 탐색해야 하므로, 체스판 크기 N이 10 이하인 경우에는 충분히 처리할 수 있습니다.

---

## 코드
```python
n = int(input())
graph = [list(map(int, input().split())) for _ in range(n)]

white_cells = []
black_cells = []
for r in range(n):
    for c in range(n):
        if graph[r][c] == 1:
            # (행 + 열)이 짝수이면 '흰색' 칸으로 간주
            if (r + c) % 2 == 0:
                white_cells.append((r, c))
            else:
                black_cells.append((r, c))

# 대각선 방문 여부를 체크
# (r-c) 대각선 (인덱스: r - c + n - 1 사용)
diag1 = [False] * (2 * n - 1)
# (r+c) 대각선 (인덱스: r + c 사용)
diag2 = [False] * (2 * n - 1)

def solve(cell_list, index):
    # 리스트의 모든 칸을 다 확인했다면 0 반환
    if index == len(cell_list):
        return 0

    # 현재 확인할 칸의 좌표
    r, c = cell_list[index]

    # 현재 칸(r, c)에 비숍을 놓지 않는 경우
    # 이 칸을 건너뛰고, 다음 칸(index + 1)부터 탐색
    res = solve(cell_list, index + 1)

    # 현재 칸(r, c)에 비숍을 놓는 경우
    diag1_idx = r - c + n - 1
    diag2_idx = r + c

    # 두 대각선이 비었는지 확인
    if not diag1[diag1_idx] and not diag2[diag2_idx]:
        diag1[diag1_idx] = True
        diag2[diag2_idx] = True

        # 현재 칸에 1개를 놓았으니, 1 + 다음 칸(index+1)부터 탐색
        placed_count = 1 + solve(cell_list, index + 1)

        # 사용 후 두 대각선 사용 해제
        diag1[diag1_idx] = False
        diag2[diag2_idx] = False
        
        # 놓지 않은 경우(res)와 놓은 경우(placed_count) 중 더 큰 값으로 res를 갱신
        res = max(res, placed_count)

    return res

# 흰색 칸들에 대해 백트래킹 실행
ans_white = solve(white_cells, 0)

# 검은색 칸들에 대해 백트래킹 실행
# 검은색 칸 탐색을 위해 대각선 배열(diag1, diag2)을 다시 초기화
diag1 = [False] * (2 * n - 1)
diag2 = [False] * (2 * n - 1)
ans_black = solve(black_cells, 0)

print(ans_white + ans_black)
```