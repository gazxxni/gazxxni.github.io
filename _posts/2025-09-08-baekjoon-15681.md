---
layout: post
title: "[백준] 15681번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "15681"]
---

## 문제 링크
[https://www.acmicpc.net/problem/15681](https://www.acmicpc.net/problem/15681)

---

## 풀이

### 풀이 핵심 로직
이 문제는 트리 구조에서 특정 노드의 서브트리 크기를 계산하는 문제입니다. 주어진 루트 노드 `r`을 기준으로 DFS(깊이 우선 탐색)를 수행하여 각 노드의 부모를 기록하고, 이후 각 노드의 서브트리 크기를 계산합니다. 서브트리 크기는 해당 노드와 그 자식 노드의 총 개수를 의미합니다.

### 동작 과정
1. 입력을 받아 트리의 노드 수 `n`, 루트 노드 `r`, 쿼리 수 `q`를 설정합니다.
2. 인접 리스트 형태로 그래프를 구성합니다. 각 간선의 정보를 받아 양방향으로 연결합니다.
3. DFS를 통해 각 노드의 부모 노드를 설정하고, 방문 순서를 기록합니다.
   - 초기 상태: `parent = [0, 0, ..., 0]`, `order = []`, `stack = [r]`
   - `stack`에서 노드를 꺼내고, 자식 노드를 탐색하여 부모를 설정하고 스택에 추가합니다.
4. 서브트리 크기를 계산합니다. 
   - `order` 리스트를 역순으로 순회하며, 자식 노드의 서브트리 크기를 합산하여 현재 노드의 서브트리 크기를 결정합니다.
5. 쿼리를 처리하며 각 노드의 서브트리 크기를 출력합니다.

예시 입력:
```
7 1 3
1 2
1 3
2 4
2 5
3 6
3 7
1
2
3
```
과정을 통해 `subtree_size` 배열은 다음과 같이 계산됩니다:
- `subtree_size[1] = 7` (전체 노드)
- `subtree_size[2] = 3` (노드 2와 그 자식들 4, 5)
- `subtree_size[3] = 3` (노드 3와 그 자식들 6, 7)

출력:
```
7
3
3
```

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n)입니다. 트리의 모든 노드를 한 번씩 방문하여 부모를 설정하고 서브트리 크기를 계산하기 때문에, n개의 노드에 대해 선형적으로 처리됩니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n, r, q = map(int, input().split())

graph = [[] for _ in range(n+1)]
for _ in range(n-1):
    u, v = map(int, input().split())
    graph[u].append(v)
    graph[v].append(u)

parent = [0] * (n+1)
parent[r] = r
order = []
stack = [r]
while stack:
    u = stack.pop()
    order.append(u)
    for v in graph[u]:
        if parent[v] == 0:
            parent[v] = u
            stack.append(v)

subtree_size = [0] * (n+1)
for u in reversed(order):
    sz = 1
    for v in graph[u]:
        if parent[v] == u:
            sz += subtree_size[v]
    subtree_size[u] = sz

for _ in range(q):
    u = int(input())
    print(subtree_size[u])
```