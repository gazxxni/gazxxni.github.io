---
layout: post
title: "[백준] 13171번 A (Python)"
date: 2026-01-15
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "13171", 수학, 분할 정복을 이용한 거듭제곱]
---

## 문제 링크
[https://www.acmicpc.net/problem/13171](https://www.acmicpc.net/problem/13171)

---

## 문제
음이 아닌 두 정수 A, X 가 있을 때 AX을 구하는 방법을 생각해보자. 물론 이 수는 매우 클 수 있기에, 1,000,000,007 (= 109 + 7)로 나눈 나머지를 구할 것이다. a mod x를 a를 x로 나눴을 때의 나머지라고 표현하면,

(a × b) mod x = {(a mod x) × (b mod x)} mod x

가 성립하기 때문에, 어떤 두 정수를 1,000,000,007로 나눈 나머지만 알고 있어도 그 두 정수의 곱을 1,000,000,007로 나눈 나머지를 쉽게 계산할 수 있다.

본 문제로 돌아가서, 그렇다면 이제 A를 X 번 곱하면 AX을 쉽게 구할 수 있을 것 같아 보인다. 그러나 안타깝게도 X가 상당히 커서 64비트 정수의 범위에 있다면 A를 하나하나씩 곱하는 방식으로는 상상할 수 없을 정도로 긴 시간이 흘러야 답을 찾을 수 있을 것이다. 그래서 다음과 같이 곱셈의 횟수를 줄이는 방법을 사용한다.


	먼저 A1, A2, A4, A8, ...을 순서대로 계산한다. 각 수는 이전에 있는 수를 제곱함으로써 계산할 수 있고, 지수가 X 를 딱 넘지 않을 시점까지만 계산하면 충분할 것이다. X가 64비트 정수의 범위에 있으므로 계산하는 수는 64개보다 작을 것이다.
	이제 X 를 이진수로 나타내 보자. 예를 들어 X를 11로 두면, X = 11 = 1 + 2 + 8이다. 그런데 지수법칙에 의해, A11 = A1+2+8 = A1 × A2 × A8이 성립한다. 이를 통해 1번 단계에서 미리 계산해 놓았던 수 몇 개만 곱해서 AX 을 계산할 수 있음을 알 수 있다.


즉, 차례로 A를 곱해 나간다면 시간이 X에 비례하게 걸리겠지만, 위의 방법을 이용하면 시간이 log(X)에 비례하게 걸리게 된다. AX를 구하는 프로그램을 작성하라.

---

## 입력
첫 번째 줄에는 정수 A(1 ≤ A ≤ 1018)이 주어진다.

두 번째 줄에는 정수 X(1 ≤ X ≤ 1018)가 주어진다.

---

## 출력
AX을 출력한다. 이 수는 매우 커질 수 있으므로 1,000,000,007로 나눈 나머지를 출력해야 한다.

---

## 성능 요약
메모리: 108384 KB, 시간: 96 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 대수적 방법을 이용하여 거듭제곱을 효율적으로 계산하는 방법을 요구합니다. 주어진 A를 X번 곱하는 대신, 이진수 표현을 활용하여 A의 거듭제곱을 계산함으로써 곱셈의 횟수를 줄이고, 시간 복잡도를 O(log X)로 줄입니다.

### 동작 과정
주어진 입력 예시로 A=3, X=11을 살펴보겠습니다.

1. **초기화**: 
   - A = 3, X = 11, MOD = 1,000,000,007
   - result = 1

2. **이진수 변환**: 
   - X = 11의 이진수 표현은 1011입니다. 이는 1 + 2 + 8에 해당합니다. 즉, A^11 = A^1 × A^2 × A^8로 표현할 수 있습니다.

3. **계산 과정**:
   - 첫 번째 반복: 
     - X = 11 (이진수 1011), x % 2 == 1 → result = (1 * 3) % 1,000,000,007 = 3
     - A를 제곱: A = (3 * 3) % 1,000,000,007 = 9
     - X를 반으로 나눔: X = 11 // 2 = 5
     
   - 두 번째 반복:
     - X = 5 (이진수 101), x % 2 == 1 → result = (3 * 9) % 1,000,000,007 = 27
     - A를 제곱: A = (9 * 9) % 1,000,000,007 = 81
     - X를 반으로 나눔: X = 5 // 2 = 2
     
   - 세 번째 반복:
     - X = 2 (이진수 10), x % 2 == 0 → result = 27 (변경 없음)
     - A를 제곱: A = (81 * 81) % 1,000,000,007 = 6561
     - X를 반으로 나눔: X = 2 // 2 = 1
     
   - 네 번째 반복:
     - X = 1 (이진수 1), x % 2 == 1 → result = (27 * 6561) % 1,000,000,007 = 177147
     - A를 제곱: A = (6561 * 6561) % 1,000,000,007 = 43046721
     - X를 반으로 나눔: X = 1 // 2 = 0

4. **결과 출력**:
   - 최종 result = 177147이므로, 이를 출력합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(log X)입니다. X를 이진수로 변환하여 각 비트에 대해 한 번씩만 반복하기 때문입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

a = int(input())
x = int(input())
MOD = 1_000_000_007

result = 1
a %= MOD

while x > 0:
    if x % 2 == 1: 
       result = (result * a) % MOD
    a = (a * a) % MOD
    x //= 2
    
print(result % MOD)
```