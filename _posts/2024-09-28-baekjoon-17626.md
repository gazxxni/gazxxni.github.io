---
layout: post
title: "[백준] 17626번 (Python)"
date: 2024-09-28
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "17626"]
---

## 문제 링크
[https://www.acmicpc.net/problem/17626](https://www.acmicpc.net/problem/17626)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 자연수를 1의 제곱수들의 합으로 표현하는 방법의 최소 개수를 찾는 것입니다. 핵심 아이디어는 제곱수의 성질을 이용하여, 먼저 n이 제곱수인지 확인하고, 그 후 n에서 제곱수를 차례로 빼면서 남은 수가 제곱수인지 확인하여 최소 개수를 구하는 것입니다.

### 동작 과정
1. 입력으로 받은 자연수 `n`에 대해, 제곱수의 배열 `sq`를 생성합니다. `sq[i]`는 `i`가 제곱수일 경우 1, 아닐 경우 0입니다.
2. 가장 큰 제곱수부터 시작하여 `n`을 빼면서 남은 수가 제곱수인지를 확인합니다.
   - 예를 들어, `n = 12`일 때:
     - `i = 3` (3^2 = 9)일 경우, `12 - 9 = 3`이 제곱수가 아니므로 계속 진행합니다.
     - `i = 2` (2^2 = 4)일 경우, `12 - 4 = 8`이 제곱수가 아니므로 계속 진행합니다.
     - `i = 1` (1^2 = 1)일 경우, `12 - 1 = 11`이 제곱수가 아니므로 계속 진행합니다.
3. 두 번째 제곱수를 빼는 경우를 고려하여, `n - i^2`의 나머지가 제곱수인지를 체크합니다. 만약 찾으면 최소 개수를 2로 설정합니다.
4. 마지막으로, 세 번째 제곱수를 빼는 경우를 고려하고, 이 경우도 제곱수가 나오면 최소 개수를 3으로 설정합니다.
5. 최종적으로 최소 개수를 출력합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(√n)입니다. 제곱수를 찾기 위해 최대 √n 번의 반복을 수행하며, 각 반복마다 추가적인 O(√n) 반복이 있을 수 있으나, 전체적으로는 O(√n) 범위 내에서 처리됩니다.

---

## 코드
```python
import sys

# n = int(input())

# dp = [0, 1]

# for i in range(2, n+1):
#     min_value = 4
#     for j in range(1, int(i ** 0.5) + 1):
#         min_value = min(min_value, dp[i-(j ** 2)])

#     dp.append(min_value + 1)

# print(dp[n])


n = int(input())
sq = [0 if i**0.5%1 else 1 for i in range(n+1)] # 제곱수는 1로 저장

mincount = 4
for i in range(int(n**0.5), 0, -1):
    if sq[n] : # n이 제곱수일 경우
        mincount=1
        break
    elif sq[n-i**2] : # 나머지가 제곱수일 경우
        mincount=2
        break
    else:
        for j in range(int((n-i**2)**0.5), 0, -1):
            if sq[(n-i**2)-j**2]: # 제곱수를 한번 더 뺀 나머지가 제곱수일 경우
                mincount=3
print(mincount)
```