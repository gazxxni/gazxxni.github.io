---
layout: post
title: "[백준] 16566번 (Python)"
date: 2025-09-27
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "16566"]
---

## 문제 링크
[https://www.acmicpc.net/problem/16566](https://www.acmicpc.net/problem/16566)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 카드 숫자들 중에서 학생들이 원하는 숫자에 대해 가장 가까운 숫자를 찾아주는 문제입니다. 이때, 학생들이 원한 숫자보다 작거나 같은 카드 숫자들 중에서 가장 큰 숫자를 찾고, 중복된 카드 숫자가 있을 경우에는 중복을 피하기 위해 Union-Find 자료구조를 사용하여 이미 선택된 숫자를 제외합니다.

### 동작 과정
1. **입력 처리**: 먼저, 카드 숫자와 학생들이 원하는 숫자를 입력받습니다. 예를 들어, `n = 5`, `m = 4`, `k = 10`이고 카드 숫자가 `[5, 4, 3, 2, 1]`, 학생들이 원하는 숫자가 `[3, 6, 2, 5]`라고 가정합니다.
   
2. **정렬**: 카드 숫자를 정렬하여 `[1, 2, 3, 4, 5]`가 됩니다.

3. **Upper Bound 함수**: 각 학생이 원하는 숫자에 대해 `upper_bound` 함수를 사용해 그 숫자보다 작거나 같은 카드 숫자의 위치를 찾습니다. 예를 들어, 학생이 3을 원할 때 `upper_bound`는 3의 위치인 3을 반환합니다.

4. **Union-Find**: 카드 숫자의 위치를 찾은 후, Union-Find를 통해 이미 선택된 숫자는 제외합니다. 예를 들어, 첫 번째 학생이 3을 원하고, 3의 위치가 3이라면, `parent` 배열을 업데이트하여 해당 위치에 있는 숫자를 다음으로 점유할 수 없도록 합니다.

5. **결과 출력**: 모든 학생의 요청에 대해 반복하여 가장 적합한 카드 숫자를 찾아서 결과를 출력합니다.

### 시간 복잡도
- 카드 숫자를 정렬하는 데 \(O(n \log n)\)이 소요됩니다.
- 각 학생의 요청에 대해 이진 탐색을 통해 upper bound를 찾는 데 \(O(\log n)\)이 소요되고, Union-Find 연산은 평균적으로 \(O(\alpha(m))\) (여기서 \(\alpha\)는 아커만 함수의 역함수)입니다.
- 따라서 전체 시간 복잡도는 \(O(n \log n + m \log n)\)입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n, m, k = map(int, input().split())
card_num = list(map(int, input().split()))
chulsu = list(map(int, input().split()))

card_num.sort()

def upper_bound(arr, x):
    st, ed = 0, len(arr)
    
    while st < ed:
        mid = (st + ed) // 2
        
        if arr[mid] <= x:
            st = mid + 1
        else:
            ed = mid
            
    return st

parent = list(range(m + 1))

def find(x):
    if parent[x] != x:
        parent[x] = find(parent[x])
        
    return parent[x]

ans = []

for i in chulsu:
    pos = upper_bound(card_num, i)
    pos = find(pos)  
    
    ans.append(card_num[pos])
    parent[pos] = find(pos + 1)
    
for i in ans:
    print(i)
```