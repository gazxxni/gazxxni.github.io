---
layout: post
title: "[백준] 10830번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "10830"]
---

## 문제 링크
[https://www.acmicpc.net/problem/10830](https://www.acmicpc.net/problem/10830)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 행렬을 특정 제곱수만큼 거듭제곱한 결과를 구하는 문제입니다. 행렬의 거듭제곱은 분할 정복을 사용하여 효율적으로 계산할 수 있으며, 모듈로 연산을 통해 결과를 1000으로 제한합니다.

### 동작 과정
1. **입력 처리**: 
   - 첫 번째 줄에서 행렬의 크기 `n`과 거듭제곱할 수 `b`를 입력받습니다.
   - 다음 `n`줄에 걸쳐 행렬 `a`를 입력받습니다.

2. **행렬 곱셈 함수(`mul`)**:
   - 두 개의 `n x n` 행렬 `A`와 `B`를 입력받아 행렬 곱셈을 수행합니다.
   - 각 원소는 `(result[i][j] + A[i][k] * B[k][j]) % mod`를 통해 계산되며, 결과 행렬 `result`를 반환합니다.

3. **행렬 거듭제곱 함수(`mat_pow`)**:
   - 거듭제곱할 수 `b`가 1인 경우 행렬을 모듈로 `mod`로 나누어 반환합니다.
   - `b`가 짝수일 경우, `mat_pow(a, b // 2)`를 호출하여 행렬을 절반 거듭제곱한 후 이를 곱합니다.
   - `b`가 홀수일 경우, 한 번 더 `mat_pow(a, b - 1)`을 호출하여 결과에 원래 행렬 `a`를 곱합니다.

4. **결과 출력**:
   - 최종적으로 반환된 행렬 `result`를 출력합니다.

예시 입력:
```
2 5
1 2
3 4
```
- 행렬 `a`는 다음과 같습니다:
```
1 2
3 4
```
- `b`는 5이므로 `a`의 5제곱을 계산합니다.
- `mat_pow` 함수의 호출을 통해 재귀적으로 거듭제곱을 수행하고, 최종 결과를 출력합니다.

### 시간 복잡도
- 행렬 곱셈 함수는 `O(n^3)`의 시간 복잡도를 가집니다.
- `mat_pow` 함수는 거듭제곱을 로그 시간에 수행하므로, 전체 시간 복잡도는 `O(n^3 log b)`입니다.

---

## 코드
```python
n, b = map(int, input().split())
a = [list(map(int, input().split())) for _ in range(n)]
mod = 1000  

def mul(A, B):
    result = [[0] * n for _ in range(n)]
    for i in range(n):
        for j in range(n):
            for k in range(n):
                result[i][j] = (result[i][j] + A[i][k] * B[k][j]) % mod
    return result

def mat_pow(a, b):
    if b == 1:
        for x in range(len(a)):
            for y in range(len(a)):
                a[x][y] %= mod
        return a
    
    if b % 2 == 0:
        half = mat_pow(a, b // 2)
        return mul(half, half)
    else:
        return mul(a, mat_pow(a, b - 1))

result = mat_pow(a, b)
for row in result:
    print(" ".join(map(str, row)))




```