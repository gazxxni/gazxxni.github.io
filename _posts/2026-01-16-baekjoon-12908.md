---
layout: post
title: "[백준] 12908번 텔레포트 3 (Python)"
date: 2026-01-16
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "12908", 그래프 이론, 브루트포스 알고리즘, 최단 경로, 플로이드–워셜]
---

## 문제 링크
[https://www.acmicpc.net/problem/12908](https://www.acmicpc.net/problem/12908)

---

## 문제
수빈이는 크기가 무한대인 격자판 위에 살고 있다. 격자판의 각 점은 두 정수의 쌍 (x, y)로 나타낼 수 있다.

제일 처음에 수빈이의 위치는 (xs, ys)이고, 집이 위치한 (xe, ye)로 이동하려고 한다.

수빈이는 두 가지 방법으로 이동할 수 있다. 첫 번째 방법은 점프를 하는 것이다. 예를 들어 (x, y)에 있는 경우에 (x+1, y), (x-1, y), (x, y+1), (x, y-1)로 이동할 수 있다. 점프는 1초가 걸린다.

두 번째 방법은 텔레포트를 사용하는 것이다. 텔레포트를 할 수 있는 방법은 총 세 가지가 있으며, 미리 정해져 있다. 텔레포트는 네 좌표 (x1, y1), (x2, y2)로 나타낼 수 있으며, (x1, y1)에서 (x2, y2)로 또는 (x2, y2)에서 (x1, y1)로 이동할 수 있다는 것이다. 텔레포트는 10초가 걸린다.

수빈이의 위치와 집의 위치가 주어졌을 때, 집에 가는 가장 빠른 시간을 구하는 프로그램을 작성하시오.

---

## 입력
첫째 줄에 xs와 ys가, 둘째 줄에 xe, ye가 주어진다. (0 ≤ xs, ys, xe, ye ≤ 1,000,000,000)

셋째 줄부터 세 개의 줄에는 텔레포트의 정보 x1, y1, x2, y2가 주어진다. (0 ≤ x1, y1, x2, y2 ≤ 1,000,000,000)

입력으로 주어지는 모든 좌표 8개는 서로 다르다.

---

## 출력
수빈이가 집에 가는 가장 빠른 시간을 출력한다.

---

## 성능 요약
메모리: 111284 KB, 시간: 120 ms

---

## 풀이

### 풀이 핵심 로직
주어진 문제는 수빈이가 집까지 가는 최단 시간을 찾는 문제로, 점프와 텔레포트 두 가지 이동 방법을 사용할 수 있다. 점프는 인접한 4개의 칸으로 1초에 이동할 수 있으며, 텔레포트는 미리 정해진 두 지점 간에 10초에 이동할 수 있다. 다익스트라 알고리즘을 활용하여, 점프와 텔레포트를 이용해 최단 경로를 계산한다.

### 동작 과정
1. **입력 및 초기화**:
   - 수빈이의 시작 위치 `(xs, ys)`와 집의 위치 `(xe, ye)`를 입력받는다.
   - 3개의 텔레포트 지점 정보를 입력받아 각각의 지점을 그래프의 노드로 저장한다.

2. **다익스트라 알고리즘 준비**:
   - 각 노드까지의 거리를 무한대로 초기화하고, 시작 노드의 거리를 0으로 설정한다.
   - 우선순위 큐를 사용하여 노드를 방문할 순서를 관리한다.

3. **다익스트라 알고리즘 실행**:
   - 시작 노드에서 출발하여, 현재 노드에서 집까지의 거리와 텔레포트를 사용할 때의 비용을 계산한다.
   - 현재 노드에서 텔레포트 가능한 노드들로 이동할 때의 비용을 계산하여 갱신한다.
   - 현재 노드에서 다른 모든 텔레포트 지점으로 점프할 때의 비용도 계산하여 갱신한다.

4. **최소 비용 계산**:
   - 각 노드를 방문하면서 집까지의 최단 거리(min_cost)를 지속적으로 업데이트하여 최종적으로 가장 빠른 시간을 도출한다.

**예시 입력**:
```
0 0
10 10
1 1 2 2
3 3 4 4
5 5 6 6
```
- 수빈이의 시작 위치는 `(0, 0)`이고 집은 `(10, 10)`이다.
- 텔레포트 지점은 세 쌍으로 주어진다. 
- 다익스트라 알고리즘을 적용하여, 수빈이가 텔레포트를 사용할 때와 점프할 때의 최단 경로를 계산하여 집까지의 최소 시간을 구한다.

### 시간 복잡도
- 다익스트라 알고리즘의 시간 복잡도는 O((V + E) log V)이다. 여기서 V는 노드의 수, E는 간선의 수를 의미한다. 본 문제에서는 텔레포트 노드가 최대 6개(3개의 텔레포트 지점에서 각각 두 노드)일 것으로 예상되므로, 실제로는 O(E log V) 형태로 실행된다.

---

## 코드
```python
import sys, heapq
from collections import defaultdict
'''
BFS로 풀면 모든 지점을 다 돌아야해서 시간초과
-> 다익스트라로 텔레포트 사용 구간만 검사, 텔레포트 안 쓰면 그냥 긴 거리가 답
'''
input = sys.stdin.readline

xs, ys = map(int, input().split())
xe, ye = map(int, input().split())

start_node = (xs, ys)
end_node = (xe, ye)

tp_dic = defaultdict(list)
tp_node = set()

for _ in range(3):
    x1, y1, x2, y2 = map(int, input().split())
    node1 = (x1, y1)
    node2 = (x2, y2)
    
    tp_node.add(node1)
    tp_node.add(node2)

    tp_dic[node1].append((node2, 10))
    tp_dic[node2].append((node1, 10))

key_nodes = list(tp_node)
key_nodes.append(start_node)

distances = {node: float('inf') for node in key_nodes}
distances[start_node] = 0

pq = [(0, start_node)]

# 시작점에서 도착점까지 가는 비용 (이게 기본 답)
min_cost = abs(xs - xe) + abs(ys - ye)

while pq:
    current_cost, current_node = heapq.heappop(pq)

    if current_cost > distances[current_node]:
        continue

    # 현재 위치에서 도착점까지 비용
    # (현재까지 비용 + 지금 위치에서 도착점까지 걷는 비용)
    cost_via_current = current_cost + abs(current_node[0] - end_node[0]) + abs(current_node[1] - end_node[1])
    min_cost = min(min_cost, cost_via_current)
    
    # 텔레포트 
    if current_node in tp_dic:
        for next_node, tele_cost in tp_dic[current_node]:
            new_cost = current_cost + tele_cost
            if new_cost < distances[next_node]:
                distances[next_node] = new_cost
                heapq.heappush(pq, (new_cost, next_node))

    # 현재 위치에서 모든 텔레포트 지점까지 비용 계산
    for next_tp_node in tp_node:
        if current_node == next_tp_node:
            continue
            
        walk_cost = abs(current_node[0] - next_tp_node[0]) + abs(current_node[1] - next_tp_node[1])
        new_cost = current_cost + walk_cost
        
        if new_cost < distances[next_tp_node]:
            distances[next_tp_node] = new_cost
            heapq.heappush(pq, (new_cost, next_tp_node))

print(min_cost)
```