---
layout: post
title: "[백준] 9019번 (Python)"
date: 2024-11-29
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "9019"]
---

## 문제 링크
[https://www.acmicpc.net/problem/9019](https://www.acmicpc.net/problem/9019)

---

## 풀이

### 풀이 핵심 로직
이 문제는 특정 숫자 A를 주어진 연산을 통해 숫자 B로 변환하는 방법을 찾는 문제로, BFS(너비 우선 탐색)를 사용하여 최단 경로를 찾는다. 각 숫자에서 가능한 네 가지 연산(D, S, L, R)을 수행하고, 방문 여부를 체크하여 이미 방문한 숫자는 다시 탐색하지 않도록 하여 효율성을 높인다.

### 동작 과정
예를 들어, A=1234, B=3412인 경우를 생각해보자.

1. 초기 상태: A(1234)에서 시작하여 BFS 큐에 (1234, '')를 추가하고 방문 표시를 한다.
2. 첫 번째 연산 D(2배): 1234 * 2 = 2468 (큐에 (2468, 'D') 추가)
3. 두 번째 연산 S(1 감소): 1234 - 1 = 1233 (큐에 (1233, 'S') 추가)
4. 세 번째 연산 L(왼쪽 회전): 1234 → 2341 (큐에 (2341, 'L') 추가)
5. 네 번째 연산 R(오른쪽 회전): 1234 → 4123 (큐에 (4123, 'R') 추가)
6. 이제 큐에서 다음 숫자를 꺼내어 반복한다. 이 과정을 통해 B(3412)에 도달할 때까지 계속 진행한다.
7. 최종적으로 B에 도달하면 연산 기록을 출력한다. 

이 과정은 BFS의 특성으로 인해 최단 경로를 보장한다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(V + E)로 볼 수 있으며, 여기서 V는 10000(0부터 9999까지의 숫자)이고 E는 각 숫자에서 가능한 네 가지 연산에 의해 생성되는 엣지 수이다. 따라서 전체적으로 O(10000)으로 간주할 수 있다.

---

## 코드
```python
from collections import deque 

t = int(input().strip())

for _ in range(t):
    visited = [False] * 10001
    
    a, b = map(int, input().strip().split())

    q = deque()
    q.append([a, ''])  # 초기값으로 A와 빈 문자열 추가
    visited[a] = True  # a를 방문했음을 표시

    while q:
        n, cmd = q.popleft()
        
        if n == b:  # 목표 b가 나오면 기록 출력
            print(cmd)
            break

        # **연산 D**: 현재 숫자 * 2, 결과가 10000을 넘으면 10000으로 나눈 나머지
        d = (n * 2) % 10000
        if not visited[d]:      
            visited[d] = True       
            q.append([d, cmd + 'D'])  # 큐에 새로운 상태와 연산 기록 추가

        # **연산 S**: 현재 숫자 - 1, 결과가 음수면 9999로 변경
        s = (n - 1) % 10000
        if not visited[s]:
            visited[s] = True
            q.append([s, cmd + 'S'])

        # **연산 L**: 현재 숫자를 왼쪽으로 회전  # 1234 → 2341 (앞의 자리수를 뒤로 이동)
        l = n // 1000 + (n % 1000) * 10
        if not visited[l]:
            visited[l] = True
            q.append([l, cmd + 'L'])

        # **연산 R**: 현재 숫자를 오른쪽으로 회전  # 1234 → 4123 (뒤의 자리수를 앞으로 이동)
        r = n // 10 + (n % 10) * 1000
        if not visited[r]:
            visited[r] = True
            q.append([r, cmd + 'R'])

```