---
layout: post
title: "[백준] 16953번 (Python)"
date: 2025-02-20
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "16953"]
---

## 문제 링크
[https://www.acmicpc.net/problem/16953](https://www.acmicpc.net/problem/16953)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 두 수 \( a \)와 \( b \)를 변환하기 위해 BFS(너비 우선 탐색)를 사용하여 최소 변환 횟수를 찾는 것이다. 두 가지 변환 연산(2배 또는 1을 오른쪽에 추가)을 통해 \( a \)를 \( b \)로 만드는 경로를 탐색하며, \( b \)보다 클 경우 더 이상 탐색하지 않도록 한다.

### 동작 과정
1. 입력: `a = 2`, `b = 162`
2. 초기 큐: `[(2, 1)]` (현재 숫자 2, 변환 횟수 1)
3. 1차 반복:
   - `now = 2`, `cnt = 1`
   - 2배 변환: `4`, 큐에 추가 `[(4, 2)]`
   - 1 추가 변환: `21`, 큐에 추가 `[(4, 2), (21, 2)]`
4. 2차 반복:
   - `now = 4`, `cnt = 2`
   - 2배 변환: `8`, 큐에 추가 `[(21, 2), (8, 3)]`
   - 1 추가 변환: `41`, 큐에 추가 `[(21, 2), (8, 3), (41, 3)]`
5. 3차 반복:
   - `now = 21`, `cnt = 2`
   - 2배 변환: `42`, 큐에 추가 `[(8, 3), (41, 3), (42, 3)]`
   - 1 추가 변환: `211`, 큐에 추가 `[(8, 3), (41, 3), (42, 3), (211, 3)]`
6. 이 과정을 반복하여 `now`가 `b`와 일치할 때까지 진행한다. 최종적으로 `b`에 도달하면 변환 횟수를 반환한다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 \( O(N) \)로, \( N \)은 큐에 들어가는 숫자들의 수에 비례한다. 그러나 실제로는 \( b \)에 가까운 값만 탐색하기 때문에, 메모리와 시간 측면에서 효율적으로 동작한다.

---

## 코드
```python
import sys
input = sys.stdin.readline
from collections import deque

a, b = map(int, input().split())

def bfs(a, b):
    q = deque()
    q.append((a, 1))  # (현재 숫자, 변환 횟수)

    while q:
        now, cnt = q.popleft()

        if now > b:
            continue

        if now == b:
            return cnt  

        q.append((now * 2, cnt + 1))
        q.append((int(str(now) + "1"), cnt + 1))

    return -1  

print(bfs(a, b))

```