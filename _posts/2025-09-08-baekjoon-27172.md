---
layout: post
title: "[백준] 27172번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "27172"]
---

## 문제 링크
[https://www.acmicpc.net/problem/27172](https://www.acmicpc.net/problem/27172)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 각 숫자에 대해 그 숫자의 두 배, 세 배 등의 형태로 존재하는 숫자를 세는 것이다. 이를 위해 입력된 배열을 집합(set)으로 변환하여 빠른 조회가 가능하게 하고, 각 숫자의 카운트를 관리하기 위해 딕셔너리(dict)를 사용한다. 이 과정을 통해 각 숫자에 대해 몇 개의 배수(2배, 3배 등)가 배열에 존재하는지 계산할 수 있다.

### 동작 과정
1. 입력으로 `n`(숫자의 개수)와 `arr`(숫자 배열)을 받는다.
   - 예시 입력: `5` (n), `1 2 1 3 2` (arr)
   
2. `set_arr`를 생성하여 `arr`의 모든 숫자를 집합으로 저장한다. 이를 통해 O(1) 시간 복잡도로 숫자가 존재하는지 확인할 수 있다.
   - set_arr = {1, 2, 3}

3. `ans`라는 딕셔너리를 초기화하여 `arr`의 각 숫자에 대해 0으로 카운트를 설정한다.
   - ans = {1: 0, 2: 0, 3: 0}

4. 각 숫자 `i`에 대해, `j`를 `i * 2`로 초기화하고, `j`가 `MAX`(1000000) 이하인 동안 반복한다.
   - 예를 들어, `i = 1`인 경우, `j = 2`, `4`, `6`, ... 순으로 증가한다.

5. `j`가 `set_arr`에 존재할 경우, `ans[i]`의 카운트를 증가시키고 `ans[j]`의 카운트를 감소시킨다. 
   - 이 과정에서 `i = 1`일 때 `j = 2`가 set_arr에 있으므로, ans[1] += 1, ans[2] -= 1이 수행된다.

6. 이 과정을 통해 모든 숫자에 대한 카운트를 업데이트 한 후, 최종적으로 각 숫자의 카운트를 출력한다.
   - 최종 출력 예시: `1 0 0` (1은 1의 배수가 1개, 2는 2의 배수가 없고, 3은 3의 배수가 없으므로)

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n + k)로, 여기서 n은 입력 배열의 크기, k는 각 숫자에 대해 최대 `MAX/i` (i는 배열의 각 숫자) 만큼의 반복이 있을 수 있다. 하지만 각 숫자에 대해 O(1) 시간으로 배수를 체크하므로, 실제로는 O(n log(MAX))에 가까운 성능을 보인다.

---

## 코드
```python
import sys
input = sys.stdin.readline

MAX = 1000000

n = int(input())
arr = list(map(int, input().split()))

set_arr = set(arr)
ans = dict.fromkeys(arr, 0)

for i in arr:
    j = i * 2
    while j <= MAX:
        if j in set_arr:
            ans[i] += 1       
            ans[j] -= 1   
        j += i

print(*[ans[x] for x in arr])

```