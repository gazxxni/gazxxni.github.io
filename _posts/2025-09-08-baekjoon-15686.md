---
layout: post
title: "[백준] 15686번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "15686"]
---

## 문제 링크
[https://www.acmicpc.net/problem/15686](https://www.acmicpc.net/problem/15686)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 집들과 치킨집들 사이의 거리를 계산하여, `m`개의 치킨집을 선택했을 때 집에서 가장 가까운 치킨집까지의 거리를 최소화하는 문제이다. 이를 위해 DFS를 사용하여 모든 조합의 치킨집을 선택하고, 각 조합에 대해 집들과의 거리를 계산하여 최소 거리를 갱신한다.

### 동작 과정
1. **입력**: 예를 들어, 입력이 다음과 같다고 가정하자.
   ```
   5 3
   0 1 0 0 2
   0 0 0 0 0
   0 0 0 0 0
   0 2 0 1 0
   2 0 0 0 0
   ```
   여기서 `n = 5` (5x5 격자), `m = 3` (세 개의 치킨집 선택)이다. 
   
2. **집과 치킨집 위치 저장**: 입력을 통해 1(집)과 2(치킨집)의 위치를 각각 `house`와 `chicken` 리스트에 저장한다.
   - `house = [(0, 1), (3, 3)]` (두 집의 위치)
   - `chicken = [(0, 4), (3, 1), (4, 0)]` (세 치킨집의 위치)

3. **DFS를 통한 조합 선택**: `dfs` 함수를 사용하여 가능한 모든 `m`개의 치킨집 조합을 선택한다. 각 조합을 선택할 때마다 `chicken_dist` 함수를 호출하여 현재 선택된 치킨집들과의 거리를 계산한다.

4. **거리 계산**: `chicken_dist` 함수는 선택된 치킨집들에 대해서 각 집에서 가장 가까운 치킨집까지의 거리를 계산하고, 이 거리의 합을 반환한다.

5. **최소 거리 업데이트**: 모든 조합에 대해 계산된 거리 중 최솟값을 `result`에 저장하고, 최종적으로 이 값을 출력한다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(C(n, m) * h * c)이다. 여기서:
- C(n, m)은 n개의 치킨집 중 m개를 선택하는 조합의 수 (조합)
- h는 집의 수 (집마다의 거리 계산)
- c는 선택된 치킨집의 수 (거리 계산 시 반복)
- 따라서, 최악의 경우에 모든 치킨집을 선택하고, 모든 집에 대한 거리를 계산해야 하므로 이 복잡도는 상대적으로 높은 편이다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n, m = map(int, input().split())
house = []  
chicken = [] 

for i in range(n):
    arr = list(map(int, input().split()))
    for j in range(n):
        if arr[j] == 1:
            house.append((i, j)) 
        elif arr[j] == 2:
            chicken.append((i, j)) 

result = float('inf')
selected = [] 

def chicken_dist():
    total_distance = 0

    # 모든 집에 대해 가장 가까운 치킨집과의 거리 계산
    for hx, hy in house:
        min_distance = float('inf')
        for cx, cy in selected:
            min_distance = min(min_distance, abs(hx - cx) + abs(hy - cy))
        total_distance += min_distance

    return total_distance

def dfs(idx, cnt):
    global result

    # 만약 m개의 치킨집을 선택했다면 최소 거리 갱신
    if cnt == m:
        result = min(result, chicken_dist())
        return

    for i in range(idx, len(chicken)):
        selected.append(chicken[i])  # 치킨집 선택
        dfs(i + 1, cnt + 1)  # 다음 치킨집 선택
        selected.pop()  # 백트래킹 (선택 해제)

dfs(0, 0)
print(result)

```