---
layout: post
title: "[백준] 1931번 (Python)"
date: 2024-09-28
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1931"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1931](https://www.acmicpc.net/problem/1931)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 회의의 종료 시간을 기준으로 회의를 정렬한 후, 이전 회의의 종료 시간 이후에 시작하는 회의만 선택하여 최대 개수의 회의를 선택하는 것입니다. 이를 통해 중복되는 시간을 피하고 가능한 많은 회의를 수용할 수 있습니다.

### 동작 과정
입력 예시: 
```
5
1 3
2 4
3 5
4 6
5 7
```

1. 첫째 줄에서 회의의 개수인 `n`이 `5`로 입력됩니다.
2. 다음 `5`줄에서 각 회의의 시작 시간과 종료 시간이 입력되어 리스트 `arr`에 저장됩니다. 이 리스트는 다음과 같습니다: `[[1, 3], [2, 4], [3, 5], [4, 6], [5, 7]]`.
3. 회의 목록을 종료 시간을 기준으로 오름차순 정렬합니다. 같은 종료 시간일 경우 시작 시간을 기준으로 정렬합니다. 정렬된 결과는 `[[1, 3], [2, 4], [3, 5], [4, 6], [5, 7]]`입니다.
4. 첫 번째 회의를 선택하여 종료 시간을 `imp`에 저장하고 카운터 `cnt`를 1로 초기화합니다.
5. 두 번째 회의부터 순차적으로 확인하며, 각 회의의 시작 시간이 `imp`보다 크거나 같은 경우에만 회의를 선택합니다. 이때 `imp`를 현재 회의의 종료 시간으로 갱신하고, 카운터를 증가시킵니다.
   - 첫 번째 회의 (1, 3) 선택 → `cnt = 1`, `imp = 3`
   - 두 번째 회의 (2, 4) 선택하지 않음
   - 세 번째 회의 (3, 5) 선택 → `cnt = 2`, `imp = 5`
   - 네 번째 회의 (4, 6) 선택하지 않음
   - 다섯 번째 회의 (5, 7) 선택 → `cnt = 3`, `imp = 7`
6. 최종적으로 선택할 수 있는 최대 회의의 개수 `cnt`를 출력합니다. 이 경우 결과는 `3`입니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 주로 정렬에 의해 결정됩니다. 리스트를 정렬하는 데 필요한 시간 복잡도는 O(n log n)이며, 회의 선택 과정은 O(n)입니다. 따라서 전체 시간 복잡도는 O(n log n)입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
arr = []

for _ in range(n):
    a, b = map(int, input().split())
    arr.append([a, b])

# 끝나는 시간을 기준으로 오름차순 정렬, 끝나는 시간이 같으면 시작 시간 기준으로 정렬
arr.sort(key=lambda x: (x[1], x[0]))

# 첫 번째 회의를 선택했으므로 카운터를 1로 설정
cnt = 1

# 첫 번째 회의의 종료 시간을 imp에 저장
imp = arr[0][1]

# 두 번째 회의부터 차례로 확인
for i in range(1, n):
    # 현재 회의의 시작 시간이 이전 회의의 종료 시간 이후일 경우에만 선택
    if arr[i][0] >= imp:
        imp = arr[i][1]  # imp에 현재 회의의 종료 시간을 저장
        cnt += 1

print(cnt)

```