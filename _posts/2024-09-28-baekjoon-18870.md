---
layout: post
title: "[백준] 18870번 (Python)"
date: 2024-09-28
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "18870"]
---

## 문제 링크
[https://www.acmicpc.net/problem/18870](https://www.acmicpc.net/problem/18870)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 중복을 제거하고 정렬된 리스트를 생성하여 각 원소의 순위를 매기는 것입니다. 이를 위해, 입력 배열에서 중복된 값을 제거하고 정렬한 후, 각 원소에 대해 해당하는 인덱스를 순위로 저장하는 딕셔너리를 사용합니다.

### 동작 과정
1. **입력 받기**: `n`개의 정수를 입력받아 리스트 `arr`에 저장합니다.
   - 예시 입력: `5` (n), `40 10 20 30 10`
2. **중복 제거 및 정렬**: `set(arr)`을 사용하여 중복 값을 제거하고, `sorted()` 함수를 통해 오름차순으로 정렬하여 새로운 리스트 `result`를 만듭니다.
   - `result` = `[10, 20, 30, 40]`
3. **순위 매기기**: 딕셔너리 `rank`를 생성하여 각 값에 대해 그 값의 인덱스를 순위로 매깁니다. 
   - `rank` = `{10: 0, 20: 1, 30: 2, 40: 3}`
4. **원본 배열의 순위 변환**: 원본 배열 `arr`의 각 원소를 딕셔너리 `rank`를 통해 해당 순위로 변환합니다.
   - 변환 후 `arr` = `[3, 0, 1, 2, 0]`
5. **결과 출력**: 최종적으로 변환된 `arr`의 각 원소를 출력합니다.
   - 출력: `3`, `0`, `1`, `2`, `0`

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n log n)입니다. 이는 중복 제거 및 정렬을 수행하는 `sorted(set(arr))`의 시간 복잡도 때문이며, 나머지 연산들은 O(n)입니다. 따라서 전체 알고리즘의 복잡도는 O(n log n)으로 평가할 수 있습니다.

---

## 코드
```python
import sys

n = int(input())
arr = list(map(int, input().split()))

result = sorted(set(arr))  # 중복 제거 및 정렬

# 딕셔너리를 사용하여 값의 순위를 저장 (해쉬테이블)
rank = {value: idx for idx, value in enumerate(result)}

# arr의 각 값에 해당하는 순위를 저장
for i in range(len(arr)):
    arr[i] = rank[arr[i]]  # 딕셔너리에서 순위 찾기

for i in arr:
    print(i)

```