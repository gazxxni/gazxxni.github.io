---
layout: post
title: "[백준] 2630번 (Python)"
date: 2024-11-23
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2630"]
---

## 문제 링크
[https://www.acmicpc.net/problem/2630](https://www.acmicpc.net/problem/2630)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 색종이를 재귀적으로 4등분하여 각 구역의 색상이 동일한지 확인하는 방식으로 해결합니다. 색상이 다르면 해당 영역을 다시 4등분하여 재귀적으로 처리하고, 모든 칸의 색상이 동일한 경우에는 해당 색상 카운트를 증가시킵니다.

### 동작 과정
예시 입력: 
```
8
0 0 1 1 0 0 1 1
0 0 1 1 0 0 1 1
0 0 0 0 0 1 1 1
0 0 0 0 0 1 1 1
1 1 0 0 0 0 0 0
1 1 0 0 0 0 0 0
1 1 1 1 1 1 1 1
1 1 1 1 1 1 1 1
```

1. 입력된 배열의 크기 `n`은 8입니다. 
2. `divide(0, 0, 8)`이 호출되어 전체 영역을 처리하기 시작합니다.
3. 첫 번째 색상을 기준으로 설정하고, 모든 색상이 동일한지 확인합니다. 이 경우에는 색상이 다르기 때문에 4등분합니다.
4. 각 부분에 대해 `divide` 함수를 재귀적으로 호출합니다:
   - 왼쪽 위 (0, 0)에서 (4, 4)
   - 오른쪽 위 (0, 4)에서 (4, 4)
   - 왼쪽 아래 (4, 0)에서 (4, 4)
   - 오른쪽 아래 (4, 4)에서 (4, 4)
5. 이 과정은 계속 반복되며, 구역이 모두 같은 색상일 때 카운트가 증가합니다.
6. 최종적으로 흰색(0)과 파란색(1)의 개수를 출력합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n^2)입니다. 모든 칸을 확인해야 하므로, 최악의 경우 n^2번의 연산이 필요합니다. 하지만 재귀적으로 4등분하여 문제를 해결하기 때문에, 실제로는 더 빨리 종료될 수 있습니다.

---

## 코드
```python
import sys
input=sys.stdin.readline

white = 0
blue = 0

n = int(input())
arr = [list(map(int, input().split())) for _ in range(n)]

def divide(x, y, size):
    global white, blue

    # 첫 번째 칸의 색상을 기준으로 설정
    color = arr[x][y]

    # 해당 영역의 모든 칸이 같은 색인지 확인
    for i in range(x, x + size):
        for j in range(y, y + size):
            if arr[i][j] != color:
                # 색상이 다른 경우 4등분하여 재귀적으로 처리
                half = size // 2
                divide(x, y, half)  # 왼쪽 위
                divide(x, y + half, half)  # 오른쪽 위
                divide(x + half, y, half)  # 왼쪽 아래
                divide(x + half, y + half, half)  # 오른쪽 아래
                return

    # 모두 같은 색이라면 해당 색의 카운트를 증가시킴
    if color == 0:
        white += 1
    else:
        blue += 1

# 전체 색종이를 나누는 재귀 함수 호출
divide(0, 0, n)

# 결과 출력
print(white)
print(blue)


```