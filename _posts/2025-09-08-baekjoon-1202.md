---
layout: post
title: "[백준] 1202번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1202"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1202](https://www.acmicpc.net/problem/1202)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 보석을 가방에 담는 최적의 방법을 찾는 문제입니다. 각 보석은 무게와 가치를 가지고 있으며, 가방은 최대 수용 가능한 무게가 정해져 있습니다. 문제의 핵심 아이디어는 가방의 용량에 맞는 보석 중에서 가장 높은 가치를 가진 보석을 선택하는 것입니다. 이를 위해 보석을 무게 기준으로 정렬하고, 각 가방의 용량에 따라 가능한 보석을 우선순위 큐(최대 힙)에 저장하여 가방마다 최대 가치를 가진 보석을 선택합니다.

### 동작 과정
1. 입력: `n`개의 보석과 `k`개의 가방의 정보를 입력받습니다.
   - 예시 입력: 
     ```
     3 2
     1 65
     5 23
     2 99
     1
     2
     ```
   - 보석: [(1, 65), (5, 23), (2, 99)] -> (무게, 가치)
   - 가방: [1, 2]

2. 보석과 가방을 각각 무게 기준으로 정렬합니다.
   - 정렬된 보석: [(1, 65), (2, 99), (5, 23)]
   - 정렬된 가방: [1, 2]

3. 가방의 용량을 하나씩 처리하며, 해당 가방의 용량을 만족하는 보석을 최대 힙에 추가합니다.
   - 가방의 용량이 1일 때:
     - 보석(1, 65) 추가 -> 힙: [-65]
     - 가방에 담을 수 있는 보석 중 최대 가치인 65를 선택 -> 총 가치: 65
   - 가방의 용량이 2일 때:
     - 보석(2, 99) 추가 -> 힙: [-99]
     - 가방에 담을 수 있는 보석 중 최대 가치인 99를 선택 -> 총 가치: 164

4. 최종적으로 모든 가방에 대해 가능한 최대 가치를 구하고 출력합니다.
   - 출력: 164

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O((n + k) log n)입니다. 여기서 n은 보석의 개수, k는 가방의 개수입니다. 보석을 정렬하는 데 O(n log n), 가방을 정렬하는 데 O(k log k), 그리고 각 가방마다 보석을 힙에 추가하거나 빼는 데 O(log n)의 시간이 소요됩니다.

---

## 코드
```python
import sys, heapq
input = sys.stdin.readline

n, k = map(int, input().split())

jew = []
for _ in range(n):
    m, v = map(int, input().split())
    jew.append((m, v))
    
bag = [int(input()) for _ in range(k)]

jew.sort()
bag.sort()

heap = []
value = 0
jew_idx = 0

for i in bag:
    
    while jew_idx < n and jew[jew_idx][0] <= i:
        heapq.heappush(heap, -jew[jew_idx][1])
        jew_idx += 1
        
    if heap:
        value += -heapq.heappop(heap)
        
        
print(value)
```