---
layout: post
title: "[백준] 12850번 본대 산책2 (Python)"
date: 2025-12-07
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, 12850, 수학, 그래프 이론, 분할 정복을 이용한 거듭제곱]
---

## 문제 링크
[https://www.acmicpc.net/problem/12850](https://www.acmicpc.net/problem/12850)

---

## 문제
숭실 대학교 정보 과학관은 유배를 당해서  캠퍼스의 길 건너편에 있다. 그래서 컴퓨터 학부 학생들은 캠퍼스를 ‘본대’ 라고 부르고 정보 과학관을 ‘정보대’ 라고 부른다. 준영이 또한 컴퓨터 학부 소속 학생이라서 정보 과학관에 박혀있으며 항상 꽃 이 활짝 핀 본 대를 선망한다. 어느 날 준영이는 본 대를 산책하기로 결심하였다. 숭실 대학교 캠퍼스 지도는 아래와 같다.



(편의 상 문제에서는 위 건물만 등장한다고 가정하자)

한 건물에서 바로 인접한 다른 건물로 이동 하는 데 1분이 걸린다. 준영이는 산책 도중에 한번도 길이나 건물에 멈춰서 머무르지 않는다. 준영이는 할 일이 많아서 딱 D분만 산책을 할 것이다. (산책을 시작 한 지 D분 일 때, 정보 과학관에 도착해야 한다.) 이때 가능한 경로의 경우의 수를 구해주자.

---

## 입력
D 가 주어진다 (1 ≤ D ≤ 1,000,000,000)

---

## 출력
가능한 경로의 수를 1,000,000,007로 나눈 나머지를 출력한다.

---

## 성능 요약
메모리: 109544 KB, 시간: 96 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 그래프의 인접 행렬을 사용하여 경로의 수를 계산하는 문제입니다. 준영이가 D분 동안 본대와 정보대 사이를 이동하는 경우의 수를 구하기 위해, 그래프의 인접 행렬을 D번 거듭 제곱하여 경로의 수를 구합니다. 이를 위해 분할 정복을 이용한 거듭제곱 알고리즘을 사용하여 효율적으로 계산합니다.

### 동작 과정
1. **그래프 정의**: 주어진 문제에서 건물 간의 연결 상태를 인접 행렬로 정의합니다. 각 행렬의 원소는 두 건물 간의 이동 가능성을 나타냅니다.
2. **입력**: D를 입력받습니다. D는 준영이가 산책하는 시간(분)입니다.
3. **거듭 제곱 계산**: 주어진 인접 행렬을 D번 거듭 제곱하여, 각 원소에서 시작 건물(본대)에서 도착 건물(정보대)로 가는 경로의 수를 계산합니다.
   - `cal` 함수는 재귀적으로 행렬을 제곱하는 역할을 하며, 분할 정복을 통해 시간 복잡도를 줄입니다.
   - 만약 n이 홀수인 경우, 한 번 더 행렬을 곱해줍니다.
4. **결과 출력**: 최종적으로 계산된 행렬의 (0, 0) 원소를 출력합니다. 이는 본대에서 정보대로 가는 경로의 수를 나타냅니다. 결과는 1,000,000,007로 나눈 나머지를 출력합니다.

예를 들어, D가 3인 경우:
- 처음 그래프의 인접 행렬을 D=3만큼 거듭 제곱하면, 본대에서 정보대로 가는 모든 가능한 경로의 수를 구할 수 있습니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(log D)입니다. 이는 거듭 제곱을 수행하는 과정에서 분할 정복을 사용하기 때문입니다. 각 행렬 곱셈의 시간 복잡도는 O(V^3)이며, 여기서 V는 그래프의 정점 수입니다. 이 문제에서는 정점 수가 8로 고정되어 있으므로, 최종 시간 복잡도는 O(log D)로 간주할 수 있습니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

MOD = 1_000_000_007

graph = [
    [0,1,1,0,0,0,0,0],
    [1,0,1,1,0,0,0,0],
    [1,1,0,1,1,0,0,0],
    [0,1,1,0,1,1,0,0],
    [0,0,1,1,0,1,0,1],
    [0,0,0,1,1,0,1,0],
    [0,0,0,0,0,1,0,1],
    [0,0,0,0,1,0,1,0],
]

d = int(input().strip())

def multiply(A, B):
    result = [[0] * 8 for i in range(8)]
  
    for i in range(8):
        for j in range(8):
            for k in range(8):
                result[i][j] += A[i][k] * B[k][j]
            result[i][j] %= MOD
      
    return result

def cal(A, n):
    if n == 1:
        return A
    cal2 = cal(A, n//2)
    
    if n % 2 == 0:
        return multiply(cal2, cal2)
    else:
        mul2 = multiply(cal2, cal2)
        return multiply(mul2, A)
    
result = cal(graph, d)
print(result[0][0])
```