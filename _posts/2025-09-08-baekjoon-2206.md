---
layout: post
title: "[백준] 2206번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2206"]
---

## 문제 링크
[https://www.acmicpc.net/problem/2206](https://www.acmicpc.net/problem/2206)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 BFS(너비 우선 탐색)를 사용하여 2차원 격자(grid)에서 출발점(0, 0)에서 도착점(n-1, m-1)으로 가는 최단 경로를 찾는 것이다. 특히, 벽을 한 번 부술 수 있는 조건을 반영하여 방문 상태를 2차원 배열의 세 번째 차원으로 관리한다. 이를 통해 각 좌표(x, y)에서 벽을 부쉈는지 여부에 따라 방문 여부를 구별할 수 있다.

### 동작 과정
1. **입력 받기**: 격자의 세로(n)와 가로(m) 크기를 입력받고, 그리드를 0과 1로 구성된 리스트로 초기화한다. 0은 빈 공간, 1은 벽을 나타낸다.
2. **초기화**: 3차원 리스트 `visited`를 생성하여 각 좌표와 벽을 부쉈는지 여부를 추적한다. `visited[0][0][0]`을 1로 설정하여 시작 위치를 방문한 것으로 표시한다.
3. **BFS 시작**: 큐에 시작 위치(0, 0, 0)를 추가하고 BFS를 시작한다. 큐가 비어 있을 때까지 반복한다.
4. **좌표 이동**: 현재 위치에서 상하좌우로 이동할 수 있는지 확인한다. 
   - 만약 이동하려는 위치가 벽(1)이고, 벽을 부수지 않은 상태(0)라면 벽을 부수고 해당 위치를 방문한 것으로 기록한다.
   - 만약 이동하려는 위치가 빈 공간(0)이며 아직 방문하지 않은 곳이라면 해당 위치를 방문한 것으로 기록한다.
5. **목표 도달 확인**: 현재 위치가 도착점(n-1, m-1)이라면 현재까지의 이동 횟수를 반환한다.
6. **결과 반환**: 목표 지점에 도달하지 못한 경우 -1을 반환한다.

**예시 입력**:
```
4 4
0001
1111
0001
1110
```
- 격자 크기는 4x4이며, 입력된 격자는 아래와 같다:
```
0 0 0 1
1 1 1 1
0 0 0 1
1 1 1 0
```
- BFS를 통해 (0, 0)에서 (3, 3)으로 가는 경로를 찾는다. 
- 벽을 한 번 부술 수 있기 때문에 벽을 부수며 이동하는 경로를 탐색한다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n * m)이다. 각 좌표에 대해 최대 2가지 상태(벽을 부쉈는지 여부)를 고려해야 하기 때문에 최악의 경우 각 좌표를 두 번 방문할 수 있다. 여기서 n은 격자의 세로 길이, m은 가로 길이이다.

---

## 코드
```python
from collections import deque

n, m = map(int, input().split())
grid = [list(map(int, input().strip())) for _ in range(n)]

visited = [[[0] * 2 for _ in range(m)] for _ in range(n)]
visited[0][0][0] = 1  

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]


def bfs():
    queue = deque()
    queue.append((0, 0, 0))  # (x좌표, y좌표, 벽을 부쉈는지 여부)

    while queue:
        x, y, w = queue.popleft()

        # 목표 지점에 도달한 경우
        if x == n - 1 and y == m - 1:
            return visited[x][y][w]

        # 상하좌우 이동
        for i in range(4):
            nx, ny = x + dx[i], y + dy[i]

            # 맵 범위 안에 있는지 확인
            if 0 <= nx < n and 0 <= ny < m:
                # 다음 이동할 곳이 벽이고, 벽을 부수지 않은 상태라면
                if grid[nx][ny] == 1 and w == 0:
                    visited[nx][ny][1] = visited[x][y][0] + 1
                    queue.append((nx, ny, 1))

                # 다음 이동할 곳이 벽이 아니고 아직 방문하지 않은 경우
                if grid[nx][ny] == 0 and visited[nx][ny][w] == 0:
                    visited[nx][ny][w] = visited[x][y][w] + 1
                    queue.append((nx, ny, w))

    return -1  # 목표 지점에 도달하지 못한 경우

print(bfs())
```