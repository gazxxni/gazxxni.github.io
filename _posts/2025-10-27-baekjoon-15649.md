---
layout: post
title: "[백준] 15649번 (Python)"
date: 2025-10-27
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "15649"]
---

## 문제 링크
[https://www.acmicpc.net/problem/15649](https://www.acmicpc.net/problem/15649)

---

## 풀이

### 풀이 핵심 로직
이 문제는 1부터 n까지의 숫자 중에서 m개의 숫자를 중복 없이 뽑아 나열하는 문제로, 깊이 우선 탐색(DFS) 기법을 사용하여 모든 조합을 생성한다. 재귀 함수를 통해 현재까지 선택한 숫자를 저장하고, 선택된 숫자가 m개가 되면 결과를 출력하며, 선택이 끝난 후에는 마지막에 선택한 숫자를 제거하여 다음 조합을 위한 준비를 한다.

### 동작 과정
1. 입력: n과 m이 주어진다. 예를 들어, n=3, m=2.
2. 초기 상태: `arr`는 빈 리스트로 시작한다.
3. 재귀 호출: `aa()` 함수가 호출되면, 현재 `arr`의 길이가 m과 같으면 이를 출력한다.
4. 반복문: 1부터 n까지의 숫자를 순회하며, 현재 숫자가 `arr`에 포함되지 않으면:
   - 숫자를 `arr`에 추가한다.
   - `aa()` 함수를 재귀 호출하여 다음 숫자를 선택한다.
   - 선택한 숫자를 `arr`에서 제거하여 다음 반복 시 다른 숫자를 선택할 수 있도록 한다.
5. 이 과정을 통해 모든 가능한 조합을 출력하게 된다.

예시 입력 (3 2)에 대하여:
- 처음 `aa()`가 호출되고, 1이 `arr`에 추가되면, 다음 호출에서 1은 제외되고 2가 추가되어 `[1, 2]`가 출력된다.
- 1, 3도 비슷한 방식으로 출력된다. 
- 다음으로 2가 처음 추가되면 1이 추가되어 `[2, 1]`, 3이 추가되어 `[2, 3]`가 출력된다.
- 마지막으로 3이 처음 추가되면 1, 2를 각각 추가하여 `[3, 1]`, `[3, 2]`가 출력된다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n^m)이다. 이는 n개의 숫자 중 m개를 선택하는 모든 조합을 생성하기 때문에, 최대 경우의 수는 n^m이 된다.

---

## 코드
```python
n, m = map(int, input().split())
arr = []

def aa():
    if len(arr) == m:
        print(*arr)
        return
    
    for i in range(1, n + 1):
        if i not in arr:
            arr.append(i)
            aa()
            arr.pop()
            
aa()
```