---
layout: post
title: "[백준] 2263번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2263"]
---

## 문제 링크
[https://www.acmicpc.net/problem/2263](https://www.acmicpc.net/problem/2263)

---

## 풀이

### 풀이 핵심 로직
이 문제는 이진 트리의 순회 방식 중 중위 순회(inorder)와 후위 순회(postorder)가 주어졌을 때, 전위 순회(preorder)를 구하는 문제입니다. 후위 순회의 마지막 원소가 루트 노드임을 이용하여, 중위 순회에서 이 루트 노드를 찾아 좌우 서브트리의 크기를 계산하고 이를 기반으로 재귀적으로 전위 순회를 수행합니다. 스택을 사용하여 이 과정을 반복적으로 진행합니다.

### 동작 과정
1. **입력 예시**: 
   - n = 5
   - inorder = [4, 2, 5, 1, 3]
   - postorder = [4, 5, 2, 3, 1]

2. **초기 스택**: 스택에 `(0, 4, 0, 4)`를 추가합니다. 이는 `inorder`의 전체 범위와 `postorder`의 전체 범위를 의미합니다.

3. **첫 번째 반복**:
   - 스택에서 `(0, 4, 0, 4)`를 꺼냅니다.
   - `postorder[4]` (즉, 1)이 루트 노드입니다. `ans`에 추가합니다.
   - 중위 순회에서 1의 인덱스를 찾습니다. `mid = 3`입니다.
   - 좌측 서브트리 크기 = `3 - 0 = 3`, 우측 서브트리 크기 = `4 - 3 = 1`.
   - 우측 서브트리 `(4, 4, 3, 3)`과 좌측 서브트리 `(0, 2, 0, 2)`를 스택에 추가합니다.

4. **두 번째 반복**:
   - 스택에서 `(0, 2, 0, 2)`를 꺼냅니다.
   - `postorder[2]` (즉, 2)가 루트입니다. `ans`에 추가합니다.
   - 중위 순회에서 2의 인덱스는 `1`입니다.
   - 좌측 서브트리 크기 = `1 - 0 = 1`, 우측 서브트리 크기 = `2 - 1 = 1`.
   - 좌측 서브트리 `(0, 0, 0, 0)`과 우측 서브트리 `(2, 2, 1, 1)`을 스택에 추가합니다.

5. **세 번째 반복**:
   - 스택에서 `(2, 2, 1, 1)`을 꺼냅니다.
   - `postorder[1]` (즉, 5)가 루트입니다. `ans`에 추가합니다.
   - 중위 순회에서 5의 인덱스는 `2`입니다. 좌측 서브트리 크기 = 0, 우측 서브트리 크기 = 0.
   - 추가할 서브트리가 없으므로 다음 반복으로 넘어갑니다.

6. **이 과정을 반복하여** 모든 노드를 전위 순서로 `ans`에 추가하게 됩니다**.

최종적으로 `ans`는 [1, 2, 5, 3, 4]가 되고 이를 출력합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n^2)입니다. 중위 순회에서 루트의 인덱스를 찾기 위해 `index()` 메서드를 사용하므로, 각 서브트리에 대해 최대 n번의 탐색이 필요할 수 있습니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
inorder = list(map(int, input().split()))
postorder = list(map(int, input().split()))

ans = []
stack = [(0, n - 1, 0, n - 1)]
while stack:
    inL, inR, postL, postR = stack.pop()
    if inL > inR:
        continue
    root = postorder[postR]
    ans.append(root)
    mid = inorder.index(root, inL, inR + 1)
    left_size = mid - inL
    right_size = inR - mid
    if right_size > 0:
        stack.append((mid + 1, inR, postL + left_size, postR - 1))
    if left_size > 0:
        stack.append((inL, mid - 1, postL, postL + left_size - 1))

print(*ans)

```