---
layout: post
title: "[백준] 13460번 (Python)"
date: 2025-09-17
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "13460"]
---

## 문제 링크
[https://www.acmicpc.net/problem/13460](https://www.acmicpc.net/problem/13460)

---

## 풀이

### 풀이 핵심 로직
이 문제는 빨간 공(R)과 파란 공(B)이 있는 그리드에서 빨간 공만 구멍(O)에 들어가도록 하는 최적의 이동 경로를 찾는 문제입니다. BFS(너비 우선 탐색)를 사용하여 각 공의 가능한 위치를 탐색하며, 파란 공이 구멍에 들어가지 않도록 하고, 최대 10번의 이동 내에 빨간 공이 구멍에 들어가면 성공으로 간주합니다.

### 동작 과정
1. **입력 받기**: 그리드의 크기(n, m)와 각 행의 문자열을 입력받습니다. 이 과정에서 빨간 공(R)과 파란 공(B)의 초기 위치를 저장합니다.
   
2. **BFS 초기화**: 큐에 초기 위치를 넣고, 방문한 상태를 기록하기 위한 리스트를 초기화합니다.

3. **BFS 실행**:
   - 큐에서 현재 공들의 위치를 꺼냅니다.
   - 이동 횟수가 10을 초과하면 탐색을 종료합니다.
   - 빨간 공이 구멍에 도착하면 현재 이동 횟수를 반환합니다.
   
4. **공 이동**:
   - 각 방향(상, 하, 좌, 우)으로 빨간 공과 파란 공을 이동시키고, 벽(#)에 부딪히면 이동을 멈춥니다.
   - 만약 파란 공이 구멍에 도착하면 해당 경로는 무효화합니다.
   - 두 공이 같은 위치에 있다면, 이동 거리를 비교하여 뒤쪽에 있던 공을 한 칸 뒤로 이동시킵니다.
   - 새로운 위치 조합이 방문한 적이 없다면 큐에 추가합니다.

5. **결과 출력**: BFS 탐색이 끝나면 결과를 출력합니다.

### 시간 복잡도
BFS는 각 상태를 최대 4 방향으로 탐색하므로, 최악의 경우 모든 가능한 상태를 탐색합니다. 상태의 수는 공의 위치에 따라 다르지만, 대략 O(N * M)에서 O(N * M * 4)로 추정할 수 있습니다. 따라서 전체 시간 복잡도는 O(N * M)입니다.

---

## 코드
```python
from collections import deque

n, m = map(int, input().split())
arr = []
for i in  range(n):
    arr.append(list(input()))
    for j in range(m):
        if arr[i][j] == 'R':
            rx, ry = i, j
        elif arr[i][j] == 'B': 
            bx, by = i, j
directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]


def bfs():
    q = deque()
    q.append((rx, ry, bx, by))
    visited = []
    visited.append((rx, ry, bx, by))
    cnt = 0
    result = -1
    
    while q:
        for _ in range(len(q)):
            rxx, ryy, bxx, byy = q.popleft()

            if cnt > 10:  # 횟수 초과
                return result
            
            if arr[rxx][ryy] == 'O':  # R이 구멍 만남
                return cnt
            
            for nx, ny in directions:
                nrx, nry = rxx, ryy
                
                while True:
                    nrx += nx
                    nry += ny
                    
                    if not (0 <= nrx < n and 0 <= nry < m):
                        break
                    
                    if arr[nrx][nry] == '#':  # 벽이면 하나 전으로
                        nrx -= nx
                        nry -= ny
                        break
                    
                    if arr[nrx][nry] == 'O':  # 구멍이면 탈출
                        break
                    
                nbx, nby = bxx, byy
                
                while True:
                    nbx += nx
                    nby += ny
                    
                    if not (0 <= nbx < n and 0 <= nby < m):
                        break
                    
                    if arr[nbx][nby] == '#':  # 벽이면 하나 전으로
                        nbx -= nx
                        nby -= ny
                        break
                    
                    if arr[nbx][nby] == 'O':  # 구멍이면 실패
                        break
                        
                if arr[nbx][nby] == 'O':  # 구멍이면 실패
                    continue
                
                if nrx == nbx and nry == nby:  # 둘이 같은 위치에 있으면
                    # R의 위치가 더 많이 움직이면 뒤에 있던 것
                    if abs(nrx - rxx) + abs(nry - ryy) > abs(nbx - bxx) + abs(nby - byy):
                        nrx -= nx
                        nry -= ny
                    else:
                        nbx -= nx
                        nby -= ny
                        
                if (nrx, nry, nbx, nby) not in visited:
                    q.append(((nrx, nry, nbx, nby)))
                    visited.append((nrx, nry, nbx, nby))
        cnt += 1
        
    return result

ans = bfs()
print(ans)
    
```