---
layout: post
title: "[백준] 10844번 (Python)"
date: 2025-10-29
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "10844"]
---

## 문제 링크
[https://www.acmicpc.net/problem/10844](https://www.acmicpc.net/problem/10844)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 자릿수 `n`의 계단 수를 구하는 문제로, 각 자릿수는 0에서 9까지의 숫자로 구성됩니다. 계단 수는 인접한 두 자리 수의 차가 1인 수를 의미합니다. 이를 위해 동적 프로그래밍(DP)을 사용하여 각 자릿수에서 가능한 계단 수의 개수를 저장하고, 이전 자릿수의 정보를 이용해 현재 자릿수의 계단 수를 계산합니다.

### 동작 과정
1. **입력**: `n`을 입력받습니다. 예를 들어, `n = 3`이라고 가정합니다.
2. **초기화**: `dp` 배열을 생성하여 `dp[1][2:11]`을 1로 초기화합니다. 이는 1자리 수 (2부터 9까지)로 시작할 수 있는 계단 수의 개수를 의미합니다. (0은 시작할 수 없고, 1은 계단 수가 될 수 없습니다.)
3. **DP 테이블 채우기**:
   - `i`가 2부터 `n`까지 반복합니다. 
   - 각 자릿수 `j` (1부터 9까지)에서, `dp[i][j]`는 `dp[i-1][j-1]` (이전 자릿수에서 왼쪽 숫자)와 `dp[i-1][j+1]` (이전 자릿수에서 오른쪽 숫자)의 합으로 정의됩니다. 이는 현재 자릿수 `j`에서 가능한 계단 수의 개수를 구하는 방법입니다.
4. **결과 계산**: 마지막으로 `dp[n]`의 모든 값을 더하여 `n`자리의 계단 수의 총 개수를 구하고, 1000000000으로 나눈 나머지를 출력합니다.

예시 입력 `n = 3`의 경우:
- `dp[1]`은 [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]입니다.
- `dp[2]`는 [0, 1, 1, 2, 2, 2, 2, 2, 1, 0, 0]입니다.
- `dp[3]`는 [0, 1, 2, 4, 4, 4, 4, 3, 0, 0, 0]입니다.
- 최종적으로 `dp[3]`의 합은 26입니다.

### 시간 복잡도
O(n) - n에 대해 DP 테이블을 채우기 위해 2중 반복문을 사용하였으나, 각 자릿수에 대해 10개의 숫자만 고려하므로 전체적으로 n에 비례하는 시간 복잡도를 가집니다.

---

## 코드
```python
n = int(input())

dp = [[0] * 12 for _ in range(n + 1)]
dp[1][2:11] = [1] * 9

for i in range(2, n + 1):
    for j in range(1, 11):
        dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]
        
ans = sum(dp[n])
print(ans % 1000000000)
```