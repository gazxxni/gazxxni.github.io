---
layout: post
title: "[백준] 2568번 (Python)"
date: 2025-09-25
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2568"]
---

## 문제 링크
[https://www.acmicpc.net/problem/2568](https://www.acmicpc.net/problem/2568)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 수열에서 가장 긴 증가하는 부분 수열(LIS)을 찾고, 이를 제외한 수열의 원소들을 출력하는 문제입니다. LIS를 찾기 위해 이진 탐색을 활용하여 효율적으로 수열의 길이를 구하고, 각 원소의 위치를 추적하여 최종적으로 제거해야 할 원소들을 확인합니다.

### 동작 과정
1. **입력 및 정렬**: 우선 `n`개의 원소를 입력받고, 각 원소를 `(a, b)`의 형태로 튜플에 저장한 후 `a`를 기준으로 정렬합니다. 이렇게 하면 `b`값의 순서를 유지하면서 `a`값을 정렬할 수 있습니다.

   예시 입력:
   ```
   5
   5 3
   1 2
   3 1
   4 5
   2 4
   ```
   정렬 후:
   ```
   [(1, 2), (2, 4), (3, 1), (4, 5), (5, 3)]
   ```

2. **LIS 계산**: `b`값들만 따로 추출하여 `brr` 리스트에 저장하고, 이 리스트에서 LIS를 찾습니다. `tails` 리스트는 현재까지 발견된 LIS의 마지막 원소들을 저장하고, `tails_pos` 리스트는 각 원소의 인덱스를 저장합니다. 이진 탐색을 통해 `b`값의 위치를 찾아가며 LIS를 업데이트합니다.

3. **원소 삭제 추적**: LIS의 길이를 계산한 후, `prev_idx` 배열을 사용하여 LIS에 포함된 원소들의 인덱스를 추적합니다. 마지막으로 `keep` 리스트를 통해 어떤 원소들이 LIS에 포함되는지를 저장합니다.

4. **결과 출력**: `keep` 리스트를 통해 LIS에 포함되지 않은 원소들을 찾아서 정렬한 후 출력합니다.

   예를 들어, 최종적으로 제거해야 할 원소는 `3`, `1`, `5`가 되며, 정렬 후 출력합니다:
   ```
   3
   5
   ```

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n log n)입니다. `n`개의 원소를 정렬하는 데 O(n log n) 시간이 소요되고, LIS를 찾는 과정에서도 이진 탐색을 사용하므로 O(n log n)의 시간 복잡도를 유지합니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
arr = []
for _ in range(n):
    a, b = map(int, input().split())
    arr.append((a, b))
arr.sort()
brr = []
for a, b in arr:
    brr.append(b)

tails = []
tails_pos = []

prev_idx = [-1] * n

def search(a, x):
    lo, hi = 0, len(a)
    while lo < hi:
        mid = (lo + hi) // 2
        if a[mid] < x:
            lo = mid + 1
        else:
            hi = mid
    return lo

for i, x in enumerate(brr):
    j = search(tails, x)

    prev_idx[i] = tails_pos[j - 1] if j > 0 else -1

    if j == len(tails): 
        tails.append(x)
        tails_pos.append(i)
    else:    
        tails[j] = x
        tails_pos[j] = i

lis_len = len(tails)
k = tails_pos[-1] if tails_pos else -1

keep = [False] * n
k = tails_pos[-1] if tails_pos else -1
while k != -1:
    keep[k] = True
    k = prev_idx[k]
    
ans = [arr[i][0] for i in range(n) if not keep[i]]
ans.sort()
        
print(n - lis_len)
for a in ans:
    print(a)
```