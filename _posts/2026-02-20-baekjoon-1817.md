---
layout: post
title: "[백준] 1817번 짐 챙기는 숌 (Python)"
date: 2026-02-20
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1817", 구현, 그리디 알고리즘, 시뮬레이션]
---

## 문제 링크
[https://www.acmicpc.net/problem/1817](https://www.acmicpc.net/problem/1817)

## 문제
숌은 짐을 챙겨서 겨울캠프에서 집으로 가려고 한다. 근데 숌은 공부를 많이 하러 캠프에 온 것이기 때문에 책을 엄청나게 많이 가지고 왔다. 숌은 이 책을 방에 탑처럼 쌓아 놨다.

숌은 책을 박스에 차곡차곡 넣어서 택배로 미리 보내려고 한다. 책은 탑처럼 차곡차곡 쌓여있기 때문에, 차례대로 박스에 넣을 수밖에 없다.

각각의 책은 무게가 있다. 그리고 박스는 최대 넣을수 있는 무게가 있다. 숌이 필요한 박스의 개수의 최솟값을 구하는 프로그램을 작성하시오.

## 입력
첫째 줄에 책의 개수 N과 박스에 넣을 수 있는 최대 무게 M이 주어진다. N은 0보다 크거나 같고 50보다 작거나 같은 정수이고, M은 1,000보다 작거나 같은 자연수이다. N이 0보다 큰 경우 둘째 줄에 책의 무게가 공백을 사이에 두고 주어진다. 책의 무게는 M보다 작거나 같은 자연수이다.

## 출력
첫째 줄에 필요한 박스의 개수의 최솟값을 출력한다.

## 풀이
### 풀이 핵심 로직
문제의 핵심은 각 책을 차례대로 박스에 넣는 것이며, 한 박스에 최대 무게 `M`을 초과하지 않도록 책들을 배치하는 것이다. 이를 위해 현재 박스에 책을 추가할 때 무게가 `M`을 초과하지 않으면 책을 추가하고, 초과할 경우 새로운 박스를 사용하도록 카운트를 증가시킨다.

### 동작 과정
예시 입력: 
```
5 10
6 3 4 5 2
```

1. 책의 개수 `N`은 5, 박스의 최대 무게 `M`은 10으로 주어진다.
2. 책의 무게는 `[6, 3, 4, 5, 2]`이다.
3. 초기 상태에서 `weight`는 0, `count`는 1 (첫 번째 박스를 사용하기 위해)로 설정한다.
4. 첫 번째 책의 무게 6을 박스에 넣는다. 현재 `weight`는 6이다.
5. 두 번째 책의 무게 3을 추가하였을 때, `weight`는 9로, 여전히 최대 무게 `M`인 10을 초과하지 않는다.
6. 세 번째 책의 무게 4를 추가하려고 하면, `weight`는 13이 되어 초과하므로 새로운 박스를 사용하고 `count`를 2로 증가시킨다. 현재 `weight`는 4 (세 번째 책의 무게)로 초기화된다.
7. 네 번째 책의 무게 5를 추가하려고 하면, `weight`는 9가 된다.
8. 마지막으로 다섯 번째 책의 무게 2를 추가하려고 하면, `weight`는 11이 되어 초과하므로 또 다시 박스를 사용하고 `count`를 3으로 증가시킨다.
9. 모든 책을 처리한 후, 필요한 박스의 총 개수는 3이 된다.

최종 출력은 `3`이 된다.

### 시간 복잡도
주어진 코드는 책의 개수 `N`에 대해 한 번의 반복문을 돌며 책의 무게를 체크하므로, 시간 복잡도는 O(N)이다.

## 코드
```python
n,m=map(int,input().split())
count = 0
if n == 0 : print(0)
else : 
    boxes = list(map(int,input().split()))
    weight = 0
    count = 1 
    for box in boxes:   
        if box+weight <= m : 
            weight += box
        else : 
            weight = box 
            count +=1
    print(count)
    
```