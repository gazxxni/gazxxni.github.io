---
layout: post
title: "[백준] 16928번 (Python)"
date: 2024-11-23
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "16928"]
---

## 문제 링크
[https://www.acmicpc.net/problem/16928](https://www.acmicpc.net/problem/16928)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주사위를 굴려 1부터 100까지 이동하며 사다리와 뱀의 영향을 고려하여 최소 주사위 횟수를 계산하는 문제입니다. BFS(너비 우선 탐색)를 사용하여 각 위치에서 가능한 모든 이동을 탐색하며, 최종 목표인 100번 칸에 도달하는 최소 주사위 횟수를 구합니다.

### 동작 과정
1. **입력 처리**: 먼저 사다리와 뱀의 정보를 입력받아 각각의 딕셔너리에 저장합니다.
   - 예를 들어, 사다리가 3에서 22로 연결되고, 뱀이 17에서 4로 연결된 경우, 각각 `a[3] = 22` 및 `b[17] = 4`로 저장됩니다.

2. **BFS 초기화**: BFS를 위해 큐(deque)를 초기화하고 시작 위치(1번 칸)를 큐에 추가합니다. 방문 여부를 체크할 리스트와 주사위 횟수를 저장할 리스트를 초기화합니다.

3. **BFS 탐색**: 큐에서 현재 위치를 꺼내고, 1부터 6까지의 주사위 눈금에 대해 다음 위치를 계산합니다.
   - 예를 들어, 현재 위치가 1이라면, 다음 위치는 2, 3, 4, 5, 6, 7이 됩니다.
   - 계산된 `next` 위치가 사다리 또는 뱀에 해당하는 경우, 해당 위치로 이동합니다.

4. **방문 체크 및 큐 업데이트**: 이동한 위치가 방문하지 않은 경우, 해당 위치를 큐에 추가하고 방문 여부를 체크합니다. 또한 현재 위치에서의 주사위 횟수 + 1로 다음 위치의 주사위 횟수를 업데이트합니다.

5. **종료**: BFS가 완료되면 100번 칸에 도달하기 위한 최소 주사위 횟수를 출력합니다.

예시 입력:
```
3 2
3 22
5 8
17 4
```
이 경우, BFS를 통해 주사위를 굴려 1번 칸에서 시작하여 최종적으로 100번 칸에 도달하는 최소 주사위 횟수를 계산하게 됩니다.

### 시간 복잡도
BFS를 사용하여 각 위치에서 최대 6개의 이동을 탐색하므로, 시간 복잡도는 O(V + E)입니다. 여기서 V는 100개의 칸(1~100), E는 각 칸에서 가능한 이동(주사위 눈금 1~6)으로 최대 600개의 간선으로 볼 수 있어, 최종적으로 O(1)로 간주할 수 있습니다. 따라서 전체 시간 복잡도는 O(1)입니다.

---

## 코드
```python
from collections import deque 

n, m = map(int, input().split())

board = [0] * 101  # 최소 주사위 횟수를 기록
visited = [False] * 101 

a = dict()  # 사다리 정보 저장
for _ in range(n):
    x, y = map(int, input().split())
    a[x] = y 

b = dict()  # 뱀 정보 저장
for _ in range(m):
    u, v = map(int, input().split())
    b[u] = v 


def bfs(s):
    q = deque() 
    q.append(s) 
    visited[s] = True 

    while q: 
        t = q.popleft()  
        
        for i in range(1, 7):  # 주사위로 1부터 6까지 이동
            next = t + i  # 다음 위치 계산
            
            # 다음 위치가 게임판 범위 안이고 방문하지 않은 경우
            if 0 < next <= 100 and not visited[next]:
                
                if next in a:  # 사다리가 있으면 올라감
                    next = a[next]

                
                if next in b:  # 뱀이 있으면 내려감
                    next = b[next]

                # 최종 위치를 아직 방문하지 않았다면 큐에 추가
                if not visited[next]:
                    q.append(next)
                    visited[next] = True 
                    board[next] = board[t] + 1  # 최소 주사위 횟수 기록

bfs(1)
print(board[100])

```