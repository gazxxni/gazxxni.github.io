---
layout: post
title: "[백준] 1524번 세준세비 (Python)"
date: 2026-01-23
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1524", 구현, 정렬]
---

## 문제 링크
[https://www.acmicpc.net/problem/1524](https://www.acmicpc.net/problem/1524)

---

## 문제
세준이와 세비는 온라인 게임을 즐겨한다. 이 온라인 게임에서는 군대를 서로 키울 수 있다. 세준이는 N명의 병사를 키웠고, 세비는 M명의 병사를 키웠다.

이제 서로 전쟁을 하려고 한다.

전쟁은 여러 번의 전투로 이루어진다. 각 전투에서 살아있는 병사중 제일 약한 병사가 죽는다. 만약 제일 약한 병사가 여러 명이고, 제일 약한 병사가 모두 같은 편에 있다면, 그 중에 한 명이 임의로 선택되어 죽는다. 하지만, 제일 약한 병사가 여러 명이고, 양 편에 모두 있다면, 세비의 제일 약한 병사 중 한 명이 임의로 선택되어 죽는다.

전쟁은 한 명의 병사를 제외하고 모두 죽었을 때 끝난다. 전쟁의 승자를 출력하는 프로그램을 작성하시오.

---

## 입력
첫째 줄에 테스트 케이스의 개수 T가 주어진다. T는 100보다 작거나 같다. 각 테스트 케이스는 다음과 같이 이루어져 있다. 첫째 줄에 N과 M이 들어오고, 둘째 줄에는 세준이의 병사들의 힘이 들어오고, 셋째 줄에는 세비의 병사들의 힘이 들어온다. 힘은 정수이고, 이 값이 클수록 강하고, 작을수록 약하다.

각 테스트 케이스는 줄 바꿈으로 구분되어 있다.

---

## 출력
각 테스트 케이스에 대해서 한 줄에 하나씩 차례대로 승자를 출력한다. 세준이가 이기면 S를 세비가 이기면 B를 둘다 아닐 경우에는 C를 출력한다.

---

## 성능 요약
메모리: 139896 KB, 시간: 1660 ms

---

## 풀이

### 풀이 핵심 로직
전투는 양측의 가장 약한 병사들(힘이 가장 낮은 병사들) 간의 비교로 이루어집니다. 각 전투에서 세준이의 가장 약한 병사와 세비의 가장 약한 병사를 비교하여, 더 약한 병사가 제거됩니다. 이 과정을 반복하여 한 측의 병사가 모두 제거되면 전쟁이 종료되며, 승자를 결정합니다.

### 동작 과정
1. 입력 예시:
   ```
   1
   3 3
   1 3 5
   2 4 6
   ```
   - 테스트 케이스 수: 1
   - N(세준 병사 수): 3, M(세비 병사 수): 3
   - 세준의 병사 힘: [1, 3, 5]
   - 세비의 병사 힘: [2, 4, 6]
   
2. 세준과 세비의 병사 힘 리스트를 각각 정렬합니다:
   - 세준: [1, 3, 5]
   - 세비: [2, 4, 6]

3. 전투 시작:
   - 첫 전투: 세준의 병사 1(1) vs 세비의 병사 2(2) → 세준의 병사 1이 죽고 세비의 병사 2가 살아남는다.
   - 리스트 상태: 세준: [3, 5], 세비: [2, 4, 6]
   
   - 두 번째 전투: 세준의 병사 3(3) vs 세비의 병사 2(2) → 세비의 병사 2가 죽는다.
   - 리스트 상태: 세준: [3, 5], 세비: [4, 6]
   
   - 세 번째 전투: 세준의 병사 3(3) vs 세비의 병사 4(4) → 세준의 병사 3이 죽는다.
   - 리스트 상태: 세준: [5], 세비: [4, 6]
   
   - 네 번째 전투: 세준의 병사 5(5) vs 세비의 병사 4(4) → 세비의 병사 4가 죽는다.
   - 리스트 상태: 세준: [5], 세비: [6]
   
   - 마지막 전투: 세준의 병사 5(5) vs 세비의 병사 6(6) → 세준의 병사 5가 죽는다.
   - 리스트 상태: 세준: [], 세비: [6]

4. 전쟁 종료: 세준의 병사가 모두 죽었으므로 세비가 승리. 출력: 'B'

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(N log N + M log M + min(N, M))입니다. 여기서 N과 M은 각각 세준과 세비의 병사 수입니다. 정렬에 O(N log N)과 O(M log M)이 소요되고, 전투 과정에서는 최대 min(N, M) 번 비교가 이루어지기 때문입니다.

---

## 코드
```python
t = int(input())

for i in range(t):
    input()
    n, m = map(int, input().split())
    arr = list(map(int, input().split()))
    brr = list(map(int, input().split()))
    
    arr.sort()
    brr.sort()
    
    while arr and brr :	
        if arr[0] >= brr[0] :	
            brr.pop(0)
        else :
            arr.pop(0)

    if arr :
        print('S')
    elif brr :
        print('B')
    else :
        print('C')
```