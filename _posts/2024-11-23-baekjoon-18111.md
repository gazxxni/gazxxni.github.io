---
layout: post
title: "[백준] 18111번 (Python)"
date: 2024-11-23
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "18111"]
---

## 문제 링크
[https://www.acmicpc.net/problem/18111](https://www.acmicpc.net/problem/18111)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 주어진 2차원 배열에서 블록의 높이를 조정하여 목표 높이를 만드는 데 필요한 시간을 계산하는 것이다. 각 높이에 대해 블록을 추가하거나 제거하는 데 드는 시간을 비교하여, 최소 시간과 그때의 목표 높이를 찾는다.

### 동작 과정
1. **입력 처리**: 먼저, 입력으로 주어진 n, m, b(각각 행, 열, 초기 블록 수)를 읽고, 2차원 배열을 생성한다.
   - 예시 입력: 
     ```
     3 4 1
     1 2 3 4
     1 2 3 4
     1 2 3 4
     ```
   - 이 경우, 2차원 배열은 다음과 같다:
     ```
     arr = [
         [1, 2, 3, 4],
         [1, 2, 3, 4],
         [1, 2, 3, 4]
     ]
     ```

2. **블록 수 계산**: 2차원 배열을 1차원으로 변환하고, 각 높이에 대한 블록의 수를 `Counter`를 사용하여 계산한다.
   - 결과: 
     ```
     block_count = {1: 6, 2: 6, 3: 6, 4: 3}
     ```

3. **최소/최대 높이 결정**: 블록의 최소 높이와 최대 높이를 구한다.
   - `min_height = 1`, `max_height = 4`

4. **목표 높이에 대한 시간 계산**: 목표 높이를 `min_height`에서 `max_height`까지 반복하면서 각 높이에 대해 필요한 시간을 계산한다.
   - 예를 들어, `target_height = 2`일 때:
     - 높이가 1인 블록 6개를 추가해야 하므로 추가 시간: `6 * 1 = 6초`
     - 높이가 3인 블록 6개를 제거해야 하므로 제거 시간: `6 * 2 = 12초`
     - 총 시간: `6 + 12 = 18초`, 인벤토리 상태: `b - 6 + 6 = 1` (충분함)

5. **최소 시간 및 목표 높이 업데이트**: 각 반복에서 시간이 최소인 경우와 같은 시간이면서 더 높은 목표 높이일 경우 업데이트 한다.

6. **결과 출력**: 최종적으로 최소 시간과 해당 높이를 출력한다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n * m + h), 여기서 n은 행의 수, m은 열의 수, h는 높이의 범위(최대 높이 - 최소 높이)이다. `Counter`로 블록 수를 계산하는 데 O(n * m)이 소요되고, 각 높이에 대해 블록을 처리하는 데 O(h)이 소요되기 때문이다.

---

## 코드
```python
import sys
from collections import Counter

n, m, b = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(n)]

# 2차원 배열을 1차원으로 변환 후 각 높이별 블록 수 계산
flattened_blocks = [block for row in arr for block in row]
block_count = Counter(flattened_blocks)

# 2차원 배열의 최소 높이와 최대 높이 구하기
min_height = min(block_count)
max_height = max(block_count)

# 결과 저장할 변수 (최소 시간, 목표 높이)
best_time = float('inf')
best_height = -1

# 각 목표 높이별로 블록 추가/제거 계산
for target_height in range(min_height, max_height + 1):
    time = 0
    inventory = b

    # 높이별로 블록을 추가하거나 제거하는데 걸리는 시간 계산
    for height, count in block_count.items():  # height: 현재 블록의 높이, count: 해당 높이의 블록 개수
        if height > target_height:  # 블록을 제거해야 하는 경우
            time += (height - target_height) * 2 * count  # 제거는 2초
            inventory += (height - target_height) * count  # 제거된 블록 수 추가
        elif height < target_height:  # 블록을 추가해야 하는 경우
            time += (target_height - height) * count  # 추가는 1초
            inventory -= (target_height - height) * count  # 인벤토리에서 블록 감소

    # 블록 인벤토리가 충분한 경우에만 결과 업데이트
    if inventory >= 0:
        # 최소 시간을 업데이트하되, 시간이 같다면 더 높은 높이를 선택
        if time < best_time or (time == best_time and target_height > best_height):
            best_time = time
            best_height = target_height

# 결과 출력
print(best_time, best_height)

```