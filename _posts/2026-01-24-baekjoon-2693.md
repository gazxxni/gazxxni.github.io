---
layout: post
title: "[백준] 2693번 N번째 큰 수 (Python)"
date: 2026-01-24
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2693", 정렬]
---

## 문제 링크
[https://www.acmicpc.net/problem/2693](https://www.acmicpc.net/problem/2693)

---

## 문제
배열 A가 주어졌을 때, N번째 큰 값을 출력하는 프로그램을 작성하시오.

배열 A의 크기는 항상 10이고, 자연수만 가지고 있다. N은 항상 3이다.

---

## 입력
첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 배열 A의 원소 10개가 공백으로 구분되어 주어진다. 이 원소는 1보다 크거나 같고, 1,000보다 작거나 같은 자연수이다.

---

## 출력
각 테스트 케이스에 대해 한 줄에 하나씩 배열 A에서 3번째 큰 값을 출력한다.

---

## 성능 요약
메모리: 110708 KB, 시간: 148 ms

---

## 풀이

### 풀이 핵심 로직
주어진 배열 A에서 3번째로 큰 값을 찾기 위해, 배열을 정렬한 후 인덱스를 이용하여 3번째 큰 수에 접근합니다. 배열의 크기가 항상 10이므로 정렬된 배열의 3번째 큰 값은 항상 `arr[-3]`로 접근할 수 있습니다.

### 동작 과정
1. 첫째 줄에 테스트 케이스의 개수 T가 주어집니다.
2. 각 테스트 케이스마다 10개의 자연수가 공백으로 구분되어 입력됩니다.
3. 배열 A를 정렬한 후, 3번째로 큰 값을 찾기 위해 정렬된 배열의 마지막에서 세 번째 요소를 출력합니다.

예시 입력:
```
2
1 2 3 4 5 6 7 8 9 10
10 9 8 7 6 5 4 3 2 1
```
- 첫 번째 테스트 케이스: 배열은 `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`로 정렬되며, 3번째 큰 수는 `8`입니다.
- 두 번째 테스트 케이스: 배열은 `[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]`로 정렬되며, 3번째 큰 수는 `8`입니다.
- 출력 결과는:
```
8
8
```

### 시간 복잡도
정렬의 시간 복잡도는 O(n log n)입니다. 여기서 n은 배열의 크기로 항상 10이므로, 실제 시간 복잡도는 O(10 log 10)로 상수 시간에 가까워집니다. 따라서 전체 알고리즘의 시간 복잡도는 O(T)입니다.

---

## 코드
```python
t = int(input())

for _ in range(t):
    arr = list(map(int, input().split()))
    arr.sort()
    
    print(arr[-3])
```