---
layout: post
title: "[백준] 9328번 열쇠 (Python)"
date: 2025-10-23
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "9328", 구현, 그래프 이론, 그래프 탐색, 너비 우선 탐색, 격자 그래프]
---

## 문제 링크
[https://www.acmicpc.net/problem/9328](https://www.acmicpc.net/problem/9328)

---

## 문제
상근이는 1층 빌딩에 침입해 매우 중요한 문서를 훔쳐오려고 한다. 상근이가 가지고 있는 평면도에는 문서의 위치가 모두 나타나 있다. 빌딩의 문은 모두 잠겨있기 때문에, 문을 열려면 열쇠가 필요하다. 상근이는 일부 열쇠를 이미 가지고 있고, 일부 열쇠는 빌딩의 바닥에 놓여져 있다. 상근이는 상하좌우로만 이동할 수 있다.

상근이가 훔칠 수 있는 문서의 최대 개수를 구하는 프로그램을 작성하시오.

---

## 입력
첫째 줄에 테스트 케이스의 개수가 주어진다. 테스트 케이스의 수는 100개를 넘지 않는다.

각 테스트 케이스의 첫째 줄에는 지도의 높이와 너비 h와 w (2 ≤ h, w ≤ 100)가 주어진다. 다음 h개 줄에는 빌딩을 나타내는 w개의 문자가 주어지며, 각 문자는 다음 중 하나이다.


	'.'는 빈 공간을 나타낸다.
	'*'는 벽을 나타내며, 상근이는 벽을 통과할 수 없다.
	'$'는 상근이가 훔쳐야하는 문서이다.
	알파벳 대문자는 문을 나타낸다.
	알파벳 소문자는 열쇠를 나타내며, 그 문자의 대문자인 모든 문을 열 수 있다.


마지막 줄에는 상근이가 이미 가지고 있는 열쇠가 공백없이 주어진다. 만약, 열쇠를 하나도 가지고 있지 않는 경우에는 "0"이 주어진다.

상근이는 처음에는 빌딩의 밖에 있으며, 빌딩 가장자리의 벽이 아닌 곳을 통해 빌딩 안팎을 드나들 수 있다. 각각의 문에 대해서, 그 문을 열 수 있는 열쇠의 개수는 0개, 1개, 또는 그 이상이고, 각각의 열쇠에 대해서, 그 열쇠로 열 수 있는 문의 개수도 0개, 1개, 또는 그 이상이다. 열쇠는 여러 번 사용할 수 있다.

---

## 출력
각 테스트 케이스 마다, 상근이가 훔칠 수 있는 문서의 최대 개수를 출력한다.

---

## 성능 요약
메모리: 117908 KB, 시간: 200 ms

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 BFS(너비 우선 탐색)를 사용하여 상근이가 열쇠를 통해 문을 통과하고 문서에 접근할 수 있는지를 탐색하는 것입니다. 상근이는 처음에 외부에서 시작하며, 가지고 있는 열쇠로 열 수 있는 문을 통과하고, 새로 발견한 열쇠로 잠긴 문을 다시 열 수 있습니다. 이 과정을 반복하여 최대한 많은 문서를 수집합니다.

### 동작 과정
1. **입력 처리**: 여러 테스트 케이스를 처리하기 위해 입력을 받고, 각 케이스마다 빌딩의 구조를 2D 리스트로 저장합니다. 빌딩의 외곽에 벽이 아닌 '.'을 추가하여 외부에서 시작하는 것을 단순화합니다.

2. **BFS 초기화**: BFS를 위한 큐를 초기화하고, 상근이가 처음 가지고 있는 열쇠를 세트로 변환하여 관리합니다. 방문한 위치를 추적하기 위해 `visited` 집합을 사용합니다.

3. **BFS 탐색**:
   - 큐에서 현재 위치를 꺼내고 상하좌우로 이동합니다.
   - 이동할 수 있는 위치가 벽이 아닌 경우:
     - 빈 공간(`.`)인 경우: 방문 표시 후 큐에 추가합니다.
     - 문(`A-Z`)인 경우: 현재 가지고 있는 열쇠로 열 수 있다면 방문하고 큐에 추가합니다. 열 수 없다면 해당 문을 `waiting_doors`에 저장합니다.
     - 열쇠(`a-z`)인 경우: 방문하고 큐에 추가한 후, 새로 발견한 열쇠로 열 수 있는 모든 문을 다시 큐에 추가합니다.
     - 문서(`$`)인 경우: 문서 수를 증가시키고 방문 후 공간으로 변경하여 중복 카운트를 방지합니다.

4. **결과 출력**: BFS가 완료된 후, 각 테스트 케이스별로 수집한 문서의 수를 출력합니다.

예를 들어, 다음과 같은 입력이 주어질 때:
```
1
3 5
..$..
*.*.*
..K..
a
```
- 상근이는 외부에서 시작하여 문서(`$`)에 접근할 수 있습니다.
- 열쇠(`a`)를 통해 문을 열 수 있는 경로를 따라 문서 수를 증가시키며, 최종적으로 문서 1개를 수집합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(H * W)입니다. 여기서 H는 빌딩의 높이, W는 빌딩의 너비입니다. BFS는 각 위치를 한 번씩 방문하므로 전체 탐색에 소요되는 시간은 빌딩의 전체 크기와 비례합니다.

---

## 코드
```python
import sys
from collections import deque

input = sys.stdin.readline
direction = [(0, 1), (1, 0), (0, -1), (-1, 0)]

def bfs(x, y, h, w, graph, key):
    visited = set()
    visited.add((x, y))
    q = deque()
    q.append((x, y))
    
    keys = set(key)
    cnt = 0
    waiting_doors = {}  # 열쇠 없는 문을 저장해두고 열쇠 발견시 다시 탐색

    while q:
        cx, cy = q.popleft()
        
        for xx, yy in direction:
            nx = cx + xx
            ny = cy + yy
            
            if 0 <= nx < w and 0 <= ny < h:
                if (nx, ny) not in visited:
                    word = graph[ny][nx]
                    
                    if word != '*':
                        if word == '.':
                            visited.add((nx, ny))
                            q.append((nx, ny))
                            
                        elif word.isupper():
                            if word.lower() in keys:
                                visited.add((nx, ny))
                                q.append((nx, ny))
                            else:
                                if word not in waiting_doors:
                                    waiting_doors[word] = []
                                waiting_doors[word].append((nx, ny))
                                
                        elif word.islower():
                            visited.add((nx, ny))
                            q.append((nx, ny))
                            if word not in keys:
                                keys.add(word)
                                door = word.upper()
                                if door in waiting_doors:
                                    for (door_x, door_y) in waiting_doors[door]:
                                        if (door_x, door_y) not in visited:
                                            visited.add((door_x, door_y))
                                            q.append((door_x, door_y))
                                    del waiting_doors[door]
                            
                        elif word == '$':
                            cnt += 1
                            visited.add((nx, ny))
                            q.append((nx, ny))
                            # 문서를 훔친 곳은 빈 공간으로 처리 (중복 카운트 방지)
                            graph[ny][nx] = '.' 
                            
    return cnt

t = int(input())
for _ in range(t):
    h, w = map(int, input().split())
    
    # 맵 가장자리에 '.'을 추가하여 빌딩 밖에서 시작하는 로직을 단순화
    graph = [['.' for _ in range(w + 2)] for _ in range(h + 2)]
    for i in range(h):
        line = list(input().rstrip())
        for j in range(w):
            graph[i + 1][j + 1] = line[j]

    h += 2
    w += 2

    key = list(input().rstrip())

    ans = bfs(0, 0, h, w, graph, key)
        
    print(ans)
```