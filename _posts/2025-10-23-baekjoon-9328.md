---
layout: post
title: "[백준] 9328번 (Python)"
date: 2025-10-23
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "9328"]
---

## 문제 링크
[https://www.acmicpc.net/problem/9328](https://www.acmicpc.net/problem/9328)

---

## 풀이

### 풀이 핵심 로직
주어진 문제는 열쇠를 사용하여 문서(‘$’)를 수집하는 문제로, BFS(너비 우선 탐색) 알고리즘을 이용하여 맵을 탐색합니다. 각 위치에서 열쇠와 문을 확인하며, 열쇠를 발견하면 해당 열쇠로 열 수 있는 문을 재탐색하여 문서 수를 최대화하는 방식으로 동작합니다.

### 동작 과정
1. **초기 설정**: 입력을 받아서 맵의 크기와 내용을 설정하고, 가장자리에 빈 공간(`'.'`)을 추가하여 탐색의 편리성을 높입니다. 시작점은 (0, 0)으로 설정합니다.

2. **BFS 탐색 시작**: BFS를 통해 (0, 0)에서 시작하여 인접한 칸을 탐색합니다. 탐색하는 동안 다음과 같은 경우를 처리합니다:
   - `'.'`: 방문하고 큐에 추가합니다.
   - `'$'`: 문서 수를 증가시키고, 해당 칸을 빈 공간으로 처리하여 중복 카운트를 방지합니다.
   - 대문자(문): 현재 열쇠가 있는 경우 방문하고 큐에 추가합니다. 그렇지 않으면 대기 리스트에 저장합니다.
   - 소문자(열쇠): 방문하고 큐에 추가하며, 새로운 열쇠를 발견하면 해당 열쇠로 열 수 있는 문을 대기 리스트에서 큐에 추가합니다.

3. **결과 출력**: 모든 탐색이 끝난 후 수집한 문서의 수를 출력합니다.

#### 예시 입력으로 단계별 설명
- 입력: 
```
1
3 3
*.* 
.*$ 
*.* 
a
```
- 초기 맵은 다음과 같고, 시작점은 (0, 0)입니다.
```
. . . . .
. * . * .
. * $ . .
. * . * .
. . . . .
```
- BFS 탐색을 시작하여 (0, 0)에서 (1, 0)으로 이동, (1, 1)은 문(`'*'`)이므로 방문할 수 없습니다.
- (0, 1)로 이동 후 (1, 1)로 이동, (1, 2)에서 문서(`'$'`)를 발견하여 수를 증가시키고, (1, 1)에서 문을 열 수 있는 열쇠(`'a'`)를 찾습니다.
- 최종적으로 1개의 문서를 수집한 결과를 출력합니다.

### 시간 복잡도
BFS 탐색은 모든 칸을 한 번씩 방문하므로 시간 복잡도는 \(O(H \times W)\)입니다. 여기서 \(H\)는 맵의 높이, \(W\)는 맵의 너비입니다.

---

## 코드
```python
import sys
from collections import deque

input = sys.stdin.readline
direction = [(0, 1), (1, 0), (0, -1), (-1, 0)]

def bfs(x, y, h, w, graph, key):
    visited = set()
    visited.add((x, y))
    q = deque()
    q.append((x, y))
    
    keys = set(key)
    cnt = 0
    waiting_doors = {}  # 열쇠 없는 문을 저장해두고 열쇠 발견시 다시 탐색

    while q:
        cx, cy = q.popleft()
        
        for xx, yy in direction:
            nx = cx + xx
            ny = cy + yy
            
            if 0 <= nx < w and 0 <= ny < h:
                if (nx, ny) not in visited:
                    word = graph[ny][nx]
                    
                    if word != '*':
                        if word == '.':
                            visited.add((nx, ny))
                            q.append((nx, ny))
                            
                        elif word.isupper():
                            if word.lower() in keys:
                                visited.add((nx, ny))
                                q.append((nx, ny))
                            else:
                                if word not in waiting_doors:
                                    waiting_doors[word] = []
                                waiting_doors[word].append((nx, ny))
                                
                        elif word.islower():
                            visited.add((nx, ny))
                            q.append((nx, ny))
                            if word not in keys:
                                keys.add(word)
                                door = word.upper()
                                if door in waiting_doors:
                                    for (door_x, door_y) in waiting_doors[door]:
                                        if (door_x, door_y) not in visited:
                                            visited.add((door_x, door_y))
                                            q.append((door_x, door_y))
                                    del waiting_doors[door]
                            
                        elif word == '$':
                            cnt += 1
                            visited.add((nx, ny))
                            q.append((nx, ny))
                            # 문서를 훔친 곳은 빈 공간으로 처리 (중복 카운트 방지)
                            graph[ny][nx] = '.' 
                            
    return cnt

t = int(input())
for _ in range(t):
    h, w = map(int, input().split())
    
    # 맵 가장자리에 '.'을 추가하여 빌딩 밖에서 시작하는 로직을 단순화
    graph = [['.' for _ in range(w + 2)] for _ in range(h + 2)]
    for i in range(h):
        line = list(input().rstrip())
        for j in range(w):
            graph[i + 1][j + 1] = line[j]

    h += 2
    w += 2

    key = list(input().rstrip())

    ans = bfs(0, 0, h, w, graph, key)
        
    print(ans)
```