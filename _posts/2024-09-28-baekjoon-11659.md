---
layout: post
title: "[백준] 11659번 (Python)"
date: 2024-09-28
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "11659"]
---

## 문제 링크
[https://www.acmicpc.net/problem/11659](https://www.acmicpc.net/problem/11659)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 배열의 특정 구간의 합을 빠르게 구하기 위해 누적 합(prefix sum) 배열을 사용한다. 누적 합 배열을 통해 배열의 특정 구간 합을 O(1) 시간에 계산할 수 있어, 여러 쿼리를 효율적으로 처리할 수 있다.

### 동작 과정
1. **입력 처리**: 첫째 줄에서 `n`(배열 크기)과 `m`(쿼리 수)를 입력 받고, 둘째 줄에서 `n`개의 정수를 배열로 읽어온다.
   - 예시: `n = 5, m = 3` 및 `arr = [1, 2, 3, 4, 5]`

2. **누적 합 배열 생성**: 누적 합 배열 `prefix_sum`을 생성한다. 배열의 크기는 `n + 1`이고, `prefix_sum[i]`는 `arr`의 첫 `i`개 요소의 합을 저장한다.
   - `prefix_sum[0] = 0`
   - `prefix_sum[1] = 1` (1)
   - `prefix_sum[2] = 3` (1 + 2)
   - `prefix_sum[3] = 6` (1 + 2 + 3)
   - `prefix_sum[4] = 10` (1 + 2 + 3 + 4)
   - `prefix_sum[5] = 15` (1 + 2 + 3 + 4 + 5)

3. **쿼리 처리**: 각 쿼리에 대해 `a`와 `b`를 입력 받고, 구간 `[a, b]`의 합을 `prefix_sum[b] - prefix_sum[a-1]`으로 계산하여 출력한다.
   - 예시 쿼리: `1 3`의 경우, `prefix_sum[3] - prefix_sum[0] = 6 - 0 = 6`
   - 또 다른 예시 쿼리: `2 4`의 경우, `prefix_sum[4] - prefix_sum[1] = 10 - 1 = 9`

### 시간 복잡도
- 누적 합 배열 생성: O(n)
- 각 쿼리 처리: O(1) (총 m개의 쿼리 처리 시 O(m))
  
따라서 전체 시간 복잡도는 O(n + m)이다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n, m = map(int, input().split())
arr = list(map(int, input().split()))

# 누적 합 배열 생성
prefix_sum = [0] * (n + 1)
for i in range(1, n + 1):
    prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1]

for _ in range(m):
    a, b = map(int, input().split())
    # a-1부터 b-1까지의 합은 prefix_sum[b] - prefix_sum[a-1]
    ans = prefix_sum[b] - prefix_sum[a - 1]
    print(ans)


```