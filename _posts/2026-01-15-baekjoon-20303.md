---
layout: post
title: "[백준] 20303번 할로윈의 양아치 (Python)"
date: 2026-01-15
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "20303", 다이나믹 프로그래밍, 그래프 이론, 자료 구조, 그래프 탐색, 분리 집합, 배낭 문제]
---

## 문제 링크
[https://www.acmicpc.net/problem/20303](https://www.acmicpc.net/problem/20303)

---

## 문제
Trick or Treat!!

10월 31일 할로윈의 밤에는 거리의 여기저기서 아이들이 친구들과 모여 사탕을 받기 위해 돌아다닌다. 올해 할로윈에도 어김없이 많은 아이가 할로윈을 즐겼지만 단 한 사람, 일찍부터 잠에 빠진 스브러스는 할로윈 밤을 즐길 수가 없었다. 뒤늦게 일어나 사탕을 얻기 위해 혼자 돌아다녀 보지만 이미 사탕은 바닥나 하나도 얻을 수 없었다.

단단히 화가 난 스브러스는 거리를 돌아다니며 다른 아이들의 사탕을 빼앗기로 마음을 먹는다. 다른 아이들보다 몸집이 큰 스브러스에게 사탕을 빼앗는 건 어렵지 않다. 또한, 스브러스는 매우 공평한 사람이기 때문에 한 아이의 사탕을 뺏으면 그 아이 친구들의 사탕도 모조리 뺏어버린다. (친구의 친구는 친구다?!)

사탕을 빼앗긴 아이들은 거리에 주저앉아 울고 K$K$명 이상의 아이들이 울기 시작하면 울음소리가 공명하여 온 집의 어른들이 거리로 나온다. 스브러스가 어른들에게 들키지 않고 최대로 뺏을 수 있는 사탕의 양을 구하여라.

스브러스는 혼자 모든 집을 돌아다녔기 때문에 다른 아이들이 받은 사탕의 양을 모두 알고 있다. 또한, 모든 아이는 스브러스를 피해 갈 수 없다.

---

## 입력
첫째 줄에 정수 N$N$, M$M$, K$K$가 주어진다. N$N$은 거리에 있는 아이들의 수, M$M$은 아이들의 친구 관계 수, K$K$는 울음소리가 공명하기 위한 최소 아이의 수이다. (1≤N≤30 000$1 \leq N \leq 30\ 000$, 0≤M≤100 000$0 \leq M \leq 100\ 000$, 1≤K≤min{N,3 000}$1 \leq K \leq \min\left\{N, 3\ 000\right\}$)

둘째 줄에는 아이들이 받은 사탕의 수를 나타내는 정수 c1,c2,⋯,cN$c_1, c_2, \cdots, c_N$이 주어진다. (1≤ci≤10 000$1 \leq c_i \leq 10\ 000$)

셋째 줄부터 M$M$개 줄에 갈쳐 각각의 줄에 정수 a$a$, b$b$가 주어진다. 이는 a$a$와 b$b$가 친구임을 의미한다. 같은 친구 관계가 두 번 주어지는 경우는 없다. (1≤a,b≤N$1 \leq a, b \leq N$, a≠b$a \neq b$)

---

## 출력
스브러스가 어른들에게 들키지 않고 아이들로부터 뺏을 수 있는 최대 사탕의 수를 출력한다.

---

## 성능 요약
메모리: 1421896 KB, 시간: 620 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 친구 관계를 그래프의 연결 요소로 이해하고, 각 연결 요소에서 얻을 수 있는 사탕의 총합을 계산한 후, 이를 기반으로 배낭 문제를 해결하는 방식으로 접근합니다. 스브러스는 K명 이상의 아이들이 함께 울지 않도록 각 연결 요소의 크기를 고려하여 사탕을 최대한 많이 뺏는 조합을 찾아야 합니다.

### 동작 과정
1. **입력 처리**: 
   - N(아이 수), M(친구 관계 수), K(최소 아이 수)를 입력받고, 각 아이가 받은 사탕의 수를 리스트로 저장합니다.
   - 친구 관계를 인접 리스트 형태로 저장합니다.

2. **DFS를 통한 연결 요소 찾기**:
   - 각 아이를 방문하면서 DFS를 통해 연결 요소의 크기와 해당 요소에서 얻을 수 있는 총 사탕의 양을 계산합니다.
   - 이 과정에서 방문한 아이들은 `visited` 리스트를 통해 관리하여 중복 방문을 방지합니다.

3. **배낭 문제 해결**:
   - 각 연결 요소의 크기가 K-1 이하인 경우에만 DP를 통해 최대 사탕 수를 계산합니다.
   - `dp` 배열을 사용하여 현재 고려 중인 크기까지의 최대 사탕 수를 업데이트합니다. 이 때, 배낭 문제를 해결하는 방식으로 진행하여 크기가 `capacity`인 경우의 최대 사탕 수를 구합니다.

4. **최종 출력**: 
   - DP 배열의 최대값을 출력하여 스브러스가 얻을 수 있는 최대 사탕의 양을 구합니다.

#### 예시 입력
```
5 4 3
1 2 3 4 5
1 2
2 3
3 4
4 5
```

- N=5, M=4, K=3
- 사탕 수: [1, 2, 3, 4, 5]
- 친구 관계: 1-2, 2-3, 3-4, 4-5 (모든 아이가 연결됨)

#### 단계별 설명
- DFS를 통해 1-5까지의 연결 요소를 탐색하고, 이를 통해 연결 요소의 크기와 총 사탕 수를 계산합니다. 이 경우, 연결 요소의 크기는 5, 총 사탕 수는 15입니다.
- K-1 = 2이므로, 크기가 3 이하인 요소만 고려합니다. 이 경우, 연결 요소의 크기가 5이므로 DP 업데이트는 이루어지지 않습니다.
- 최종적으로 DP 배열을 통해 최대 사탕 수를 계산하여 출력합니다.

### 시간 복잡도
- DFS 탐색: O(N + M) (모든 아이와 친구 관계를 한 번씩 탐색)
- DP 업데이트: O(C * E) (C는 K-1의 최대 값, E는 연결 요소의 수)
- 최종 시간 복잡도: O(N + M)

---

## 코드
```python
import sys
input = sys.stdin.readline
sys.setrecursionlimit(1000000)

n, m, k = map(int, input().split())
candy = [0] + list(map(int, input().split()))
relation = [[] for _ in range(n + 1)]
for _ in range(m):
    a, b = map(int, input().split())
    relation[a].append(b)
    relation[b].append(a)
    
visited = [False] * (n + 1)

def dfs(v):
    visited[v] = True
    size = 1
    total = candy[v]
    
    for next in relation[v]:
        if not visited[next]:
            sub_size, sub_total = dfs(next)
            size += sub_size
            total += sub_total
            
    return size, total

components = []
for i in range(1, n + 1):
    if not visited[i]:
        comp_size, comp_candy = dfs(i)
        components.append((comp_size, comp_candy))

capacity = k - 1 
dp = [0] * (capacity + 1)

for size, value in components:
    if size > capacity:
        continue
    for w in range(capacity, size - 1, -1):
        dp[w] = max(dp[w], dp[w - size] + value)

print(max(dp))
```