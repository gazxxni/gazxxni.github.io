---
layout: post
title: "[백준] 20040번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "20040"]
---

## 문제 링크
[https://www.acmicpc.net/problem/20040](https://www.acmicpc.net/problem/20040)

---

## 풀이

### 풀이 핵심 로직
이 문제는 Union-Find 자료구조를 사용하여 주어진 간선으로 이루어진 그래프에서 사이클이 형성되는 첫 번째 순간을 찾는 문제입니다. 각 점들을 연결하면서 이미 연결된 점에 대해 union 연산을 시도할 때, 두 점의 루트가 동일한 경우 사이클이 발생하는 것으로 판단합니다.

### 동작 과정
예를 들어, 입력이 다음과 같다고 가정해 봅시다:
```
5 4
1 2
2 3
3 1
4 5
```
1. `n`은 5, `m`은 4입니다. 즉, 5개의 노드와 4개의 간선이 있습니다.
2. 초기 상태에서 각 노드는 자기 자신을 부모로 가집니다: `parent = [0, 1, 2, 3, 4]`.
3. 첫 번째 간선 (1, 2)를 union합니다. `find(1)`과 `find(2)`의 결과는 서로 다르므로 연결 후 `parent = [0, 1, 1, 3, 4]`로 업데이트됩니다.
4. 두 번째 간선 (2, 3)을 union합니다. `find(2)`는 1을 찾고, `find(3)`는 3을 찾습니다. 서로 다르므로 연결 후 `parent = [0, 1, 1, 1, 4]`로 업데이트됩니다.
5. 세 번째 간선 (3, 1)을 union합니다. `find(3)`는 1을 찾고, `find(1)`도 1을 찾습니다. 두 점의 루트가 같으므로 사이클이 발생한 것으로 판단하고, 3을 출력한 후 반복문을 종료합니다.
6. 마지막으로, 사이클이 발견되지 않았다면 0을 출력하는 부분이 있지만, 이 경우에는 이미 사이클이 발견되었으므로 실행되지 않습니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 거의 O(α(n))입니다. 여기서 α(n)는 아커만 함수의 역함수로, 실제로 매우 느리게 증가하므로 상수 시간에 가깝습니다. Union-Find 연산은 효율적이며, 이 문제의 입력 크기에서는 매우 빠르게 동작합니다.

---

## 코드
```python
import sys
sys.setrecursionlimit(10**6) 
input = sys.stdin.readline

n, m = map(int, input().split())
parent = [i for i in range(n)]

def find(x):
    while parent[x] != x:
        parent[x] = parent[parent[x]] 
        x = parent[x]
    return x

def union(a, b):
    root_a, root_b = find(a), find(b)
    if root_a == root_b:
        return False
    parent[root_b] = root_a
    return True

for i in range(1, m + 1):
    a, b = map(int, input().split())
    if not union(a, b):
        print(i)
        break
else:
    print(0)
 
```