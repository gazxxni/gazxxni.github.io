---
layout: post
title: "[백준] 11444번 (Python)"
date: 2025-02-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "11444"]
---

## 문제 링크
[https://www.acmicpc.net/problem/11444](https://www.acmicpc.net/problem/11444)

---

## 풀이

### 풀이 핵심 로직
주어진 문제는 Fibonacci 수열의 n번째 항을 구하는 것입니다. 이 코드는 메모이제이션을 활용하여 재귀적으로 Fibonacci 수를 계산합니다. `fib(n)` 함수는 n이 짝수일 때와 홀수일 때 각각의 점화식을 사용하여 중복 계산을 줄이고, 모듈로 연산을 통해 큰 수의 오버플로우를 방지합니다.

### 동작 과정
1. 사용자가 n을 입력합니다.
2. `fib(n)` 함수가 호출됩니다.
3. n이 2 이하일 경우, 1을 반환합니다.
4. n이 짝수인 경우:
   - `fib(n // 2)`와 `fib(n // 2 - 1)`을 호출하여 두 값을 계산합니다.
   - 이 두 값을 사용해 `(fib(n//2) * (2 * fib(n // 2 - 1) + fib(n // 2))) % mod`를 계산하여 반환합니다.
5. n이 홀수인 경우:
   - `fib(n // 2 + 1)`과 `fib(n // 2)`를 호출하여 두 값을 계산합니다.
   - 이 두 값을 사용해 `(fib(n // 2 + 1) ** 2 + fib(n // 2) ** 2) % mod`를 계산하여 반환합니다.
6. 최종적으로 계산된 Fibonacci 수는 `print`를 통해 출력됩니다.

**예시 입력 및 단계별 설명:**
- 입력: `5`일 경우
  1. `fib(5)`가 호출됩니다.
  2. 5는 홀수이므로, `fib(5)`는 `fib(3) ** 2 + fib(2) ** 2`를 계산합니다.
  3. `fib(3)`이 호출되며, 이는 다시 `fib(2) ** 2 + fib(1) ** 2`로 계산됩니다.
  4. `fib(2)`는 1을 반환하고, `fib(1)`도 1을 반환합니다.
  5. 따라서 `fib(3)`는 `1 ** 2 + 1 ** 2`로 계산되어 2를 반환합니다.
  6. 이제 `fib(5)`는 `2 ** 2 + 1 ** 2`로 계산되어 5를 반환합니다.
  7. 최종적으로 5가 출력됩니다.

### 시간 복잡도
시간 복잡도는 O(log n)입니다. 이는 Fibonacci 수를 계산하기 위해 재귀적으로 호출되는 함수의 깊이가 log n 수준이기 때문입니다. 메모이제이션을 사용하여 중복 계산을 피하므로 효율적인 성능을 유지합니다.

---

## 코드
```python
from functools import cache

mod = 1000000007

@cache
def fib(n):
    if n <= 2:
        return 1
    elif n % 2 == 0:
        return (fib(n//2) * (2 * fib(n // 2 - 1) + fib(n // 2))) % mod
    else:
        return (fib(n // 2 + 1) ** 2 + fib(n // 2) ** 2) % mod
    
print(fib(int(input())))
```