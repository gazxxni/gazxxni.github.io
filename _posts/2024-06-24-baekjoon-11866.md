---
layout: post
title: "[백준] 11866번 (Python)"
date: 2024-06-24
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "11866"]
---

## 문제 링크
[https://www.acmicpc.net/problem/11866](https://www.acmicpc.net/problem/11866)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 n명의 사람들 중에서 k번째 사람을 제거하는 과정을 반복하여 마지막 남은 사람을 찾는 문제입니다. 핵심 아이디어는 원형 큐를 사용하여 k-1 만큼 인덱스를 이동하고, 그 인덱스의 사람을 제거하는 것입니다. 이를 통해 반복적으로 사람을 제거하면서 최종적으로 제거된 순서를 기록합니다.

### 동작 과정
예시로 n=7, k=3인 경우를 살펴보겠습니다.

1. 초기 큐: `[1, 2, 3, 4, 5, 6, 7]`
2. `idx`는 0으로 시작합니다. 첫 번째로 제거할 사람은 `k-1` 만큼 이동한 2번째 인덱스입니다. (3번째 사람)
   - `idx` 업데이트: `idx += 3 - 1 → idx = 2`
   - 큐에서 3 제거 → `[1, 2, 4, 5, 6, 7]`, `a = ['3']`

3. 다음 인덱스 계산:
   - `idx` 업데이트: `idx += 3 - 1 → idx = 4`
   - 큐에서 6 제거 → `[1, 2, 4, 5, 7]`, `a = ['3', '6']`

4. 계속 반복하다 보면 최종적으로 `a`에 모든 제거 순서가 저장됩니다. 최종적으로 모든 제거가 완료되면, `a`를 출력 형식으로 변환하여 결과를 출력합니다. 

이 과정을 반복하면서 인덱스가 큐의 길이를 초과할 경우에는 `%` 연산을 통해 원형 큐의 형태를 유지합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n^2)입니다. 각 제거 과정에서 pop 연산이 리스트의 중간에서 이루어지기 때문에, n개의 원소를 제거할 때마다 최악의 경우 O(n)의 시간이 소요됩니다. 따라서 전체적으로 O(n^2) 시간이 걸리게 됩니다.

---

## 코드
```python
import sys

n,k=map(int,sys.stdin.readline().split())
idx=0
queue=[i for i in range(1,n+1)]
a=[]

while queue:
    idx+=k-1
    if idx>=len(queue):
        idx%=len(queue)
    a.append(str(queue.pop(idx)))

print("<", ", ".join(a),">",sep="")
```