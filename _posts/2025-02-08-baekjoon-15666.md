---
layout: post
title: "[백준] 15666번 (Python)"
date: 2025-02-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "15666"]
---

## 문제 링크
[https://www.acmicpc.net/problem/15666](https://www.acmicpc.net/problem/15666)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 숫자들 중에서 중복을 허용하여 비내림차순으로 길이 m의 수열을 생성하는 것입니다. 핵심 아이디어는 깊이 우선 탐색(DFS)을 사용하여 모든 가능한 조합을 탐색하되, 이전에 선택한 숫자 또는 인덱스에서부터만 선택하여 비내림차순을 유지하는 것입니다.

### 동작 과정
예를 들어, 입력이 `4 2`와 `1 2 2 3`일 때, 이 과정을 단계별로 살펴보겠습니다:

1. 입력을 처리하여 `k = [1, 2, 3]`로 중복을 제거하고 정렬합니다.
2. DFS를 시작합니다. `depth`가 0이고, `idx`도 0입니다.
3. `i=0`: `ans`에 `1`을 추가하고, `depth`를 1로 증가시켜 DFS를 재귀 호출합니다.
   - `i=0`: `ans = [1, 1]` 출력
   - `i=1`: `ans = [1, 2]` 출력
   - `i=2`: `ans = [1, 3]` 출력
4. `i=1`: `ans`에 `2`를 추가하고, `depth`를 1로 증가시켜 DFS를 재귀 호출합니다.
   - `i=1`: `ans = [2, 2]` 출력
   - `i=2`: `ans = [2, 3]` 출력
5. `i=2`: `ans`에 `3`을 추가하고, `depth`를 1로 증가시켜 DFS를 재귀 호출합니다.
   - `i=2`: `ans = [3, 3]` 출력
6. 모든 경우의 수를 탐색한 뒤, `ans`를 이용해 원하는 결과를 출력합니다.

### 시간 복잡도
최악의 경우, 각 숫자가 중복될 수 있기 때문에 전체 조합의 수는 \(O(k^m)\)이며, 여기서 \(k\)는 고유한 숫자의 개수입니다. 따라서 시간 복잡도는 \(O(k^m)\)입니다.

---

## 코드
```python
n, m = map(int, input().split())
k = sorted(set(list(map(int, input().split()))))
ans = []
p = []

def dfs(depth, idx):
    if depth == m:
        print(*ans)
        return

    # idx부터 끝까지 탐색하면서 비내림차순을 유지
    for i in range(idx, len(k)):
        ans.append(k[i])  # 현재 숫자 선택
        dfs(depth+1, i)  # 같은 숫자를 중복 선택할 수 있으므로 `i`부터 다시 탐색
        ans.pop()   # 백트래킹(다음 경우를 위해 이전 선택을 되돌림)

dfs(0, 0)
p = sorted(list(set(p)))



```