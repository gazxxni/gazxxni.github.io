---
layout: post
title: "[백준] 1364번 울타리 치기 (Python)"
date: 2025-12-07
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1364", 수학]
---

## 문제 링크
[https://www.acmicpc.net/problem/1364](https://www.acmicpc.net/problem/1364)

---

## 문제
육각형 블록들로 이루어진 RPG 세계가 있다. 그 세계에 나라를 세우려고 하는 군주 캐릭터 송유진은 일반 블록을 울타리 블록으로 바꿀 수 있는 아이템을 N개 가지고 있다. 유진이가 이 N개의 아이템을 이용해서 점령할 수 있는 최대의 영토의 넓이를 구해보자. 울타리 안에 둘러싸인 블록들은 당연히 넓이에 포함 시키고, 울타리를 세운 블록도 넓이에 포함을 시킨다. 울타리는 항상 이어져 있어야 하며, 맵의 넓이는 무한하다.

---

## 입력
첫 줄에는 송유진이 가지고 있는 아이템의 수 N(1≤N≤1,000,000)이 주어진다.

---

## 출력
N개의 아이템을 이용하여 점령할 수 있는 최대의 블록 수를 출력한다.

---

## 성능 요약
메모리: 109544 KB, 시간: 88 ms

---

## 풀이

### 풀이 핵심 로직
주어진 문제는 N개의 울타리 블록을 사용하여 최대한 넓은 영역을 차지할 수 있는 구조를 만드는 것입니다. 육각형 블록의 특성을 이용하여, 울타리 블록을 줄어드는 형태로 배치하면 블록을 둘러싸는 구조를 만들 수 있으며, 이때 블록의 수는 `cnt += n`으로 계산됩니다. 울타리 블록을 배치하는 과정에서 `n`을 6씩 감소시키는 이유는 육각형 구조의 경계를 유지하기 위함입니다.

### 동작 과정
1. 입력값으로 `N`을 받습니다. 예를 들어, `N = 12`일 경우를 가정합니다.
2. `cnt`를 0으로 초기화합니다.
3. `N`이 6으로 나누어 떨어지는 경우 `cnt`에 1을 더합니다. (`N % 6 == 0`의 경우)
4. `N`이 0보다 큰 동안 다음 과정을 반복합니다:
   - 현재의 `N` 값을 `cnt`에 더합니다.
   - `N`에서 6을 빼줍니다.
5. 반복이 끝나면 `cnt`의 값을 출력합니다.
6. 예시로 `N = 12`일 경우, `cnt`는 다음과 같이 증가합니다:
   - 첫 번째 반복: `N = 12`, `cnt = 0 + 12 = 12`, `N`을 6 감소시켜 6이 됨
   - 두 번째 반복: `N = 6`, `cnt = 12 + 6 = 18`, `N`을 6 감소시켜 0이 됨
   - 종료 후 `cnt`는 18이 되어 출력됩니다.

### 시간 복잡도
이 알고리즘은 `N`을 6씩 감소시키므로, 반복 횟수는 대략 `N/6`에 비례합니다. 따라서 시간 복잡도는 O(N)입니다.

---

## 코드
```python
n = int(input())

cnt = 0

if n % 6 == 0:
    cnt += 1
    
while n > 0:
    cnt += n
    n -= 6

print(cnt)
```