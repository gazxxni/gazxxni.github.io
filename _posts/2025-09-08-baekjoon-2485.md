---
layout: post
title: "[백준] 2485번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2485"]
---

## 문제 링크
[https://www.acmicpc.net/problem/2485](https://www.acmicpc.net/problem/2485)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 주어진 점들 사이의 간격을 계산하고, 이 간격들의 최대 공약수(GCD)를 구하여, 이 GCD를 이용해 점들 사이에 추가할 수 있는 점의 개수를 계산하는 것입니다. 즉, 주어진 점들을 포함하여 등차수열을 만들기 위해 필요한 점의 개수를 구하는 것입니다.

### 동작 과정
1. **입력 처리**: 먼저, 점의 개수 `n`을 입력받고, 이어서 `n`개의 점의 좌표를 리스트 `arr`에 저장합니다.
   
   예시 입력:
   ```
   5
   2
   4
   8
   6
   10
   ```
   
2. **정렬**: 입력받은 점들을 오름차순으로 정렬합니다.
   - 정렬 후 `arr` = `[2, 4, 6, 8, 10]`

3. **간격 계산**: 각 점 사이의 간격을 계산하여 리스트 `brr`에 저장합니다.
   - `brr` = `[2, 2, 2, 2]` (각 점들 사이의 차이)

4. **GCD 계산**: `brr`의 모든 간격의 GCD를 계산합니다. 이 경우 모든 간격이 동일하므로 GCD는 2입니다.

5. **점의 개수 계산**: 주어진 점 사이의 최대 거리와 GCD를 이용하여 필요한 점의 개수를 계산합니다.
   - 전체 거리: `arr[-1] - arr[0]` = `10 - 2` = `8`
   - 필요한 점의 개수: `(8 // 2) + 1 - 5` = `4 - 5` = `-1` (여기서 음수는 필요하지 않음을 의미)

6. **결과 출력**: 최종적으로 추가해야 할 점의 개수를 출력합니다. 이 예시에서는 4개의 점을 추가해야 하므로 결과는 4입니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 다음과 같습니다.
- 점 정렬: \(O(n \log n)\)
- 간격 계산: \(O(n)\)
- GCD 계산: \(O(n)\) (각 GCD 계산은 최대 \(O(\log m)\)이지만, 여기서는 GCD를 여러 번 계산하여 최종적으로 \(O(n)\))
- 따라서 전체 시간 복잡도는 \(O(n \log n)\)입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
arr = [int(input()) for _ in range(n)]
arr.sort()

brr = [arr[i+1] - arr[i] for i in range(n - 1)]

def gcd(a, b):
    while b:
        a, b = b, a % b
    return abs(a) 

def gcd_of_array(brr):
    result = brr[0]
    for num in brr[1:]:
        result = gcd(result, num)
        if result == 1:
            return 1
    return result

a = gcd_of_array(brr)

cnt = (arr[-1] - arr[0]) // a + 1 - n
        
print(cnt)
```