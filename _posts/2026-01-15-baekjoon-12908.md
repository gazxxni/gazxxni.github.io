---
layout: post
title: "[백준] 12908번 텔레포트 3 (Python)"
date: 2026-01-15
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "12908", 그래프 이론, 브루트포스 알고리즘, 최단 경로, 플로이드–워셜]
---

## 문제 링크
[https://www.acmicpc.net/problem/12908](https://www.acmicpc.net/problem/12908)

---

## 문제
수빈이는 크기가 무한대인 격자판 위에 살고 있다. 격자판의 각 점은 두 정수의 쌍 (x, y)로 나타낼 수 있다.

제일 처음에 수빈이의 위치는 (xs, ys)이고, 집이 위치한 (xe, ye)로 이동하려고 한다.

수빈이는 두 가지 방법으로 이동할 수 있다. 첫 번째 방법은 점프를 하는 것이다. 예를 들어 (x, y)에 있는 경우에 (x+1, y), (x-1, y), (x, y+1), (x, y-1)로 이동할 수 있다. 점프는 1초가 걸린다.

두 번째 방법은 텔레포트를 사용하는 것이다. 텔레포트를 할 수 있는 방법은 총 세 가지가 있으며, 미리 정해져 있다. 텔레포트는 네 좌표 (x1, y1), (x2, y2)로 나타낼 수 있으며, (x1, y1)에서 (x2, y2)로 또는 (x2, y2)에서 (x1, y1)로 이동할 수 있다는 것이다. 텔레포트는 10초가 걸린다.

수빈이의 위치와 집의 위치가 주어졌을 때, 집에 가는 가장 빠른 시간을 구하는 프로그램을 작성하시오.

---

## 입력
첫째 줄에 xs와 ys가, 둘째 줄에 xe, ye가 주어진다. (0 ≤ xs, ys, xe, ye ≤ 1,000,000,000)

셋째 줄부터 세 개의 줄에는 텔레포트의 정보 x1, y1, x2, y2가 주어진다. (0 ≤ x1, y1, x2, y2 ≤ 1,000,000,000)

입력으로 주어지는 모든 좌표 8개는 서로 다르다.

---

## 출력
수빈이가 집에 가는 가장 빠른 시간을 출력한다.

---

## 성능 요약
메모리: 111284 KB, 시간: 120 ms

---

## 풀이

### 풀이 핵심 로직
문제는 수빈이의 시작 위치에서 집까지 가는 최단 시간을 찾는 것입니다. 수빈이는 점프와 텔레포트를 이용해 이동할 수 있으며, 텔레포트는 미리 주어진 두 좌표 쌍 간에만 가능합니다. 이 문제를 해결하기 위해 다익스트라 알고리즘을 사용하여 텔레포트 가능한 지점을 그래프의 노드로 간주하고, 각 노드 간의 거리를 계산하여 최단 경로를 찾습니다.

### 동작 과정
1. **입력 받기**: 수빈이의 시작 위치 `(xs, ys)`와 집의 위치 `(xe, ye)`를 입력받습니다. 이후 3개의 텔레포트 정보도 입력받습니다.
2. **그래프 구성**: 텔레포트 가능한 지점들을 그래프의 노드로 추가하고, 서로 연결된 노드 간의 거리를 10초로 설정합니다.
3. **다익스트라 알고리즘 적용**:
   - 시작점에서 집까지 가는 기본 거리(맨해튼 거리)를 계산합니다.
   - 우선순위 큐를 사용하여 현재 노드에서 다른 노드로 이동할 때 비용을 계산하고, 텔레포트를 사용하거나 점프를 통해 이동합니다.
   - 각 노드에 도달할 수 있는 최소 비용을 업데이트하면서 진행합니다.
4. **최종 결과**: 큐가 비어 있을 때까지 반복하고, 집까지 가는 최소 시간을 출력합니다.

예시 입력:
```
0 0
1 1
0 1 1 0
1 0 1 1
0 0 1 1
```
- 수빈이의 시작 위치는 `(0, 0)`이고 집은 `(1, 1)`입니다.
- 첫 번째 텔레포트는 `(0, 1)`과 `(1, 0)` 간의 이동을 가능하게 합니다. 두 번째 텔레포트는 `(1, 0)`과 `(1, 1)`, 세 번째는 `(0, 0)`과 `(1, 1)`입니다.
- 다익스트라 알고리즘을 통해 최단 경로를 계산하여 2초가 소요됨을 확인할 수 있습니다.

### 시간 복잡도
다익스트라 알고리즘의 시간 복잡도는 O((V + E) log V)입니다. 여기서 V는 노드의 수, E는 엣지의 수입니다. 텔레포트 노드가 3개로 제한되어 있어, V는 최대 5가 되므로, 전체 시간 복잡도는 O(log 5)로 상수 시간에 가까워 매우 빠르게 동작합니다.

---

## 코드
```python
import sys, heapq
from collections import defaultdict
'''
BFS로 풀면 모든 지점을 다 돌아야해서 시간초과
-> 다익스트라로 텔레포트 사용 구간만 검사, 텔레포트 안 쓰면 그냥 긴 거리가 답
'''
input = sys.stdin.readline

xs, ys = map(int, input().split())
xe, ye = map(int, input().split())

start_node = (xs, ys)
end_node = (xe, ye)

tp_dic = defaultdict(list)
tp_node = set()

for _ in range(3):
    x1, y1, x2, y2 = map(int, input().split())
    node1 = (x1, y1)
    node2 = (x2, y2)
    
    tp_node.add(node1)
    tp_node.add(node2)

    tp_dic[node1].append((node2, 10))
    tp_dic[node2].append((node1, 10))

key_nodes = list(tp_node)
key_nodes.append(start_node)

distances = {node: float('inf') for node in key_nodes}
distances[start_node] = 0

pq = [(0, start_node)]

# 시작점에서 도착점까지 가는 비용 (이게 기본 답)
min_cost = abs(xs - xe) + abs(ys - ye)

while pq:
    current_cost, current_node = heapq.heappop(pq)

    if current_cost > distances[current_node]:
        continue

    # 현재 위치에서 도착점까지 비용
    # (현재까지 비용 + 지금 위치에서 도착점까지 걷는 비용)
    cost_via_current = current_cost + abs(current_node[0] - end_node[0]) + abs(current_node[1] - end_node[1])
    min_cost = min(min_cost, cost_via_current)
    
    # 텔레포트 
    if current_node in tp_dic:
        for next_node, tele_cost in tp_dic[current_node]:
            new_cost = current_cost + tele_cost
            if new_cost < distances[next_node]:
                distances[next_node] = new_cost
                heapq.heappush(pq, (new_cost, next_node))

    # 현재 위치에서 모든 텔레포트 지점까지 비용 계산
    for next_tp_node in tp_node:
        if current_node == next_tp_node:
            continue
            
        walk_cost = abs(current_node[0] - next_tp_node[0]) + abs(current_node[1] - next_tp_node[1])
        new_cost = current_cost + walk_cost
        
        if new_cost < distances[next_tp_node]:
            distances[next_tp_node] = new_cost
            heapq.heappush(pq, (new_cost, next_tp_node))

print(min_cost)
```