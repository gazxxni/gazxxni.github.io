---
layout: post
title: "[백준] 12908번 텔레포트 3 (Python)"
date: 2026-01-15
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "12908", 그래프 이론, 브루트포스 알고리즘, 최단 경로, 플로이드–워셜]
---

## 문제 링크
[https://www.acmicpc.net/problem/12908](https://www.acmicpc.net/problem/12908)

---

## 문제
수빈이는 크기가 무한대인 격자판 위에 살고 있다. 격자판의 각 점은 두 정수의 쌍 (x, y)로 나타낼 수 있다.

제일 처음에 수빈이의 위치는 (xs, ys)이고, 집이 위치한 (xe, ye)로 이동하려고 한다.

수빈이는 두 가지 방법으로 이동할 수 있다. 첫 번째 방법은 점프를 하는 것이다. 예를 들어 (x, y)에 있는 경우에 (x+1, y), (x-1, y), (x, y+1), (x, y-1)로 이동할 수 있다. 점프는 1초가 걸린다.

두 번째 방법은 텔레포트를 사용하는 것이다. 텔레포트를 할 수 있는 방법은 총 세 가지가 있으며, 미리 정해져 있다. 텔레포트는 네 좌표 (x1, y1), (x2, y2)로 나타낼 수 있으며, (x1, y1)에서 (x2, y2)로 또는 (x2, y2)에서 (x1, y1)로 이동할 수 있다는 것이다. 텔레포트는 10초가 걸린다.

수빈이의 위치와 집의 위치가 주어졌을 때, 집에 가는 가장 빠른 시간을 구하는 프로그램을 작성하시오.

---

## 입력
첫째 줄에 xs와 ys가, 둘째 줄에 xe, ye가 주어진다. (0 ≤ xs, ys, xe, ye ≤ 1,000,000,000)

셋째 줄부터 세 개의 줄에는 텔레포트의 정보 x1, y1, x2, y2가 주어진다. (0 ≤ x1, y1, x2, y2 ≤ 1,000,000,000)

입력으로 주어지는 모든 좌표 8개는 서로 다르다.

---

## 출력
수빈이가 집에 가는 가장 빠른 시간을 출력한다.

---

## 성능 요약
메모리: 111284 KB, 시간: 120 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 수빈이가 집으로 가는 가장 빠른 시간을 구하는 문제로, 점프와 텔레포트를 이용한 이동 방법을 조합하여 최단 경로를 찾는 것이 핵심이다. 일반적인 거리 계산을 통해 기본적인 점프 이동 시간을 구한 후, 텔레포트를 사용할 수 있는 위치에서 이동 시간을 업데이트하여 최적의 경로를 찾는다.

### 동작 과정
1. **입력 받기**: 시작 좌표 `(xs, ys)`와 집 좌표 `(xe, ye)`를 입력받고, 3개의 텔레포트 좌표를 입력받는다.
2. **초기 설정**: 시작점과 끝점, 텔레포트 가능한 지점을 저장하고, 각 지점 간의 최단 거리를 무한대로 초기화한다.
3. **우선순위 큐 초기화**: 시작점을 큐에 넣고 거리 0으로 초기화한다.
4. **다익스트라 알고리즘 실행**: 
    - 현재 위치에서 집까지의 직선 거리를 계산하여 최소 시간을 업데이트한다.
    - 텔레포트 가능한 위치로의 이동 시간을 계산하고, 업데이트된 거리로 큐에 넣는다.
    - 현재 위치에서 다른 텔레포트 지점까지의 점프 이동 시간을 계산하고, 필요 시 큐에 추가한다.
5. **최종 결과 출력**: 최단 시간 결과인 `min_cost`를 출력한다.

예시 입력:
```
0 0
1 1
0 1 1 0
1 0 0 1
0 0 1 1
```
- 수빈이는 `(0, 0)`에서 시작하고, 집은 `(1, 1)`에 위치한다.
- 텔레포트 정보는 3개 주어지며, 각각의 텔레포트 연결을 통해 비용을 계산한다.
- 직선 거리를 통해 기본 이동 시간을 계산하고, 텔레포트를 활용한 최단 경로를 계산하여 결과를 도출한다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O((V + E) log V)로, 여기서 V는 방문할 수 있는 노드의 수(텔레포트 노드 + 시작점), E는 가능한 엣지(점프 거리 및 텔레포트 연결)이다. 하지만 실제로는 텔레포트 지점이 3개이므로, 상수 시간으로 처리된다. 따라서 이 문제의 복잡도는 O(log V)로 간주할 수 있다.

---

## 코드
```python
import sys, heapq
from collections import defaultdict
'''
BFS로 풀면 모든 지점을 다 돌아야해서 시간초과
-> 다익스트라로 텔레포트 사용 구간만 검사, 텔레포트 안 쓰면 그냥 긴 거리가 답
'''
input = sys.stdin.readline

xs, ys = map(int, input().split())
xe, ye = map(int, input().split())

start_node = (xs, ys)
end_node = (xe, ye)

tp_dic = defaultdict(list)
tp_node = set()

for _ in range(3):
    x1, y1, x2, y2 = map(int, input().split())
    node1 = (x1, y1)
    node2 = (x2, y2)
    
    tp_node.add(node1)
    tp_node.add(node2)

    tp_dic[node1].append((node2, 10))
    tp_dic[node2].append((node1, 10))

key_nodes = list(tp_node)
key_nodes.append(start_node)

distances = {node: float('inf') for node in key_nodes}
distances[start_node] = 0

pq = [(0, start_node)]

# 시작점에서 도착점까지 가는 비용 (이게 기본 답)
min_cost = abs(xs - xe) + abs(ys - ye)

while pq:
    current_cost, current_node = heapq.heappop(pq)

    if current_cost > distances[current_node]:
        continue

    # 현재 위치에서 도착점까지 비용
    # (현재까지 비용 + 지금 위치에서 도착점까지 걷는 비용)
    cost_via_current = current_cost + abs(current_node[0] - end_node[0]) + abs(current_node[1] - end_node[1])
    min_cost = min(min_cost, cost_via_current)
    
    # 텔레포트 
    if current_node in tp_dic:
        for next_node, tele_cost in tp_dic[current_node]:
            new_cost = current_cost + tele_cost
            if new_cost < distances[next_node]:
                distances[next_node] = new_cost
                heapq.heappush(pq, (new_cost, next_node))

    # 현재 위치에서 모든 텔레포트 지점까지 비용 계산
    for next_tp_node in tp_node:
        if current_node == next_tp_node:
            continue
            
        walk_cost = abs(current_node[0] - next_tp_node[0]) + abs(current_node[1] - next_tp_node[1])
        new_cost = current_cost + walk_cost
        
        if new_cost < distances[next_tp_node]:
            distances[next_tp_node] = new_cost
            heapq.heappush(pq, (new_cost, next_tp_node))

print(min_cost)
```