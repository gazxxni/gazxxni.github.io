---
layout: post
title: "[백준] 15663번 (Python)"
date: 2025-02-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "15663"]
---

## 문제 링크
[https://www.acmicpc.net/problem/15663](https://www.acmicpc.net/problem/15663)

---

## 풀이

### 풀이 핵심 로직
이 문제는 중복을 허용하지 않고, 주어진 숫자 배열에서 길이가 m인 순열을 생성하는 문제입니다. DFS(Depth-First Search) 기법을 사용하여 재귀적으로 숫자를 선택하고, `visited` 배열을 통해 이미 선택한 숫자를 추적하며, 중복된 숫자는 사용하지 않도록 체크합니다.

### 동작 과정
예시 입력: 
```
4 2
1 1 2 2
```

1. **초기화**: n=4, m=2, arr=[1, 1, 2, 2]로 주어지고, arr는 정렬되어 [1, 1, 2, 2]가 됩니다. `ans`는 빈 리스트로 시작하고, `visited`는 [False, False, False, False]로 초기화됩니다.

2. **첫 번째 DFS 호출**: DFS 함수가 호출되면 ans의 길이가 m(2)인지 확인합니다. 처음에는 길이가 0이므로, for 루프를 시작합니다.

3. **첫 번째 숫자 선택**: i=0일 때 arr[0]이 1이므로, visited[0]를 True로 설정하고 ans에 1을 추가합니다. `check`는 1로 업데이트됩니다. DFS가 재귀적으로 다시 호출됩니다.

4. **두 번째 숫자 선택**: 두 번째 DFS 호출에서 ans의 길이가 여전히 m이 아니므로 다시 for 루프를 실행합니다. i=0은 이미 visited 상태이므로 무시하고, i=1로 가서 arr[1]도 1이므로 선택할 수 있습니다. ans는 [1, 1]이 되고, 이 상태에서 DFS가 호출되지만 ans의 길이가 m이므로 결과를 출력하고, backtrack합니다.

5. **중복 방지**: i=2로 가면 arr[2]가 2이므로, visited[2]를 True로 하고 ans에 2를 추가합니다. 다시 DFS가 호출되어 ans는 [1, 2]가 됩니다. 길이가 m이므로 결과를 출력하고 다시 backtrack합니다.

6. **반복**: 이 과정은 arr의 모든 숫자를 다 탐색할 때까지 반복되며, 모든 가능한 조합이 출력됩니다.

최종적으로 출력되는 조합은 다음과 같습니다:
```
1 1
1 2
2 1
2 2
```

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n^m)입니다. 여기서 n은 입력 숫자의 개수, m은 출력할 숫자의 개수입니다. 각 숫자 조합을 생성하는 과정에서 각 숫자에 대해 재귀적으로 호출되므로, 가능한 모든 조합을 탐색하게 됩니다.

---

## 코드
```python
import sys

n, m = map(int, input().split())  
arr = list(map(int, input().split()))  
arr.sort()  
ans = [] 
visited = [False] * n 


def dfs():
    if len(ans) == m: 
        print(*ans) 
        return 
    
    check = 0  # 같은은 숫자가 사용되는 것을 방지하기 위한 변수

    for i in range(n):
        # 숫자가 아직 방문되지 않았고, 이전에 사용한 숫자가 아닌 경우
        if not visited[i] and check != arr[i]: 
            visited[i] = True  # 현재 숫자를 방문 처리
            ans.append(arr[i])  # 숫자를 결과 리스트에 추가
            check = arr[i]  # 현재 숫자를 중복 체크 변수에 저장
            dfs() 
            visited[i] = False  # 재귀 호출이 끝나면 현재 숫자의 방문을 취소
            ans.pop()  # 결과 리스트에서 숫자를 제거 (백트래킹)

dfs()

```