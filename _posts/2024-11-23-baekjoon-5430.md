---
layout: post
title: "[백준] 5430번 (Python)"
date: 2024-11-23
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "5430"]
---

## 문제 링크
[https://www.acmicpc.net/problem/5430](https://www.acmicpc.net/problem/5430)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 주어진 명령어(`p`)의 처리 중 'R' 명령어에 따라 배열의 순서를 뒤집을 필요가 있을 때, 실제로 배열을 뒤집는 대신 뒤집힌 횟수를 카운트하여 이를 통해 배열의 상태를 판단하는 것입니다. 'D' 명령어는 배열에서 요소를 삭제하는 역할을 하며, 이때 배열의 현재 상태(정방향 또는 뒤집힌 상태)에 따라 적절한 요소를 제거합니다.

### 동작 과정
1. 여러 테스트 케이스가 주어지므로, 먼저 테스트 케이스의 개수를 입력받습니다.
2. 각 테스트 케이스에 대해, 명령어(`p`), 배열의 크기(`n`), 배열의 요소를 입력받습니다.
3. `deque`를 사용하여 배열을 큐 형태로 저장합니다.
4. `flag` 변수를 통해 'R' 명령어의 총 횟수를 추적합니다. (짝수일 경우 원래 상태, 홀수일 경우 뒤집힌 상태)
5. 명령어를 순차적으로 처리합니다:
   - 'R' 명령어가 오면 `flag`를 증가시킵니다.
   - 'D' 명령어가 오면 큐가 비어있지 않은지 확인하고, 현재의 상태에 따라 적절한 요소를 제거합니다.
6. 모든 명령을 처리한 후, `flag`의 값에 따라 큐를 출력합니다. 만약 `flag`가 홀수라면 큐를 뒤집어서 출력합니다.

**예시 입력:**
```
1
RDD
4
[1,2,3,4]
```
**단계별 설명:**
- `t`가 1이므로 하나의 테스트 케이스를 처리합니다.
- `p`는 'RDD'이고, `n`은 4, 배열은 `[1,2,3,4]`입니다.
- 초기 큐는 `deque(['1', '2', '3', '4'])`입니다.
- 'R' 명령어가 오면 `flag`가 1이 되어 뒤집힌 상태가 됩니다.
- 첫 번째 'D' 명령어가 오면 큐에서 `4`를 제거합니다 (뒤집힌 상태이므로 큐의 오른쪽에서 제거).
- 두 번째 'D' 명령어가 오면 큐에서 `3`을 제거합니다.
- 최종적으로 큐는 `deque(['1', '2'])`이고, `flag`는 홀수이므로 결과는 `"[2,1]"`로 뒤집혀서 출력됩니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 \(O(t \cdot (m + n))\)입니다. 여기서 \(t\)는 테스트 케이스의 개수, \(m\)은 명령어의 길이, \(n\)은 배열의 크기입니다. 각 명령어를 처리하는데 \(O(1)\)의 시간이 소요되고, 배열의 요소를 출력하는데 \(O(n)\)의 시간이 소요됩니다.

---

## 코드
```python
from collections import deque 
 
t = int(input())
 
for i in range(t):
    p = input() 
    n = int(input()) 
    arr = input()[1:-1].split(',') 
 
    queue = deque(arr)  
 
    flag = 0  # 뒤집힌 횟수를 추적하는 변수 (R이 짝수면 원래 상태)
 
    if n == 0: 
        queue = []
 
    for j in p: 
        if j == 'R':  
            flag += 1  # 뒤집힌 횟수 추가
        elif j == 'D':  
            if len(queue) == 0:
                print("error")  
                break 
            else:
                if flag % 2 == 0:  # 뒤집힌 횟수가 짝수면 (정방향)
                    queue.popleft()  
                else:  # 뒤집힌 횟수가 홀수면 (뒤집힌 상태)
                    queue.pop() 
 
    else:  # 명령어 처리가 끝난 후
        if flag % 2 == 0: 
            print("[" + ",".join(queue) + "]")  # 원래 순서대로 출력
        else:  
            queue.reverse()  # deque를 뒤집어서 원래 순서대로 되돌림
            print("[" + ",".join(queue) + "]")  # 뒤집힌 결과 출력

```