---
layout: post
title: "[백준] 10026번 (Python)"
date: 2024-11-23
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "10026"]
---

## 문제 링크
[https://www.acmicpc.net/problem/10026](https://www.acmicpc.net/problem/10026)

---

## 풀이

### 풀이 핵심 로직
이 문제는 두 가지 경우 (정상인과 적록색약인 경우)에 대해 연결된 색상의 영역을 세는 문제입니다. BFS(너비 우선 탐색)를 사용하여 각 색상 영역을 탐색하고, 방문한 영역은 다시 방문하지 않도록 처리하여 그룹의 개수를 세는 방식으로 해결합니다.

### 동작 과정
1. **입력 처리**: N x N의 색상 배열을 입력받습니다.
   예를 들어, 입력이 다음과 같다고 가정합시다:
   ```
   5
   RRRRR
   RRGGG
   RRGGG
   RRRRR
   RRRRR
   ```
   
2. **정상인 경우 그룹 카운트**:
   - `visited` 배열을 초기화하고 `cnt_1`을 0으로 설정합니다.
   - 2중 루프를 통해 모든 칸을 탐색하며, 방문하지 않은 칸에서 BFS를 시작합니다.
   - BFS는 현재 색상과 동일한 색상을 가진 인접한 칸을 모두 방문하면서 카운트를 증가시킵니다.
   - 위 입력에서는 1개의 그룹(R 영역)과 1개의 그룹(G 영역)으로 총 2개의 그룹이 형성됩니다. 따라서 `cnt_1`은 2가 됩니다.

3. **적록색약 처리**:
   - 색상 배열에서 'G'를 'R'로 변경하여 적록색약을 처리합니다.
   - 이제 색상 배열은 다음과 같이 됩니다:
   ```
   RRRRR
   RRRRR
   RRRRR
   RRRRR
   RRRRR
   ```

4. **적록색약인 경우 그룹 카운트**:
   - `visited` 배열을 다시 초기화하고 `cnt_2`을 0으로 설정합니다.
   - 다시 2중 루프를 통해 모든 칸을 탐색하며 BFS를 시작합니다.
   - 위의 입력에서는 모든 칸이 'R'로 변경되었기 때문에 하나의 그룹만 형성됩니다. 따라서 `cnt_2`는 1이 됩니다.

5. **출력**: 두 그룹의 개수인 `cnt_1`과 `cnt_2`를 출력합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(N^2)입니다. N x N의 격자를 탐색하기 위해 두 번의 BFS를 수행하며, 각 BFS는 최대 N^2의 칸을 방문할 수 있습니다. 따라서 전체 시간 복잡도는 O(N^2)입니다.

---

## 코드
```python
from collections import deque

def BFS(x, y):
    q.append((x, y))
    dx = [-1, 0, 1, 0]
    dy = [0, 1, 0, -1]
    visited[x][y] = 1

    while q:
        x, y = q.popleft()

        for i in range(4):
            nx = x + dx[i] 
            ny = y + dy[i] 

            # 경계 안에 있고, 현재 색과 동일하며, 방문하지 않은 경우
            if 0 <= nx < n and 0 <= ny < n and a[nx][ny] == a[x][y] and not visited[nx][ny]:
                visited[nx][ny] = 1  # 방문 처리
                q.append((nx, ny))  # 큐에 추가

n = int(input())
a = [list(input()) for _ in range(n)]
q = deque()

visited = [[0] * n for _ in range(n)]
cnt_1 = 0  # 정상 시각 그룹의 개수


for i in range(n):
    for j in range(n):
        if not visited[i][j]:
            BFS(i, j)
            cnt_1 += 1 

# 적록색약 처리를 위해 'G'를 'R'로 변경
for i in range(n):
    for j in range(n):
        if a[i][j] == 'G':
            a[i][j] = 'R'

visited = [[0] * n for _ in range(n)]
cnt_2 = 0  # 적록색약 그룹의 개수

for i in range(n):
    for j in range(n):
        if not visited[i][j]:
            BFS(i, j)
            cnt_2 += 1  # 적록색약 그룹 카운트 증가

print(cnt_1, cnt_2)

```