---
layout: post
title: "[백준] 1562번 계단 수 (Python)"
date: 2025-12-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1562", 다이나믹 프로그래밍, 비트마스킹, 비트필드를 이용한 다이나믹 프로그래밍]
---

## 문제 링크
[https://www.acmicpc.net/problem/1562](https://www.acmicpc.net/problem/1562)

---

## 문제
45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N이면서 0부터 9까지 숫자가 모두 등장하는 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. 0으로 시작하는 수는 계단수가 아니다.

---

## 입력
첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

---

## 출력
첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

---

## 성능 요약
메모리: 116564 KB, 시간: 116 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 길이 N의 계단 수를 구하는 것으로, 계단 수는 인접한 자리의 숫자 차이가 1인 수입니다. 또한, 모든 숫자(0부터 9까지)가 포함되어야 하며, 0으로 시작하지 않아야 합니다. 이를 해결하기 위해 동적 프로그래밍(DP)과 비트마스킹 기법을 사용하여 각 자리수의 숫자와 사용된 숫자의 상태를 함께 저장합니다.

### 동작 과정
1. **초기화**: 길이가 1인 계단 수를 초기화합니다. 숫자 1부터 9까지의 경우는 각각 1개의 계단 수로 초기화하고, 비트마스크는 해당 숫자를 사용했다는 것을 표시합니다.
   ```python
   for j in range(1, 10):
       dp[1][j][1 << j] = 1
   ```

2. **DP 테이블 갱신**: 길이가 i인 계단 수에서 길이 i+1인 계단 수로 변환합니다. 현재 숫자가 j일 때, j-1 또는 j+1로 이동하며 새로운 비트마스크를 갱신합니다.
   ```python
   if j > 0:
       new_digit = j - 1
       new_mask = k | (1 << new_digit)
       dp[i + 1][new_digit][new_mask] += dp[i][j][k]
   if j < 9:
       new_digit = j + 1
       new_mask = k | (1 << new_digit)
       dp[i + 1][new_digit][new_mask] += dp[i][j][k]
   ```

3. **결과 계산**: 길이가 N인 계단 수 중 모든 숫자가 사용된 경우를 찾아서 합산합니다. 비트마스크 `(1 << 10) - 1`은 모든 숫자가 사용되었음을 나타냅니다.
   ```python
   for j in range(10):
       result += dp[n][j][(1 << 10) - 1]
   ```

4. **출력**: 최종 결과를 1,000,000,000으로 나눈 나머지를 출력합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(N * 10 * 1024)입니다. 여기서 N은 입력의 길이, 10은 가능한 숫자(0~9)의 개수, 1024는 2^10으로 모든 숫자의 조합을 나타냅니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

MOD = 1_000_000_000
n = int(input())
dp = [[[0] * 1024 for _ in range(10)] for _ in range(n + 1)]

# 길이 1의 계단 수 초기화
for j in range(1, 10):
    dp[1][j][1 << j] = 1

for i in range(1, n):
    for j in range(10):
        for k in range(1 << 10):
            if dp[i][j][k] == 0:
                continue
            
            # Case 1: 다음 숫자가 j-1일 경우
            if j > 0:
                new_digit = j - 1
                new_mask = k | (1 << new_digit)
                dp[i + 1][new_digit][new_mask] = (dp[i + 1][new_digit][new_mask] + dp[i][j][k]) % MOD
            
            # Case 2: 다음 숫자가 j+1일 경우
            if j < 9:
                new_digit = j + 1
                new_mask = k | (1 << new_digit)
                dp[i + 1][new_digit][new_mask] = (dp[i + 1][new_digit][new_mask] + dp[i][j][k]) % MOD

result = 0
for j in range(10):
    result = (result + dp[n][j][(1 << 10) - 1]) % MOD
    
print(result)
```