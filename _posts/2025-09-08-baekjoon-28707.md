---
layout: post
title: "[백준] 28707번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "28707"]
---

## 문제 링크
[https://www.acmicpc.net/problem/28707](https://www.acmicpc.net/problem/28707)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 배열을 정렬하기 위해 여러 쌍의 원소를 교환할 수 있는 비용을 최소화하는 방법을 찾는 것입니다. 다익스트라 알고리즘을 사용하여 현재의 배열 상태에서 목표 배열로 가는 최소 비용을 찾습니다. 각 상태는 배열의 특정 순서를 나타내며, 상태 간의 전이는 주어진 교환 쌍을 사용하여 이루어집니다.

### 동작 과정
1. **입력 처리**: 먼저, 배열의 길이 `n`과 배열 `arr`, 교환 쌍의 수 `m`과 각 교환 쌍 `(l, r, c)`를 입력받습니다. `brr` 리스트에 (0-indexed) 형태로 저장합니다.
   
2. **초기 상태 및 목표 설정**: 초기 배열 `start`는 입력받은 배열의 튜플 형태이고, 목표 배열 `goal`은 정렬된 배열입니다. 

3. **다익스트라 알고리즘**:
   - 우선순위 큐 `heap`을 초기화하고, 시작 상태를 큐에 추가합니다.
   - 큐에서 상태를 꺼내고, 그 상태가 목표 상태와 같다면 현재 비용을 출력하고 종료합니다.
   - 꺼낸 상태의 비용이 이미 기록된 비용보다 크면, 굳이 처리할 필요가 없으므로 계속합니다.
   - 교환 쌍 리스트 `brr`를 순회하여 가능한 교환을 통해 새로운 상태를 만들고, 이 상태의 비용을 계산하여 최소 비용을 유지하는 경우에만 큐에 추가합니다.
   - 목표 상태에 도달하지 못하면 `-1`을 출력합니다.

**예시 입력**:
```
5
4 3 2 1 5
3
1 2 1
3 4 2
2 4 3
```

- 초기 상태: `(4, 3, 2, 1, 5)`, 목표 상태: `(1, 2, 3, 4, 5)`
- 첫 번째 상태에서 `1, 2`를 교환하여 `(3, 4, 2, 1, 5)`로 변화 (비용 1).
- 두 번째 상태에서 `2, 3`을 교환하여 `(3, 2, 4, 1, 5)`로 변화 (비용 3).
- 이후 상태에서 `3, 4`를 교환하여 `(1, 2, 3, 4, 5)`로 도달 (비용 5).
  
최종적으로 출력: `5`

### 시간 복잡도
최악의 경우, 다익스트라 알고리즘의 복잡도는 `O((n!) * log(n!))`입니다. 여기서 `n!`는 가능한 모든 배열 상태의 수를 나타내며, 각 상태에 대해 우선순위 큐에서의 연산이 필요하기 때문입니다.

---

## 코드
```python
import sys, heapq
input = sys.stdin.readline

n = int(input())
arr = list(map(int, input().split()))
m = int(input())
brr = []
for _ in range(m):
    l, r, c = map(int, input().split())
    brr.append((l-1, r-1, c))
    
start = tuple(arr)
goal = tuple(sorted(arr))
visited = {}

def dijk():
    heap = []
    heapq.heappush(heap, (0, start))
    visited[start] = 0
    
    while heap:
        cost, state = heapq.heappop(heap)
        
        if state == goal:
            print(cost)
            break
        
        if visited[state] < cost:
            continue
        
        for l, r, c in brr:
            
            new_state = list(state)
            new_state[l], new_state[r] = new_state[r], new_state[l]
            next_state = tuple(new_state)
            new_cost = cost + c
            
            if next_state not in visited or visited[next_state] > new_cost:
                visited[next_state] = new_cost
                heapq.heappush(heap, (new_cost, next_state))
            
    else:
        print(-1)        
                
dijk()
```