---
layout: post
title: "[백준] 11053번 (Python)"
date: 2025-02-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "11053"]
---

## 문제 링크
[https://www.acmicpc.net/problem/11053](https://www.acmicpc.net/problem/11053)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 수열에서 가장 긴 증가하는 부분 수열(Longest Increasing Subsequence, LIS)의 길이를 찾는 문제입니다. 동적 프로그래밍(DP) 기법을 사용하여, 각 위치에서의 가장 긴 증가하는 부분 수열의 길이를 저장하고, 이전 위치들과 비교하여 현재 위치에서의 최적 값을 갱신하는 방식으로 해결합니다.

### 동작 과정
예를 들어 입력이 다음과 같다고 가정해 보겠습니다:
```
6
10 20 10 30 20 50
```
1. 초기화: `n = 6`, `a = [10, 20, 10, 30, 20, 50]`, `dp = [1, 1, 1, 1, 1, 1]` (각 원소는 자기 자신으로 시작하는 부분 수열의 길이)
  
2. `i = 1` (a[1] = 20): 
   - `j = 0` (a[0] = 10): a[1] > a[0] 이므로, `dp[1] = max(dp[1], dp[0] + 1) = max(1, 1 + 1) = 2` 
   - dp 상태: `[1, 2, 1, 1, 1, 1]`

3. `i = 2` (a[2] = 10):
   - `j = 0` (a[0] = 10): a[2] <= a[0] 이므로 변화 없음
   - `j = 1` (a[1] = 20): a[2] <= a[1] 이므로 변화 없음
   - dp 상태: `[1, 2, 1, 1, 1, 1]`
  
4. `i = 3` (a[3] = 30):
   - `j = 0` (a[0] = 10): a[3] > a[0] → `dp[3] = max(1, 1 + 1) = 2`
   - `j = 1` (a[1] = 20): a[3] > a[1] → `dp[3] = max(2, 2 + 1) = 3`
   - `j = 2` (a[2] = 10): a[3] > a[2] → 변화 없음
   - dp 상태: `[1, 2, 1, 3, 1, 1]`

5. `i = 4` (a[4] = 20):
   - `j = 0` (a[0] = 10): a[4] > a[0] → `dp[4] = max(1, 1 + 1) = 2`
   - `j = 1` (a[1] = 20): a[4] <= a[1] → 변화 없음
   - `j = 2` (a[2] = 10): a[4] > a[2] → 변화 없음
   - `j = 3` (a[3] = 30): a[4] <= a[3] → 변화 없음
   - dp 상태: `[1, 2, 1, 3, 2, 1]`

6. `i = 5` (a[5] = 50):
   - `j = 0` (a[0] = 10): a[5] > a[0] → `dp[5] = max(1, 1 + 1) = 2`
   - `j = 1` (a[1] = 20): a[5] > a[1] → `dp[5] = max(2, 2 + 1) = 3`
   - `j = 2` (a[2] = 10): a[5] > a[2] → 변화 없음
   - `j = 3` (a[3] = 30): a[5] > a[3] → `dp[5] = max(3, 3 + 1) = 4`
   - `j = 4` (a[4] = 20): a[5] > a[4] → 변화 없음
   - dp 상태: `[1, 2, 1, 3, 2, 4]`

마지막으로 `max(dp)`를 통해 가장 긴 증가하는 부분 수열의 길이를 출력합니다. 이 경우, 최대값인

---

## 코드
```python
import sys
input = sys.stdin.readline

n = int(input())  
a = list(map(int, input().split()))
dp = [1] * n  

for i in range(1, n):  # i는 현재 위치
    for j in range(i):  # j는 i 이전의 모든 위치
        if a[i] > a[j]:
            dp[i] = max(dp[i], dp[j]+1)

print(max(dp))

```