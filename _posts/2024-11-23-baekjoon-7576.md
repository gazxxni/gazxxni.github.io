---
layout: post
title: "[백준] 7576번 (Python)"
date: 2024-11-23
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "7576"]
---

## 문제 링크
[https://www.acmicpc.net/problem/7576](https://www.acmicpc.net/problem/7576)

---

## 풀이

### 풀이 핵심 로직
이 문제는 BFS(너비 우선 탐색) 알고리즘을 사용하여 익은 토마토가 주변의 익지 않은 토마토를 익히는 과정을 시뮬레이션합니다. 초기 상태에서 익은 토마토의 위치를 큐에 담고, 큐에서 하나씩 꺼내며 4방향으로 탐색하여 익지 않은 토마토를 익히는 과정을 반복합니다. 마지막에는 모든 토마토가 익는 데 걸린 최대 일수를 계산합니다.

### 동작 과정
1. **입력 받기**: 최초에 m(열)과 n(행)의 크기를 입력받고, n개의 행에 대한 토마토 상태를 입력받아 2차원 배열 `arr`에 저장합니다.
   
   예시 입력:
   ```
   5 4
   0 0 1 0 0
   0 0 0 0 0
   0 0 0 0 0
   0 0 0 0 0
   ```

2. **초기 큐 설정**: 배열을 순회하며 익은 토마토(값이 1인 경우)의 위치를 큐에 추가합니다. 이 예시에서는 (0, 2) 위치의 토마토가 익어 있습니다.

3. **BFS 탐색**: 큐가 빌 때까지 반복하며, 큐에서 토마토의 위치를 꺼내고, 그 위치의 4방향(상하좌우)으로 탐색합니다. 주변에 익지 않은 토마토(값이 0인 경우)를 발견하면 그 토마토를 익히고(값을 현재 토마토의 값 + 1로 설정), 큐에 추가합니다.

4. **결과 확인**: BFS가 끝난 후, 배열을 다시 순회하여 익지 않은 토마토(값이 0인 경우)가 남아 있는지 체크합니다. 만약 남아 있다면 -1을 출력하고 종료합니다. 그렇지 않으면 최대 익은 날짜를 계산하여 출력합니다. 이때, 시작 상태를 제외하기 위해 1을 빼줍니다.

   예시 결과:
   ```
   6
   ```

### 시간 복잡도
BFS는 각 토마토를 한 번씩 방문하므로, 시간 복잡도는 O(n * m)입니다. 여기서 n은 행의 수, m은 열의 수입니다.

---

## 코드
```python
from collections import deque

m, n = map(int, input().split())

arr = []

for _ in range(n):
    row = list(map(int, input().split()))
    arr.append(row)

q = deque()
# 토마토 익히기 위해 사용할 방향 배열 (상하좌우)
directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

# 초기 익은 토마토의 위치를 큐에 추가합니다.
for i in range(n):  # 행
    for j in range(m):  # 열
        if arr[i][j] == 1:  # 익은 토마토인 경우
            q.append((i, j))  # 큐에 (행, 열) 추가

while q:
    x, y = q.popleft() 
    
    # 현재 토마토의 주변 4개 방향 탐색
    for dx, dy in directions:
        nx, ny = x + dx, y + dy 
        
        # 새로운 좌표가 배열의 범위 내에 있는지 체크
        if 0 <= nx < n and 0 <= ny < m:
            # 익지 않은 토마토인 경우
            if arr[nx][ny] == 0:  
                # 현재 토마토의 날짜 + 1로 익은 날짜를 설정
                arr[nx][ny] = arr[x][y] + 1  
                q.append((nx, ny))

# 결과 확인: 모든 토마토가 익었는지 확인
max_days = 0  # 최대 날짜를 저장할 변수
for i in range(n):  # 행
    for j in range(m):  # 열
        if arr[i][j] == 0:  # 익지 않은 토마토가 남아있는 경우
            print(-1)  # 모든 토마토가 익지 못했음을 출력
            exit(0)  
        max_days = max(max_days, arr[i][j])  # 최대 날짜 갱신

# 최종 결과 출력: 시작 상태를 제외하므로 1을 빼줍니다.
print(max_days - 1)  
```