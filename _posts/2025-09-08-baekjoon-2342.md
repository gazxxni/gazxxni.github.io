---
layout: post
title: "[백준] 2342번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2342"]
---

## 문제 링크
[https://www.acmicpc.net/problem/2342](https://www.acmicpc.net/problem/2342)

---

## 풀이

### 풀이 핵심 로직
이 문제는 두 발(왼발과 오른발)을 사용하여 주어진 발판으로 이동할 때의 최소 이동 비용을 구하는 문제입니다. DP(동적 계획법)를 사용하여 각 발의 위치에 따른 최소 비용을 기록하고, 현재 발판에 도달하기 위해 두 발의 가능한 위치에서의 비용을 갱신합니다.

### 동작 과정
1. 입력으로 주어진 발판을 읽고 마지막 요소(0)를 제거하여 처리합니다. 예를 들어, 입력이 `1 2 3 0`이라면 `arr`는 `[1, 2, 3]`가 됩니다.
2. `dp` 배열을 초기화합니다. `dp[i][l][r]`는 `i` 번째 발판에 도달하기 위해 왼발이 `l` 위치에 있고 오른발이 `r` 위치에 있을 때의 최소 비용을 저장합니다.
3. 각 발판에 대해 현재 발판의 위치와 왼발, 오른발의 위치를 고려하여 다음 발판에 도달하기 위한 비용을 계산합니다. `move_cost` 함수는 현재 발의 위치에서 다음 발판으로 이동하는 비용을 계산합니다.
4. 마지막으로 모든 가능한 발의 위치에 대해 최종 비용을 구하고, 그 중 최소 비용을 출력합니다.

예시 입력으로 `1 2 3 0`가 주어졌을 때의 단계별 설명:
- 초기 비용은 `dp[0][0][0] = 0`으로 설정.
- 첫 번째 발판(1)에 도달하기 위해 왼발이 0, 오른발이 0에서 시작하여 이동 비용을 갱신.
- 두 번째 발판(2)으로 이동할 때는 첫 번째 발판에서의 왼발 또는 오른발의 위치에 따라 비용을 갱신.
- 세 번째 발판(3)도 같은 방식으로 처리.
- 모든 발판을 처리한 후, 최종적으로 최소 비용을 출력.

### 시간 복잡도
O(N) - 여기서 N은 발판의 개수입니다. 각 발판에 대해 최대 25(5x5) 가능한 발 위치 조합을 고려하므로 전체 시간 복잡도는 O(N * 5 * 5)로 간주할 수 있습니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

arr = list(map(int, input().split()))
arr.pop() 
l_arr = len(arr)

INF = float('inf')
dp = [[[INF]*5 for _ in range(5)] for _ in range(2)]
dp[0][0][0] = 0

def move_cost(from_pos, to_pos):
    if from_pos == to_pos:
        return 1
    if from_pos == 0:
        return 2
    if abs(from_pos - to_pos) == 2: 
        return 4
    return 3

for i in range(l_arr):
    cur = i % 2
    nxt = (i + 1) % 2

    for l in range(5):
        for r in range(5):
            dp[nxt][l][r] = INF
    target = arr[i]
    for l in range(5):
        for r in range(5):
            if dp[cur][l][r] == INF:
                continue

            if target != r:
                cost = dp[cur][l][r] + move_cost(l, target)
                dp[nxt][target][r] = min(dp[nxt][target][r], cost)

            if target != l:
                cost = dp[cur][l][r] + move_cost(r, target)
                dp[nxt][l][target] = min(dp[nxt][l][target], cost)

ans = INF
for l in range(5):
    for r in range(5):
        ans = min(ans, dp[l_arr%2][l][r])

print(ans)

```