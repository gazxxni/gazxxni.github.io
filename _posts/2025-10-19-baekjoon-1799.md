---
layout: post
title: "[백준] 1799번 (Python)"
date: 2025-10-19
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1799"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1799](https://www.acmicpc.net/problem/1799)

---

## 풀이

### 풀이 핵심 로직
이 문제는 체스판 위에 비숍을 최대한 많이 배치하는 문제로, 비숍은 같은 대각선에 있는 칸에 서로 배치할 수 없다. 입력된 그래프에서 흰색과 검은색 칸을 구분하여 각각에 대해 비숍을 최대한 배치하는 방법을 백트래킹을 통해 탐색한다.

### 동작 과정
1. **입력 처리**: n x n 크기의 그래프를 입력받고, 비숍을 놓을 수 있는 칸(값이 1인 칸)을 흰색과 검은색으로 분류한다.
2. **백트래킹 함수 정의**: `solve(cell_list, index)` 함수를 정의하여 주어진 칸 리스트에서 비숍을 배치할 수 있는 최대 수를 계산한다.
   - `index`가 칸 리스트의 길이와 같으면 더 이상 확인할 칸이 없으므로 0을 반환한다.
   - 현재 칸에 비숍을 놓지 않는 경우와 놓는 경우를 각각 탐색한다.
   - 비숍을 놓는 경우, 해당 칸의 대각선이 사용 중인지 확인하고, 사용하지 않으면 비숍을 놓고 재귀 호출을 한다.
   - 비숍을 놓은 후에는 대각선 정보를 다시 해제하여 다른 경로에서 사용할 수 있도록 한다.
3. **흰색과 검은색 칸에 대해 각각 백트래킹 수행**: 흰색 칸에 대해서 먼저 백트래킹을 수행하고, 검은색 칸에 대해서도 다시 대각선 정보를 초기화한 후 백트래킹을 수행한다.
4. **결과 출력**: 흰색 칸과 검은색 칸 각각에서 얻은 최대 비숍 수를 더하여 출력한다.

#### 예시 입력
```
4
0 1 0 1
1 1 1 1
0 1 0 1
1 1 1 1
```
1. 입력으로 주어진 그래프를 처리하면 흰색 칸과 검은색 칸의 위치가 다음과 같이 나뉜다:
   - 흰색 칸: (0, 1), (1, 0), (1, 2), (2, 1), (3, 0), (3, 2)
   - 검은색 칸: (0, 3), (1, 1), (1, 3), (2, 3), (3, 1)
2. `solve` 함수가 흰색 칸을 기준으로 호출되고, 최대 비숍 수를 계산하여 예를 들어 3이 반환된다.
3. 이후 검은색 칸에 대해서도 `solve`가 호출되어 최대 비숍 수가 3이 반환된다.
4. 최종적으로 두 결과를 더하여 6을 출력한다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(2^(n^2))로, 비숍을 놓을 수 있는 칸이 최대 n^2일 때 모든 조합을 탐색할 수 있기 때문이다. 그러나 실제로는 대각선 제약 조건으로 인해 많은 경우가 가지치기되어 효율적인 탐색이 이루어진다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
graph = [list(map(int, input().split())) for _ in range(n)]

white_cells = []
black_cells = []
for r in range(n):
    for c in range(n):
        if graph[r][c] == 1:
            # (행 + 열)이 짝수이면 '흰색' 칸으로 간주
            if (r + c) % 2 == 0:
                white_cells.append((r, c))
            else:
                black_cells.append((r, c))

# 대각선 방문 여부를 체크
# (r-c) 대각선 (인덱스: r - c + n - 1 사용)
diag1 = [False] * (2 * n - 1)
# (r+c) 대각선 (인덱스: r + c 사용)
diag2 = [False] * (2 * n - 1)

def solve(cell_list, index):
    # 리스트의 모든 칸을 다 확인했다면 0 반환
    if index == len(cell_list):
        return 0

    # 현재 확인할 칸의 좌표
    r, c = cell_list[index]

    # 현재 칸(r, c)에 비숍을 놓지 않는 경우
    # 이 칸을 건너뛰고, 다음 칸(index + 1)부터 탐색
    res = solve(cell_list, index + 1)

    # 현재 칸(r, c)에 비숍을 놓는 경우
    diag1_idx = r - c + n - 1
    diag2_idx = r + c

    # 두 대각선이 비었는지 확인
    if not diag1[diag1_idx] and not diag2[diag2_idx]:
        diag1[diag1_idx] = True
        diag2[diag2_idx] = True

        # 현재 칸에 1개를 놓았으니, 1 + 다음 칸(index+1)부터 탐색
        placed_count = 1 + solve(cell_list, index + 1)

        # 사용 후 두 대각선 사용 해제
        diag1[diag1_idx] = False
        diag2[diag2_idx] = False
        
        # 놓지 않은 경우(res)와 놓은 경우(placed_count) 중 더 큰 값으로 res를 갱신
        res = max(res, placed_count)

    return res

# 흰색 칸들에 대해 백트래킹 실행
ans_white = solve(white_cells, 0)

# 검은색 칸들에 대해 백트래킹 실행
# 검은색 칸 탐색을 위해 대각선 배열(diag1, diag2)을 다시 초기화
diag1 = [False] * (2 * n - 1)
diag2 = [False] * (2 * n - 1)
ans_black = solve(black_cells, 0)

print(ans_white + ans_black)
```