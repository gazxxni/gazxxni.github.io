---
layout: post
title: "[백준] 11660번 (Python)"
date: 2025-02-20
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "11660"]
---

## 문제 링크
[https://www.acmicpc.net/problem/11660](https://www.acmicpc.net/problem/11660)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 2차원 배열의 구간 합을 효율적으로 계산하기 위해 누적 합 배열(dp)을 사용하는 것입니다. 이를 통해 특정 영역의 합을 O(1) 시간에 계산할 수 있으며, 이 과정에서 각 요소의 합을 이전의 누적 합을 활용하여 빠르게 구할 수 있습니다.

### 동작 과정
1. **입력 받기**: n x n 크기의 격자와 m 개의 쿼리를 입력받습니다.
2. **누적 합 배열(dp) 계산**:
   - `dp[i][j]`는 (1, 1)부터 (i, j)까지의 합을 저장합니다.
   - 각 요소는 다음과 같은 관계로 업데이트됩니다:
     ```
     dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1] + graph[i-1][j-1]
     ```
   - 이 관계는 현재 위치의 값을 더하고, 상단과 좌측의 합을 더한 후 중복 계산된 부분을 빼는 방식으로 동작합니다.
3. **쿼리 처리**:
   - 각 쿼리 `(x1, y1)`에서 `(x2, y2)`까지의 합을 `dp` 배열을 이용하여 계산합니다:
     ```
     a = dp[x2][y2] - dp[x1-1][y2] - dp[x2][y1-1] + dp[x1-1][y1-1]
     ```
   - 이 식은 요청한 사각형의 합을 빠르게 구하는 방법으로, x1과 y1이 1부터 시작하므로 배열 인덱스 조정이 필요합니다.
4. **출력**: 각 쿼리의 결과를 출력합니다.

**예시 입력**:
```
4 2
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16
1 1 2 2
2 2 4 4
```
**단계별 설명**:
- 입력된 격자를 기반으로 dp 배열을 구성한 후, 각 쿼리에 대해 합을 계산하여 출력합니다.
- 첫 번째 쿼리 `(1, 1)`에서 `(2, 2)`까지의 합은 `1 + 2 + 5 + 6 = 14`로 계산됩니다.
- 두 번째 쿼리 `(2, 2)`에서 `(4, 4)`까지의 합은 `6 + 7 + 10 + 11 + 14 + 15 + 16 = 79`로 계산됩니다.

### 시간 복잡도
- 누적 합 배열을 만드는 과정은 O(n^2)입니다.
- 각 쿼리를 처리하는 과정은 O(1)입니다.
- 따라서 전체 시간 복잡도는 O(n^2 + m)입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n, m = map(int, input().split())
graph = [list(map(int, input().split())) for _ in range(n)]
dp = [[0]*(n+1) for i in range(n+1)]


for i in range(1, n+1):
    for j in range(1, n+1):
        dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1] + graph[i-1][j-1]


for _ in range(m):
    x1, y1, x2, y2 = map(int, input().split())
    a = dp[x2][y2] - dp[x1-1][y2] - dp[x2][y1-1] + dp[x1-1][y1-1]
    print(a)
```