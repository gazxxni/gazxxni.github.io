---
layout: post
title: "[백준] 2252번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2252"]
---

## 문제 링크
[https://www.acmicpc.net/problem/2252](https://www.acmicpc.net/problem/2252)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 수업의 선후 관계를 기반으로, 수업들을 적절한 순서로 나열하는 "위상 정렬"을 적용합니다. 그래프의 노드(수업)와 간선(선후 관계)을 통해 진입 차수를 계산하고, 진입 차수가 0인 노드를 큐에 추가하여 순차적으로 처리합니다. 이를 통해 모든 수업의 순서를 결정할 수 있습니다.

### 동작 과정
1. **입력 처리**: 먼저, 수업의 수 `n`과 선후 관계의 수 `m`을 입력받습니다. 그 다음, `n+1` 크기의 그래프와 진입 차수 배열을 초기화합니다.
   
2. **그래프 구성**: 선후 관계를 입력받아 그래프를 구성하고, 각 노드의 진입 차수를 업데이트합니다. 예를 들어, 입력이 `3 2`와 `1 2`, `1 3`이라면 그래프는 `1 -> 2`, `1 -> 3` 형태가 되고, 진입 차수는 `[0, 0, 1, 1]`이 됩니다.

3. **위상 정렬 실행**: 진입 차수가 0인 노드를 큐에 추가합니다. 큐에서 노드를 꺼내고, 그 노드와 연결된 모든 노드의 진입 차수를 감소시킵니다. 만약 진입 차수가 0이 된 노드가 있다면 큐에 추가합니다. 이 과정을 큐가 빌 때까지 반복합니다.

4. **결과 출력**: 최종적으로 결과 리스트를 출력합니다. 예시 입력에 대해 위상 정렬을 수행하면 `1 2 3` 또는 `1 3 2`와 같은 결과가 나올 수 있습니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n + m)입니다. 여기서 `n`은 노드의 수(수업의 수), `m`은 간선의 수(선후 관계의 수)로, 그래프의 모든 노드와 간선을 한 번씩 방문하기 때문입니다.

---

## 코드
```python
import sys
from collections import deque

input = sys.stdin.readline

n, m = map(int, input().split())

graph = [[] for _ in range(n + 1)]
indegree = [0] * (n + 1)

for _ in range(m):
    a, b = map(int, input().split())
    graph[a].append(b)
    indegree[b] += 1

def topological_sort():
    result = []
    q = deque()

    for i in range(1, n + 1):
        if indegree[i] == 0:
            q.append(i)

    while q:
        node = q.popleft()
        result.append(node)

        for neighbor in graph[node]:
            indegree[neighbor] -= 1
            if indegree[neighbor] == 0:
                q.append(neighbor)

    return result

ans = topological_sort()
print(*ans)
```