---
layout: post
title: "[백준] 10870번 피보나치 수 5 (Python)"
date: 2025-12-09
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "10870", 수학, 구현]
---

## 문제 링크
[https://www.acmicpc.net/problem/10870](https://www.acmicpc.net/problem/10870)

---

## 문제
피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.

이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다.

n=17일때 까지 피보나치 수를 써보면 다음과 같다.

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597

n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.

---

## 입력
첫째 줄에 n이 주어진다. n은 20보다 작거나 같은 자연수 또는 0이다.

---

## 출력
첫째 줄에 n번째 피보나치 수를 출력한다.

---

## 성능 요약
메모리: 108384 KB, 시간: 104 ms

---

## 풀이

### 풀이 핵심 로직
피보나치 수열은 재귀적인 성질을 가지고 있으며, 각 수는 그 이전 두 수의 합으로 정의됩니다. 문제에서는 n번째 피보나치 수를 구해야 하므로, 동적 프로그래밍을 사용하여 이전 계산 결과를 저장하고 재사용하는 방식으로 효율적으로 해결합니다. 이를 통해 O(n) 시간 복잡도로 n번째 피보나치 수를 계산할 수 있습니다.

### 동작 과정
1. 입력으로 n이 주어진다고 가정합니다. 예를 들어 n = 5인 경우를 살펴보겠습니다.
2. 피보나치 수는 다음과 같이 정의됩니다:
   - F(0) = 0
   - F(1) = 1
   - F(2) = 1
   - F(3) = 2
   - F(4) = 3
   - F(5) = 5
3. 코드에서는 dp 배열을 생성하여 각 인덱스에 해당하는 피보나치 수를 저장합니다.
4. n이 5일 때, dp 배열은 다음과 같이 업데이트됩니다:
   - dp[0] = 0
   - dp[1] = 1
   - dp[2] = 1
   - dp[3] = dp[2] + dp[1] = 2
   - dp[4] = dp[3] + dp[2] = 3
   - dp[5] = dp[4] + dp[3] = 5
5. 최종적으로 dp[5] = 5를 출력하게 됩니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n)입니다. 피보나치 수를 계산하는 과정에서 dp 배열을 한 번 순회하기 때문에 입력 n에 비례하는 시간만 소요됩니다.

---

## 코드
```python
n = int(input())

if n > 2:
    dp = [0] * (n + 1)
    dp[1] = 1
    dp[2] = 1
    dp[2] = 2

    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
        
    print(dp[n - 1])
        
elif n == 2 or n == 1:
    print(1)

else:
    print(0)
```