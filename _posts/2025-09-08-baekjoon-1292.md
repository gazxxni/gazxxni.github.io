---
layout: post
title: "[백준] 1292번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1292"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1292](https://www.acmicpc.net/problem/1292)

---

## 풀이

### 풀이 핵심 로직
이 문제는 1부터 1000까지의 수를 특정 규칙에 따라 나열한 후, 주어진 두 정수 a와 b에 해당하는 구간의 합을 구하는 문제입니다. 수는 1이 1번, 2가 2번, 3이 3번, ... 이렇게 반복적으로 나열됩니다. 그 후, a와 b를 인덱스로 하여 해당 구간의 합을 계산합니다.

### 동작 과정
1. 사용자로부터 두 정수 a와 b를 입력받습니다. 예를 들어, 입력이 `3 7`이라면 a는 3, b는 7입니다.
2. `arr` 리스트를 초기화하고, `num` 변수를 1로 설정합니다. `arr`의 첫 번째 요소는 0으로 두고, 이후에 수를 추가할 준비를 합니다.
3. `while` 루프를 통해 `num`이 1001이 될 때까지 반복합니다.
   - 내부의 `for` 루프에서 `num`의 값만큼 `arr`에 `num`을 추가합니다. 즉, 1은 1번, 2는 2번, 3은 3번, ... 이렇게 진행됩니다.
   - `num`을 1씩 증가시키며 이 과정을 반복합니다.
4. 모든 수가 추가된 후, `sum(arr[a:b+1])`를 통해 인덱스 a부터 b까지의 합을 계산하여 출력합니다.
5. 예를 들어, `arr` 리스트가 [0, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4, ...]가 되면, `sum(arr[3:8])`은 `2 + 3 + 3 + 4 + 4`로 16이 됩니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n^2)입니다. 이는 `num`이 1부터 1000까지 증가할 때마다 내부의 `for` 루프가 `num`의 값만큼 반복되기 때문입니다. 최악의 경우, 모든 수를 추가하는 데 약 500500번의 반복이 발생하게 됩니다.

---

## 코드
```python
a, b = map(int, input().split())

arr = [0]
num = 1

while True:
    if num == 1001:
        break
    
    for _ in range(num):
        arr.append(num)
        
    num += 1

a = sum(arr[a:b+1])
print(a)
```