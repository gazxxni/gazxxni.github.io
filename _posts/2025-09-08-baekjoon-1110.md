---
layout: post
title: "[백준] 1110번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1110"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1110](https://www.acmicpc.net/problem/1110)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 숫자에서 '사이클'을 생성하여 원래 숫자로 돌아올 때까지의 반복 횟수를 구하는 것입니다. 각 반복에서 숫자를 두 자리로 나누고, 두 자리의 합의 일의 자리 숫자를 구하여 새로운 숫자를 생성하고, 이 과정을 반복합니다.

### 동작 과정
1. 입력으로 숫자 `n`을 받습니다. 예를 들어, `n = 26`이라고 가정합니다.
2. `num` 변수에 `n`을 저장하고, `cnt`를 0으로 초기화합니다 (반복 횟수를 세기 위함).
3. 무한 루프를 시작합니다.
   - `a = num // 10`: 26을 10으로 나눈 몫을 구하여 `a = 2`가 됩니다.
   - `b = num % 10`: 26을 10으로 나눈 나머지를 구하여 `b = 6`이 됩니다.
   - `c = (a + b) % 10`: `a`와 `b`를 더한 후 10으로 나눈 나머지를 구하여 `c = (2 + 6) % 10 = 8`이 됩니다.
   - 새로운 숫자는 `num = (b * 10) + c`, 즉 `num = (6 * 10) + 8 = 68`로 갱신됩니다.
4. `cnt`를 1 증가시킵니다.
5. `num`이 원래의 `n`과 같아질 때까지 3-4 단계를 반복합니다.
6. `num`이 다시 26이 되면 루프를 종료하고 `cnt`를 출력합니다. 이 경우, 반복 횟수는 4가 됩니다.

### 시간 복잡도
이 알고리즘은 주어진 숫자가 두 자리 수이므로, 최대 60번의 반복이 필요할 수 있습니다. 따라서 시간 복잡도는 O(1)로 상수 시간 복잡도로 볼 수 있습니다.

---

## 코드
```python
n = int(input())
num = n
cnt = 0

while True:
    a = num // 10
    b = num % 10
    c = (a + b) % 10
    num = (b * 10) + c
    
    cnt += 1
    if num == n:
        break
    
print(cnt)
```