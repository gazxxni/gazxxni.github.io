---
layout: post
title: "[백준] 12015번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "12015"]
---

## 문제 링크
[https://www.acmicpc.net/problem/12015](https://www.acmicpc.net/problem/12015)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 수열에서 가장 긴 증가하는 부분 수열(LIS)의 길이를 찾는 문제입니다. 이 코드는 이진 탐색을 사용하여 효율적으로 LIS를 구축하며, 각 원소가 들어갈 위치를 찾아 업데이트하는 방식으로 O(n log n) 시간 복잡도로 문제를 해결합니다.

### 동작 과정
예시 입력: `6` (수열의 길이), `10 20 10 30 20 50`

1. `n = 6`으로 입력받고, `arr`는 `[10, 20, 10, 30, 20, 50]`입니다.
2. 빈 리스트 `brr`를 생성하여 LIS를 저장할 준비를 합니다.
3. 첫 번째 원소 `10`을 처리합니다:
   - `brr`가 비어있으므로 `brr`에 `10`을 추가합니다. 현재 `brr = [10]`.
4. 두 번째 원소 `20`을 처리합니다:
   - `20`은 현재 `brr`의 마지막 원소 `10`보다 크므로 `brr`에 추가합니다. 현재 `brr = [10, 20]`.
5. 세 번째 원소 `10`을 처리합니다:
   - `10`의 위치를 `search` 함수로 찾아 `brr`에서 `10`의 자리에 `10`을 대체합니다. 현재 `brr = [10, 20]`.
6. 네 번째 원소 `30`을 처리합니다:
   - `30`은 `20`보다 크므로 추가합니다. 현재 `brr = [10, 20, 30]`.
7. 다섯 번째 원소 `20`을 처리합니다:
   - `20`의 위치를 찾아 `brr`에서 `20`의 자리에 `20`을 대체합니다. 현재 `brr = [10, 20, 30]`.
8. 여섯 번째 원소 `50`을 처리합니다:
   - `50`은 `30`보다 크므로 추가합니다. 현재 `brr = [10, 20, 30, 50]`.
9. 모든 원소를 처리한 후, `brr`의 길이를 출력합니다. 결과는 `4`입니다.

### 시간 복잡도
O(n log n)  
- `n`은 입력 수열의 길이이며, 각 원소에 대해 이진 탐색(`search` 함수)의 시간 복잡도 O(log n)과 리스트에 원소를 추가하는 시간 복잡도 O(1)을 고려할 때 전체적인 시간 복잡도는 O(n log n)입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
arr = list(map(int, input().split()))

brr = []

def search(arr, x):
    st, ed = 0, len(arr)
    while st < ed:
        mid = (st + ed) // 2
        if arr[mid] < x:
            st = mid + 1
        else:
            ed = mid
    return st

for num in arr:
    if not brr or num > brr[-1]:
        brr.append(num)
    else:
        idx = search(brr, num)
        brr[idx] = num

print(len(brr))

```