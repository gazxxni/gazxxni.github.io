---
layout: post
title: "[백준] 1676번 (Python)"
date: 2024-06-24
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1676"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1676](https://www.acmicpc.net/problem/1676)

---

## 풀이

### 풀이 핵심 로직
주어진 문제는 n! (n 팩토리얼)의 끝에 있는 0의 개수를 구하는 것입니다. 0의 개수는 10의 배수에 의해 결정되며, 10은 2와 5의 곱으로 이루어져 있습니다. 그러나 n!에서 2의 개수는 항상 5의 개수보다 많기 때문에, 0의 개수는 5의 개수에 의해 결정됩니다. 따라서 n!에서 5의 배수를 세는 방식으로 0의 개수를 구합니다.

### 동작 과정
1. 입력으로 주어진 n을 읽습니다.
2. cnt 변수를 0으로 초기화합니다. 이 변수는 n!의 끝에 있는 0의 개수를 세기 위해 사용됩니다.
3. n이 0보다 큰 동안 반복합니다:
   - n을 5로 나눈 몫을 cnt에 더합니다. (즉, n//5)
   - n을 5로 나누어 n을 갱신합니다. (즉, n//=5)
4. n이 0이 되면 반복이 종료되고, cnt를 출력합니다.

예시 입력으로 n=25라고 가정해 보겠습니다:
- 첫 번째 반복: n=25, cnt=0 → cnt += 25//5 = 5 → n = 25//5 = 5
- 두 번째 반복: n=5, cnt=5 → cnt += 5//5 = 1 → n = 5//5 = 1
- 세 번째 반복: n=1, cnt=6 → cnt += 1//5 = 0 → n = 1//5 = 0
- 반복 종료 후 cnt는 6이므로, 25!의 끝에 있는 0의 개수는 6입니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(log n)입니다. 이는 n이 5로 나누어질 때마다 n이 감소하기 때문에, n이 5의 거듭제곱에 도달할 때까지 반복하므로 로그 시간 복잡도를 가집니다.

---

## 코드
```python
import sys

n=int(input())
cnt=0

while n>0:
    cnt+=n//5
    n//=5

print(cnt)

# a=[]

# def factorial(n):
#     if n == 0 or n == 1:
#         return 1
#     else:
#         return n * factorial(n-1)

# a=factorial(n)
# a.reverse()

# for i in a:
#     if i==0:
#         cnt+=1
```