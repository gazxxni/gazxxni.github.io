---
layout: post
title: "[백준] 5525번 (Python)"
date: 2024-11-23
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "5525"]
---

## 문제 링크
[https://www.acmicpc.net/problem/5525](https://www.acmicpc.net/problem/5525)

---

## 풀이

### 풀이 핵심 로직
문제는 문자열에서 "IOI" 패턴이 n번 반복되는 경우의 수를 찾는 것입니다. 이 코드는 문자열을 순회하면서 "IOI" 패턴을 찾고, 연속으로 n번 발견될 때마다 카운트를 증가시킵니다. 카운트를 증가시키면서도, 다음 패턴을 찾기 위해 카운트를 적절히 조정하여 중복 카운트를 방지합니다.

### 동작 과정
1. **입력 예시**:
   ```
   1
   13
   IOIOIOIOIOI
   ```

2. **초기화**:
   - `n = 1`, `m = 13`, `s = "IOIOIOIOIOI"`
   - `p = "IOI"`, `cnt = 0`, `i = 0`, `ans = 0`

3. **반복 과정**:
   - `i = 0`: `s[0:3]` = "IOI" → `cnt` 증가 (1), `i`를 2로 이동
   - `i = 2`: `s[2:5]` = "IOI" → `cnt` 증가 (2), `ans` 증가 (1), `cnt`를 1로 감소, `i`를 4로 이동
   - `i = 4`: `s[4:7]` = "IOI" → `cnt` 증가 (2), `ans` 증가 (2), `cnt`를 1로 감소, `i`를 6으로 이동
   - `i = 6`: `s[6:9]` = "IOI" → `cnt` 증가 (2), `ans` 증가 (3), `cnt`를 1로 감소, `i`를 8로 이동
   - `i = 8`: `s[8:11]` = "IOI" → `cnt` 증가 (2), `ans` 증가 (4), `cnt`를 1로 감소, `i`를 10으로 이동
   - `i = 10`: `s[10:13]` = "I" (길이 부족) → 루프 종료

4. **결과**:
   - 최종 `ans` 값은 4로 출력됨.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(m)입니다. 문자열을 한 번 순회하면서 필요한 연산을 수행하므로, 입력 문자열의 길이에 비례하는 선형 시간 복잡도를 가집니다.

---

## 코드
```python
import sys

input=sys.stdin.readline

n = int(input().strip())
m = int(input().strip())
s = input().strip()

p = 'IOI'

cnt = i = ans = 0

while i < (m - 1):   # 입력받은 S의 길이만큼 반복
    if s[i : i+3] == p:  # 현재 반복되는 문자열이 'IOI'인가 ?
        i += 2       # 그렇다면 다음에도 반복하는지 확인하기 위해 i+2
        cnt += 1     # 'IOI' 반복 수 저장
        if cnt == n:     # 반복 수 cnt가 우리가 원하는 N과 동일한가 ?
            ans += 1     # 그렇다면 Pn을 찾은 것이므로 answer + 1
            cnt -= 1     # 지금 Pn의 일부를 포함해서 또다른 Pn이 나올 수 있으므로 
                         # cnt를 초기화하지 않고 -1만 함

    else:
        i += 1    # 'IOI'가 아니면 다음 인덱스로 이동
        cnt = 0   # cnt 초기화

print(ans)

```