---
layout: post
title: "[백준] 1074번 (Python)"
date: 2024-11-23
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1074"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1074](https://www.acmicpc.net/problem/1074)

---

## 풀이

### 풀이 핵심 로직
이 문제는 Z-Order Curve(또는 Morton Order)를 사용하여 2차원 배열의 특정 좌표(r, c)가 Z 순서에서 몇 번째로 방문되는지를 계산하는 문제입니다. 배열의 크기를 2의 거듭제곱으로 표현하고, 각 사분면의 크기를 이용하여 좌표를 사분면으로 나누며, 해당 사분면의 시작값을 더해가며 최종 결과를 계산합니다.

### 동작 과정
1. 입력으로 n, r, c를 받습니다. 여기서 n은 배열의 크기(2^n x 2^n), r과 c는 찾고자 하는 좌표입니다.
2. n이 0이 될 때까지 반복합니다. 매 반복마다 n을 1씩 줄여가며 아래의 조건을 확인합니다.
   - r, c 모두 2^n보다 작으면 좌표가 제2사분면에 속하므로 0을 더합니다. (변경 없음)
   - r는 2^n보다 작고 c는 2^n 이상이면 제1사분면에 속하므로 1을 더하고 c에서 2^n을 뺍니다.
   - r는 2^n 이상이고 c는 2^n보다 작으면 제3사분면에 속하므로 2를 더하고 r에서 2^n을 뺍니다.
   - 나머지 경우는 제4사분면에 속하므로 3을 더하고 r과 c에서 각각 2^n을 뺍니다.
3. 최종적으로 ans를 출력합니다.

**예시 입력:**
```
2 3 1
```
**단계별 설명:**
- n = 2, r = 3, c = 1
  - 2^n = 4 (2의 2승)
  - r >= 4 (3 >= 4는 거짓), c < 4 (1 < 4는 참) → 제4사분면
  - ans += 3 * (4) = 12, r -= 4 (3-4 = -1), c -= 4 (1-4 = -3)
  
- n = 1, r = -1, c = -3
  - 2^n = 2 (2의 1승)
  - r < 2 (−1 < 2는 참), c < 2 (−3 < 2는 참) → 제2사분면
  - ans += 0 * (2) = 0 (변경 없음)

- n = 0, r = -1, c = -3
  - 2^n = 1 (2의 0승)
  - r < 1 (−1 < 1은 참), c < 1 (−3 < 1은 참) → 제2사분면
  - ans += 0 * (1) = 0 (변경 없음)

최종적으로 ans = 12 + 0 + 0 = 12가 출력됩니다.

### 시간 복잡도
이 알고리즘은 n의 크기만큼 반복하므로 O(n)입니다. n은 2의 거듭제곱에 따라 제한되므로, 최대 시간 복잡도는 O(log N)으로 볼 수 있습니다.

---

## 코드
```python
import sys

n, r, c = map(int, input().split()) 

ans = 0 

while n != 0:  # 배열 크기를 줄여가면서 (r, c)의 위치를 찾는 루프
    n -= 1  # 배열을 4개의 사분면으로 나누기 위해 n을 1씩 감소시킴
    
    if r < 2 ** n and c < 2 ** n:  # 제2사분면
        ans += (2 ** n) * (2 ** n) * 0  # 제2사분면의 시작값은 0이므로 더하지 않음

    elif r < 2 ** n and c >= 2 ** n:  # 제1사분면
        ans += (2 ** n) * (2 ** n) * 1  # 제1사분면의 시작값은 1
        c -= (2 ** n)  # 현재 위치를 제1사분면으로 이동했으므로 열 인덱스를 줄임

    elif r >= 2 ** n and c < 2 ** n:  # 제3사분면 
        ans += (2 ** n) * (2 ** n) * 2  # 제3사분면의 시작값은 2
        r -= (2 ** n)  # 현재 위치를 제3사분면으로 이동했으므로 행 인덱스를 줄임

    else:  # 제4사분면
        ans += (2 ** n) * (2 ** n) * 3  # 제4사분면의 시작값은 3
        r -= (2 ** n)  # 현재 위치를 제4사분면으로 이동했으므로 행 인덱스를 줄임
        c -= (2 ** n)  # 열 인덱스도 줄여서 새로운 좌표로 설정

print(ans)  # 최종적으로 Z-order에서 (r, c) 좌표에 해당하는 값을 출력

```