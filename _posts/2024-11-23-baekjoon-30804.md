---
layout: post
title: "[백준] 30804번 (Python)"
date: 2024-11-23
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "30804"]
---

## 문제 링크
[https://www.acmicpc.net/problem/30804](https://www.acmicpc.net/problem/30804)

---

## 풀이

### 풀이 핵심 로직
이 문제는 슬라이딩 윈도우 기법을 사용하여 주어진 과일 카테고리 배열에서 두 가지 고유한 과일 종류만 포함하는 가장 긴 부분 배열의 길이를 찾는 것입니다. 슬라이딩 윈도우를 통해 오른쪽 포인터를 확장하면서 과일 종류를 세고, 두 가지를 초과할 경우 왼쪽 포인터를 이동하여 조건을 만족하도록 조정합니다.

### 동작 과정
예를 들어, 입력이 다음과 같다고 가정합니다:
```
7
1 2 1 2 3 1 2
```

1. 초기 상태: `n = 7`, `fruit_category = [1, 2, 1, 2, 3, 1, 2]`, `left = 0`, `ans = 0`, `cnt = {}`, `distinct_cnt = 0`.
2. `right = 0`: 과일 종류 1을 추가 → `cnt = {1: 1}`, `distinct_cnt = 1` → `ans = max(0, 1 - 0 + 1) = 1`.
3. `right = 1`: 과일 종류 2를 추가 → `cnt = {1: 1, 2: 1}`, `distinct_cnt = 2` → `ans = max(1, 2 - 0 + 1) = 2`.
4. `right = 2`: 과일 종류 1을 추가 → `cnt = {1: 2, 2: 1}`, `distinct_cnt = 2` → `ans = max(2, 2 - 0 + 1) = 3`.
5. `right = 3`: 과일 종류 2를 추가 → `cnt = {1: 2, 2: 2}`, `distinct_cnt = 2` → `ans = max(3, 3 - 0 + 1) = 4`.
6. `right = 4`: 과일 종류 3을 추가 → `cnt = {1: 2, 2: 2, 3: 1}`, `distinct_cnt = 3`, 이때 고유 과일 수가 2를 초과하므로 왼쪽 포인터를 이동.
7. 왼쪽 포인터 이동: `left = 1`, 과일 종류 1의 개수 감소 → `cnt = {1: 1, 2: 2, 3: 1}`, `distinct_cnt = 3`.
8. 왼쪽 포인터 이동: `left = 2`, 과일 종류 1의 개수 감소 → `cnt = {1: 0, 2: 2, 3: 1}`, `distinct_cnt = 2` (과일 종류 1 제거) → `ans = max(4, 4 - 2 + 1) = 4`.
9. 이후 `right`가 계속 진행되면서 적절히 왼쪽 포인터를 이동하여 고유 과일 수를 유지하며 최대 길이를 업데이트.
10. 최종적으로 `ans`는 5가 되어 출력.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n)입니다. 이는 각 과일 종류를 한 번씩 방문하고, 왼쪽 포인터와 오른쪽 포인터가 배열을 한 번만 순회하기 때문입니다.

---

## 코드
```python
from collections import defaultdict

n = int(input())

fruit_category = list(map(int, input().split()))

ans = 0 
left = 0  # 슬라이딩 윈도우의 왼쪽 끝을 가리키는 포인터
cnt = {}  # 각 과일의 카테고리별로 몇 개가 있는지 저장하는 딕셔너리
distinct_cnt = 0  # 현재 슬라이딩 윈도우 내에 있는 고유한 과일 종류의 수

# 슬라이딩 윈도우의 오른쪽 끝을 이동하면서 처리
for right in range(n):
    # 현재 과일이 이미 딕셔너리에 있다면, 그 과일의 개수를 증가시킴
    if fruit_category[right] in cnt:
        cnt[fruit_category[right]] += 1
    # 그렇지 않다면, 새로운 과일 종류로 추가하고, 고유 과일 종류의 수 증가
    else:
        cnt[fruit_category[right]] = 1
        distinct_cnt += 1

    # 고유한 과일 종류가 2개를 초과하면, 조건을 만족할 때까지 왼쪽 포인터를 이동
    while distinct_cnt > 2:
        # 왼쪽 포인터가 가리키는 과일의 개수를 1 줄임
        cnt[fruit_category[left]] -= 1
        # 만약 그 과일의 개수가 0이 되면, 딕셔너리에서 해당 과일을 제거하고 고유 과일 수 감소
        if cnt[fruit_category[left]] == 0:
            del cnt[fruit_category[left]]
            distinct_cnt -= 1
        left += 1     # 왼쪽 포인터를 1칸 이동
    
    # 현재 슬라이딩 윈도우 크기 (right - left + 1)와 지금까지의 최대 길이를 비교해 최대값을 업데이트
    ans = max(ans, right - left + 1)

print(ans)


```