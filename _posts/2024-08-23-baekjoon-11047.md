---
layout: post
title: "[백준] 11047번 (Python)"
date: 2024-08-23
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "11047"]
---

## 문제 링크
[https://www.acmicpc.net/problem/11047](https://www.acmicpc.net/problem/11047)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 동전의 가치가 큰 것부터 사용하여 목표 금액을 최소한의 동전 개수로 만들기 위해 그리디 알고리즘을 사용하는 것이다. 주어진 동전의 종류를 내림차순으로 정렬하고, 각 동전으로 가능한 최대 개수만큼 사용한 후, 남은 금액에 대해 같은 방법을 반복하여 최종적으로 필요한 동전 개수를 계산한다.

### 동작 과정
예를 들어, 입력이 다음과 같다고 가정하자:
```
3 10
1
2
5
```
- 첫 번째 줄에서 `n=3` (동전의 종류 수), `k=10` (목표 금액)을 입력받는다.
- 그 다음 각 동전의 가치를 입력받아 리스트 `a`에 저장한다: `a = [1, 2, 5]`.
- 리스트를 내림차순으로 정렬하면 `a = [5, 2, 1]`이 된다.
- 동전의 개수 `cnt`를 0으로 초기화한다.

이제 동전의 가치를 큰 것부터 사용하여 다음과 같이 진행한다:
1. `i = 5`: `cnt += 10 // 5` (2개 사용), `k %= 5` (남은 금액 0).
2. `k`가 0이므로 더 이상 동전을 사용할 필요가 없다.

최종적으로 `cnt`는 2가 되어, 10원을 만드는 데 필요한 최소 동전 개수는 2개임을 알 수 있다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n)이다. 여기서 n은 동전의 종류 수이다. 동전의 입력과 리스트 정렬(내림차순)에서 O(n) 시간이 소요되며, 각 동전의 가치를 사용하는 과정에서도 최대 n번 반복하므로 전체적으로 O(n)으로 분석할 수 있다.

---

## 코드
```python
import sys

n,k=map(int,input().split())
a=[]
cnt=0

for i in range(n):
    a.append(int(input()))

a.reverse()

for i in a:
    cnt+=k//i
    k%=i

print(cnt)



```