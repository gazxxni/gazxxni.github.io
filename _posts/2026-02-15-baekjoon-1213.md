---
layout: post
title: "[백준] 1213번 팰린드롬 만들기 (Python)"
date: 2026-02-15
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1213", 구현, 그리디 알고리즘, 문자열, 홀짝성]
---

## 문제 링크
[https://www.acmicpc.net/problem/1213](https://www.acmicpc.net/problem/1213)

## 문제
임한수와 임문빈은 서로 사랑하는 사이이다.

임한수는 세상에서 팰린드롬인 문자열을 너무 좋아하기 때문에, 둘의 백일을 기념해서 임문빈은 팰린드롬을 선물해주려고 한다.

임문빈은 임한수의 영어 이름으로 팰린드롬을 만들려고 하는데, 임한수의 영어 이름의 알파벳 순서를 적절히 바꿔서 팰린드롬을 만들려고 한다.

임문빈을 도와 임한수의 영어 이름을 팰린드롬으로 바꾸는 프로그램을 작성하시오.

## 입력
첫째 줄에 임한수의 영어 이름이 있다. 알파벳 대문자로만 된 최대 50글자이다.

## 출력
첫째 줄에 문제의 정답을 출력한다. 만약 불가능할 때는 "I'm Sorry Hansoo"를 출력한다. 정답이 여러 개일 경우에는 사전순으로 앞서는 것을 출력한다.

## 풀이
### 풀이 핵심 로직
팰린드롬을 만들기 위해서는 각 문자들이 대칭을 이루어야 합니다. 따라서 각 문자의 개수는 짝수여야 하며, 홀수인 문자는 최대 한 개만 허용되어 중앙에 위치할 수 있습니다. 이를 바탕으로 각 문자의 빈도를 세고, 조건에 맞게 문자열을 구성하는 방법을 사용합니다.

### 동작 과정
1. **문자 빈도 세기**: 입력된 문자열에서 각 알파벳의 빈도를 세어 `alpha_cnt` 리스트에 저장합니다.
2. **홀수 개수 확인 및 중앙 문자 결정**: 각 알파벳의 빈도를 확인하여 홀수인 알파벳의 개수를 센다. 홀수 개수가 1개 이하일 경우에만 팰린드롬이 가능하며, 홀수인 알파벳은 중앙에 위치할 수 있도록 `mid` 변수에 저장한다.
3. **팰린드롬 구성**: 남은 알파벳들은 짝수 개수로 남아있으므로, 각각의 알파벳을 절반만 `front` 문자열에 추가한다.
4. **결과 조합**: `front` 문자열과 `mid` 문자열, 그리고 `front`의 역순을 결합하여 최종적인 팰린드롬을 생성한다.
5. **조건 불충족 시 처리**: 홀수 개수가 1개를 초과할 경우 "I'm Sorry Hansoo"를 출력한다.

### 예시 입력으로 단계별 설명
- 입력: `AABB`
  1. 빈도 수: `A: 2, B: 2` (모두 짝수)
  2. 홀수 개수: 0 (팰린드롬 가능)
  3. `front` 구성: `AB` (A와 B를 각각 1개씩)
  4. 결과: `AB + "" + BA` = `ABBA`

- 입력: `AAABBB`
  1. 빈도 수: `A: 3, B: 3`
  2. 홀수 개수: 2 (팰린드롬 불가능)
  3. 결과: "I'm Sorry Hansoo"

### 시간 복잡도
O(n) - 문자열의 길이에 비례하여 각 문자의 빈도를 세는 과정과 팰린드롬을 만드는 과정이 포함되어 있습니다. 여기서 n은 입력 문자열의 길이입니다.

## 코드
```python
s = input().strip()
alpha_cnt = [0] * 26

for char in s:
    alpha_cnt[ord(char) - ord('A')] += 1

odd_cnt = 0
mid = ''
front = ''

for i in range(26):
    if alpha_cnt[i] % 2 == 1:
        odd_cnt += 1
        mid = chr(i + ord('A'))
    front += chr(i + ord('A')) * (alpha_cnt[i] // 2)

if odd_cnt > 1:
    print("I'm Sorry Hansoo")
else:
    print(front + mid + front[::-1])
```