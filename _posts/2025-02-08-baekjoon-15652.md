---
layout: post
title: "[백준] 15652번 (Python)"
date: 2025-02-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "15652"]
---

## 문제 링크
[https://www.acmicpc.net/problem/15652](https://www.acmicpc.net/problem/15652)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 숫자 `n`까지의 자연수 중에서 중복을 허용하여 `m`개의 수로 이루어진 비내림차순 수열을 생성하는 문제입니다. DFS(Depth-First Search) 알고리즘을 사용하여 수열을 탐색하며, 현재 수열에 추가할 수 있는 숫자는 이전에 선택한 숫자 `a` 이상으로 제한하여 중복과 비내림차순 조건을 만족하게 합니다.

### 동작 과정
예를 들어, 입력이 `3 2`라고 가정해 보겠습니다. 여기서 `n = 3`이고 `m = 2`입니다.

1. `dfs(1)` 호출: `arr`이 비어있고, `a`는 1입니다.
   - `i = 1`: `arr`에 1을 추가하고 `dfs(1)` 호출.
     - `arr = [1]`, `len(arr) < m`이므로 계속 진행.
     - `i = 1`: `arr`에 1 추가하고 `dfs(1)` 호출.
       - `arr = [1, 1]`, `len(arr) == m`이므로 출력: `1 1`.
       - 백트래킹: `arr`에서 1을 제거.
     - `i = 2`: `arr`에 2 추가하고 `dfs(2)` 호출.
       - `arr = [1, 2]`, 출력: `1 2`.
       - 백트래킹: `arr`에서 2를 제거.
     - `i = 3`: `arr`에 3 추가하고 `dfs(3)` 호출.
       - `arr = [1, 3]`, 출력: `1 3`.
       - 백트래킹: `arr`에서 3을 제거.
   - 백트래킹: `arr`에서 1을 제거.
   
2. `i = 2`: `arr`에 2 추가하고 `dfs(2)` 호출.
   - `arr = [2]`, `len(arr) < m`이므로 계속 진행.
   - `i = 2`: `arr`에 2 추가하고 `dfs(2)` 호출.
     - `arr = [2, 2]`, 출력: `2 2`.
     - 백트래킹: `arr`에서 2 제거.
   - `i = 3`: `arr`에 3 추가하고 `dfs(3)` 호출.
     - `arr = [2, 3]`, 출력: `2 3`.
     - 백트래킹: `arr`에서 3 제거.
   - 백트래킹: `arr`에서 2 제거.
   
3. `i = 3`: `arr`에 3 추가하고 `dfs(3)` 호출.
   - `arr = [3]`, `len(arr) < m`이므로 계속 진행.
   - `i = 3`: `arr`에 3 추가하고 `dfs(3)` 호출.
     - `arr = [3, 3]`, 출력: `3 3`.
     - 백트래킹: `arr`에서 3 제거.
   - 백트래킹: `arr`에서 3 제거.

최종적으로 출력되는 결과는 다음과 같습니다:
```
1 1
1 2
1 3
2 2
2 3
3 3
```

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n^m)입니다. 이는 각 자리수에 대해 n개의 선택이 가능하고, 총 m자리 수열을 생성해야 하기 때문입니다.

---

## 코드
```python
import sys

n, m = map(int, input().split())
arr = []

def dfs(a):
    if len(arr) == m:  # m개의 숫자가 들어갔을 때 재귀 종료
        print(' '.join(map(str, arr)))  # 리스트를 문자열로 변환하여 출력
        return
    
    for i in range(a, n+1):
        arr.append(i)  # 현재 숫자 i를 선택
        dfs(i) 
        arr.pop()  # 백트래킹

dfs(1)

```