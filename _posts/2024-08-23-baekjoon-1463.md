---
layout: post
title: "[백준] 1463번 (Python)"
date: 2024-08-23
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1463"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1463](https://www.acmicpc.net/problem/1463)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 자연수 \( n \)을 1로 만드는 최소 연산 횟수를 구하는 문제로, 동적 계획법(DP)을 사용하여 해결한다. 각 수 \( i \)에 대해 1을 빼거나 2로 나누거나 3으로 나누는 세 가지 방법을 통해 이전 수에서의 최소 연산 횟수를 바탕으로 현재 수의 최소 연산 횟수를 계산한다.

### 동작 과정
예를 들어, \( n = 10 \)일 때의 단계별 설명은 다음과 같다:

1. **초기화**: `d` 배열을 초기화하여 `d[0]`과 `d[1]`은 0으로 설정한다. (1로 만들기 위해 필요한 연산이 없음)
2. **i = 2**: 
   - 1을 빼면 1 → `d[2] = d[1] + 1 = 1`
   - 2로 나누면 1 → `d[2] = min(d[2], d[1] + 1) = 1`
   - 결과: `d[2] = 1`
3. **i = 3**: 
   - 1을 빼면 2 → `d[3] = d[2] + 1 = 2`
   - 3으로 나누면 1 → `d[3] = min(d[3], d[1] + 1) = 1`
   - 결과: `d[3] = 1`
4. **i = 4**: 
   - 1을 빼면 3 → `d[4] = d[3] + 1 = 2`
   - 2로 나누면 2 → `d[4] = min(d[4], d[2] + 1) = 2`
   - 결과: `d[4] = 2`
5. **i = 5**: 
   - 1을 빼면 4 → `d[5] = d[4] + 1 = 3`
   - 결과: `d[5] = 3`
6. **i = 6**: 
   - 1을 빼면 5 → `d[6] = d[5] + 1 = 4`
   - 2로 나누면 3 → `d[6] = min(d[6], d[3] + 1) = 2`
   - 3으로 나누면 2 → `d[6] = min(d[6], d[2] + 1) = 2`
   - 결과: `d[6] = 2`
7. **i = 7**: 
   - 1을 빼면 6 → `d[7] = d[6] + 1 = 3`
   - 결과: `d[7] = 3`
8. **i = 8**: 
   - 1을 빼면 7 → `d[8] = d[7] + 1 = 4`
   - 2로 나누면 4 → `d[8] = min(d[8], d[4] + 1) = 3`
   - 결과: `d[8] = 3`
9. **i = 9**: 
   - 1을 빼면 8 → `d[9] = d[8] + 1 = 4`
   - 3으로 나누면 3 → `d[9] = min(d[9], d[3] + 1) = 2`
   - 결과: `d[9] = 2`
10. **i = 10**: 
    - 1을 빼면 9 → `d[10] = d[9] + 1 = 3`
    - 2로 나누면 5 → `d[10] = min(d[10], d[5] + 1) = 4`
    - 결과: `d[10] = 3`

최종적으로 `d[10]`은 3으로, 10을 1로 만드는 최소 연산 횟수는 3이다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 \( O(n) \)이다. 각 수 \( i \)에 대해 상수 시간 내에 연산을 수행하므로, 전체 \( n \)에 대해 선형적으로 계산이 이루어진다.

---

## 코드
```python
import sys

n = int(input())

# DP(동적 계획법) 테이블 초기화
d = [0] * 1000001

# 다이나믹 프로그래밍 진행(bottom-up)
for i in range(2, n+1):
    # 현재의 수에서 1을 빼는 경우
    d[i] = d[i-1] + 1
    # 현재의 수가 2로 나누어 떨어지는 경우
    if i%2 == 0:
        d[i] = min(d[i], d[i//2] + 1)
    # 현재의 수가 3으로 나누어 떨어지는 경우
    if i%3 == 0:
        d[i] = min(d[i], d[i//3] + 1)

# 결과 출력
print(d[n])


```