---
layout: post
title: "[백준] 1342번 행운의 문자열 (Python)"
date: 2025-12-09
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1342", 브루트포스 알고리즘, 집합과 맵, 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/1342](https://www.acmicpc.net/problem/1342)

---

## 문제
민식이와 준영이는 자기 방에서 문자열을 공부하고 있다. 민식이가 말하길 인접해 있는 모든 문자가 같지 않은 문자열을 행운의 문자열이라고 한다고 한다. 준영이는 문자열 S를 분석하기 시작했다. 준영이는 문자열 S에 나오는 문자를 재배치하면 서로 다른 행운의 문자열이 몇 개 나오는지 궁금해졌다. 만약 원래 문자열 S도 행운의 문자열이라면 그것도 개수에 포함한다.

---

## 입력
첫째 줄에 문자열 S가 주어진다. S의 길이는 최대 10이고, 알파벳 소문자로만 이루어져 있다.

---

## 출력
첫째 줄에 위치를 재배치해서 얻은 서로 다른 행운의 문자열의 개수를 출력한다.

---

## 성능 요약
메모리: 113412 KB, 시간: 1512 ms

---

## 풀이

### 풀이 핵심 로직
주어진 문자열의 모든 문자를 재배치하여 인접한 문자가 같지 않은 '행운의 문자열'을 생성하는 문제이다. 이를 해결하기 위해 백트래킹을 사용하여, 현재 선택된 문자가 이전 문자와 다를 때만 다음 문자를 선택하도록 하여 중복된 문자열 생성을 방지한다. 또한, 각 문자의 사용 개수를 기록하고 관리하여 서로 다른 문자열을 생성한다.

### 동작 과정
1. **입력 처리**: 문자열 S를 입력받아 리스트로 변환하고 각 문자별 개수를 딕셔너리에 저장한다.
   - 예시 입력: `aabb`
   - 딕셔너리: `{'a': 2, 'b': 2}`

2. **백트래킹 함수 정의**: `back(dic, before, use)` 함수는 현재까지 사용된 문자와 현재 위치를 인자로 받아 행운의 문자열을 생성한다.
   - `before`: 이전에 사용된 문자 (첫 호출 시 None)
   - `use`: 현재까지 사용된 문자의 수 (초기값 0)

3. **재귀 호출**: 각 문자에 대해 사용 가능 여부를 체크하고, 사용했을 경우 개수를 줄이고 다음 문자로 재귀 호출을 진행한다. 이전 문자와 다를 때만 호출하도록 하여 인접 문자가 같지 않도록 한다.

4. **종료 조건**: 모든 문자가 사용되었을 때 (use == l) 카운트를 증가시킨다.

5. **결과 출력**: 최종적으로 생성된 서로 다른 행운의 문자열 개수를 출력한다.

### 시간 복잡도
최악의 경우 문자열의 길이가 10이므로, 각 문자에 대해 최대 10! (3628800) 경우의 수가 존재할 수 있다. 하지만 인접 문자가 같지 않은 조건으로 인해 유효한 조합은 줄어들기 때문에 실제로는 이보다 적다. 따라서 시간 복잡도는 O(N!)로 볼 수 있다.

---

## 코드
```python
s = list(input().rstrip())
l = len(s)
dic = {}

for i in s:
    dic[i] = dic.get(i, 0) + 1

cnt = 0
def back(dic, before, use):
    global cnt
    if use == l:
        cnt += 1
        return
    
    for k, v in dic.items():
        if v > 0 and k != before:
            dic[k] -= 1
            back(dic, k, use + 1)
            dic[k] += 1

back(dic, None, 0)
print(cnt)

```