---
layout: post
title: "[백준] 2559번 (Python)"
date: 2025-11-03
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2559"]
---

## 문제 링크
[https://www.acmicpc.net/problem/2559](https://www.acmicpc.net/problem/2559)

---

## 풀이

### 풀이 핵심 로직
이 문제는 연속된 k일 동안의 온도 합을 계산하여 최대 온도 합을 찾는 문제입니다. 슬라이딩 윈도우 기법을 사용하여 첫 k일의 합을 구한 후, 윈도우를 하나씩 이동시키며 이전의 값을 활용해 새로운 합을 계산함으로써 효율적으로 최대 합을 찾습니다.

### 동작 과정
예를 들어, 입력이 `n = 8`, `k = 3`이고 온도 배열이 `arr = [1, 2, 3, -1, -2, 4, 5, 6]`인 경우:

1. **초기 값 계산**: 첫 번째 슬라이딩 윈도우인 `[1, 2, 3]`의 합을 계산합니다.
   - `ss = 1 + 2 + 3 = 6`
   - `ans = 6` (현재 최대 합)
   
2. **윈도우 이동**:
   - **i = 3**: 새로운 윈도우 `[2, 3, -1]`
     - `ss = 6 - arr[0] + arr[3]` → `ss = 6 - 1 - 1 = 5`
     - `ans`는 여전히 6
   - **i = 4**: 새로운 윈도우 `[3, -1, -2]`
     - `ss = 5 - arr[1] + arr[4]` → `ss = 5 - 2 - 2 = 1`
     - `ans`는 여전히 6
   - **i = 5**: 새로운 윈도우 `[-1, -2, 4]`
     - `ss = 1 - arr[2] + arr[5]` → `ss = 1 - 3 + 4 = 2`
     - `ans`는 여전히 6
   - **i = 6**: 새로운 윈도우 `[-2, 4, 5]`
     - `ss = 2 - arr[3] + arr[6]` → `ss = 2 + 1 + 5 = 6`
     - `ans`는 여전히 6
   - **i = 7**: 새로운 윈도우 `[4, 5, 6]`
     - `ss = 6 - arr[4] + arr[7]` → `ss = 6 + 2 + 6 = 12`
     - `ans` 업데이트: `ans = 12`

최종적으로 `ans`는 12가 되어 출력됩니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n)입니다. n개의 원소를 한 번만 순회하며, 각 원소에 대해 상수 시간의 계산을 수행하기 때문입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n, k = map(int, input().split())
arr = list(map(int, input().split()))

ss = sum(arr[:k])
ans = ss

for i in range(k, n):
    ss = ss - arr[i - k] + arr[i]
    ans = max(ans, ss)

print(ans)
```