---
layout: post
title: "[백준] 20920번 (Python)"
date: 2025-10-24
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "20920"]
---

## 문제 링크
[https://www.acmicpc.net/problem/20920](https://www.acmicpc.net/problem/20920)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 주어진 단어들을 조건에 맞춰서 세고, 그 결과를 정렬하여 출력하는 것입니다. 주어진 단어의 길이가 `m` 이상인 경우에만 세어주고, 그 다음 세기 결과를 빈도수에 따라 그룹화한 후, 각 그룹 내에서 단어를 길이와 사전순으로 정렬합니다.

### 동작 과정
1. **입력 읽기**: 첫 번째 줄에서 `n`(단어 수)과 `m`(최소 길이)을 입력받습니다.
2. **단어 세기**: `for` 루프를 통해 `n`개의 단어를 읽고, 길이가 `m` 이상인 단어만 딕셔너리에 추가하여 그 빈도를 센다.
   - 예시 입력: 
     ```
     5 3
     apple
     banana
     app
     pear
     peach
     ```
   - 빈도 딕셔너리(`dic`)는 다음과 같이 구성됩니다:
     ```
     {
       'apple': 1,
       'banana': 1,
       'pear': 1,
       'peach': 1
     }
     ```
3. **그룹화**: 빈도수를 키로 하는 새로운 딕셔너리(`dic2`)를 생성하여, 같은 빈도를 가진 단어들을 리스트로 그룹화합니다.
   - 결과:
     ```
     {
       1: ['apple', 'banana', 'pear', 'peach']
     }
     ```
4. **정렬**: 각 빈도 그룹 내에서 단어를 길이와 사전순으로 정렬합니다.
   - 정렬 결과: 
     ```
     ['banana', 'apple', 'peach', 'pear']
     ```
5. **최종 정렬**: 빈도수를 기준으로 내림차순으로 정렬합니다. 결과는 이미 빈도수가 동일하므로 변화가 없습니다.
6. **결과 출력**: 최종적으로 정렬된 단어들을 출력합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 `O(n + k log k)`입니다. 여기서 `n`은 입력받은 단어의 수, `k`는 빈도수에 따라 그룹화된 단어의 수입니다. 단어의 세기와 그룹화는 각각 `O(n)`의 시간 복잡도를 가지며, 정렬 단계에서 각 그룹의 단어를 정렬하는 과정이 `O(k log k)`의 시간 복잡도를 가집니다.

---

## 코드
```python
import sys
input = sys.stdin.readline
from collections import defaultdict

n, m = map(int, input().split())

dic = defaultdict(int)
for _ in range(n):
    a = input().rstrip()
    if len(a) >= m:
        dic[a] += 1
    
dic2 = defaultdict(list)
for k, v in dic.items():
    dic2[v].append(k)
    
for k, v in dic2.items():
    v.sort(key=lambda x: (-len(x), x))
    
a = sorted(dic2.items(), key=lambda x:x[0], reverse=True)

for i, j in a:
    for k in j:
        print(k)
```