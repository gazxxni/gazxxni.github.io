---
layout: post
title: "[백준] 1562번 (Python)"
date: 2025-02-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1562"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1562](https://www.acmicpc.net/problem/1562)

---

## 풀이

### 풀이 핵심 로직
이 문제는 "계단 수"를 세는 문제로, 각 자리의 숫자가 이전 자리 숫자보다 1 커지거나 작아야 합니다. 또한, 모든 숫자가 최소 한 번은 나타나야 하므로 비트 마스크를 사용하여 각 숫자의 출현 여부를 추적합니다. 동적 프로그래밍을 이용하여 길이 `n`의 계단 수를 계산하고, 모든 숫자가 나타나는 경우를 합산하여 최종 결과를 도출합니다.

### 동작 과정
1. **초기화**: 길이가 1인 계단 수를 초기화합니다. 각 숫자(1~9)가 하나의 자리로만 나타날 수 있으므로, `dp[1][j][1 << j]`를 1로 설정합니다. 여기서 `1 << j`는 숫자 `j`가 사용되었음을 나타내는 비트 마스크입니다.

2. **동적 프로그래밍 진행**: 길이 `i`의 계단 수를 만들기 위해, 이전 자리 `j`에서 가능한 모든 경우를 탐색합니다.
    - 현재 숫자 `j`에서 `j-1`로 이동 가능한 경우와 `j+1`로 이동 가능한 경우를 각각 처리합니다.
    - 새로운 숫자로 이동할 때, 그 숫자에 대한 비트 마스크를 업데이트하고, 해당 상태의 수를 누적합니다.

3. **결과 계산**: 길이가 `n`인 계단 수 중 모든 숫자가 나타나는 경우(비트 마스크가 `1111111111`인 경우)를 합산하여 최종 결과를 도출합니다.

예를 들어, `n = 3`일 때:
- 길이 1: 1, 2, ..., 9로 초기화
- 길이 2: 예를 들어, 1에서 2로 갈 수 있으므로 `dp[2][1][...]`와 `dp[2][2][...]`를 업데이트
- 길이 3: 다시 이전 자리의 상태에 따라 새로운 숫자를 생성하고, 모든 조합을 탐색

4. **출력**: 최종적으로 `dp[n][j][(1 << 10) - 1]` 값들을 합산하여 출력합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n * 10 * 1024)입니다. 이는 n자리 수를 만들기 위해 10개의 숫자와 1024개의 비트 마스크 조합을 모두 탐색하기 때문입니다. 최악의 경우, 이 복잡도는 효율적으로 처리할 수 있는 범위입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

MOD = 1_000_000_000
n = int(input())
dp = [[[0] * 1024 for _ in range(10)] for _ in range(n + 1)]

# 길이 1의 계단 수 초기화
for j in range(1, 10):
    dp[1][j][1 << j] = 1

for i in range(1, n):
    for j in range(10):
        for k in range(1 << 10):
            if dp[i][j][k] == 0:
                continue
            
            # Case 1: 다음 숫자가 j-1일 경우
            if j > 0:
                new_digit = j - 1
                new_mask = k | (1 << new_digit)
                dp[i + 1][new_digit][new_mask] = (dp[i + 1][new_digit][new_mask] + dp[i][j][k]) % MOD
            
            # Case 2: 다음 숫자가 j+1일 경우
            if j < 9:
                new_digit = j + 1
                new_mask = k | (1 << new_digit)
                dp[i + 1][new_digit][new_mask] = (dp[i + 1][new_digit][new_mask] + dp[i][j][k]) % MOD

result = 0
for j in range(10):
    result = (result + dp[n][j][(1 << 10) - 1]) % MOD
    
print(result)
```