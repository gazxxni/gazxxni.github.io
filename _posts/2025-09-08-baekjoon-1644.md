---
layout: post
title: "[백준] 1644번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1644"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1644](https://www.acmicpc.net/problem/1644)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 정수 `n`을 소수의 합으로 표현할 수 있는 경우의 수를 찾는 문제입니다. 소수를 구한 후, 두 포인터 기법을 사용하여 소수의 연속적인 합이 `n`이 되는 경우의 수를 세는 방식으로 해결합니다.

### 동작 과정
1. **입력 받기**: `n`을 입력받습니다.
2. **소수 구하기**: `is_prime` 함수를 통해 2부터 `n`까지의 소수를 찾아 리스트 `primenums`에 저장합니다.
3. **두 포인터 초기화**: `st`(시작 인덱스)와 `ed`(끝 인덱스)를 0으로 초기화하고, `cnt`(합이 `n`이 되는 경우의 수)와 `total`(현재 소수의 합)을 0으로 초기화합니다.
4. **합 계산**:
   - `while True` 루프를 통해 `total`이 `n` 이상일 때와 미만일 때를 구분합니다.
   - `total`이 `n`과 같을 경우 `cnt`를 1 증가시키고, `st` 인덱스를 증가시켜서 소수를 빼줍니다.
   - `total`이 `n` 미만일 경우, `ed` 인덱스를 증가시켜서 소수를 더합니다.
   - `ed`가 소수 리스트의 길이에 도달하면 루프를 종료합니다.
5. **결과 출력**: 최종적으로 카운트된 경우의 수 `cnt`를 출력합니다.

예시 입력으로 `n = 10`일 경우:
- 소수 리스트는 `[2, 3, 5, 7]`가 됩니다.
- 두 포인터를 사용하여 `2 + 3 + 5 = 10`과 `5 + 5 = 10`을 찾을 수 있게 됩니다. 최종적으로 두 가지 경우가 가능하므로 출력값은 `2`가 됩니다.

### 시간 복잡도
- 소수를 구하는 부분에서 O(n√n) (에라토스테네스의 체 사용 시 O(n log log n)), 
- 두 포인터를 사용하는 부분에서 O(m) (m은 소수의 개수)입니다.
- 전체적으로는 O(n√n) 또는 O(n log log n)으로 볼 수 있습니다.

---

## 코드
```python
import sys, math
input = sys.stdin.readline

n = int(input())

def is_prime(x):
    if x < 2:
        return False
    for i in range(2, int(math.sqrt(x)) + 1):
        if x % i == 0:
            return False
    return True

primenums = []

for i in range(2, n+1):
    if is_prime(i):
        primenums.append(i)

st, ed = 0, 0
cnt = 0
total = 0

while True:
    if total >= n:
        if total == n:
            cnt += 1
        total -= primenums[st]
        st += 1
    elif ed == len(primenums):
        break
    else:
        total += primenums[ed]
        ed += 1

print(cnt)
```