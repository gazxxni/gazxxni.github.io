---
layout: post
title: "[백준] 12789번 (Python)"
date: 2025-10-18
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "12789"]
---

## 문제 링크
[https://www.acmicpc.net/problem/12789](https://www.acmicpc.net/problem/12789)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 주어진 숫자들을 차례대로 정렬된 순서로 배치할 수 있는지를 판단하는 것입니다. 각 숫자를 순서대로 확인하면서 현재 기대하는 숫자(idx)가 나오면 순서를 유지하고, 그렇지 않으면 스택(brr)에 임시 저장하여 나중에 확인할 수 있도록 합니다. 최종적으로 스택이 비어 있으면 모든 숫자를 올바른 순서로 정렬할 수 있다는 것을 의미합니다.

### 동작 과정
1. **입력**: 예를 들어, `n = 5`이고 `arr = [5, 1, 2, 3, 4]`라고 가정합니다.
2. **초기 상태**: `brr = []`, `idx = 1`입니다.
3. **첫 번째 반복**: `i = 5`일 때, `5`는 `idx`와 다르므로 `brr`에 추가합니다. (`brr = [5]`)
4. **두 번째 반복**: `i = 1`일 때, `1`은 `idx`와 다르므로 `brr`에 추가합니다. (`brr = [5, 1]`)
5. **세 번째 반복**: `i = 2`일 때, `2`는 `idx`와 다르므로 `brr`에 추가합니다. (`brr = [5, 1, 2]`)
6. **네 번째 반복**: `i = 3`일 때, `3`은 `idx`와 다르므로 `brr`에 추가합니다. (`brr = [5, 1, 2, 3]`)
7. **다섯 번째 반복**: `i = 4`일 때, `4`는 `idx`와 다르므로 `brr`에 추가합니다. (`brr = [5, 1, 2, 3, 4]`)
8. **결과 확인**: 반복이 끝난 후, `brr`이 비어 있지 않으므로 "Sad"를 출력합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n)입니다. 입력 배열을 한 번 순회하면서 각 원소를 스택에 추가하거나 제거하는 작업을 하기 때문에 최악의 경우에도 선형 시간에 해결됩니다.

---

## 코드
```python
n = int(input())
arr = list(map(int, input().split()))

brr = []
idx = 1

for i in arr:
    if i == idx:
        idx += 1
        while brr and brr[-1] == idx:
            brr.pop()
            idx += 1
    else:
        brr.append(i)

if not brr:
    print("Nice")
else:
    print("Sad")
```