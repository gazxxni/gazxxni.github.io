---
layout: post
title: "[백준] 9506번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "9506"]
---

## 문제 링크
[https://www.acmicpc.net/problem/9506](https://www.acmicpc.net/problem/9506)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 자연수 \( n \)이 완전수인지 판별하는 문제입니다. 완전수는 자신의 약수의 합이 자신과 같은 수를 의미합니다. 코드에서는 입력된 수의 약수를 찾고, 이 약수들의 합이 \( n \)과 같은지를 비교하여 완전수 여부를 판단합니다.

### 동작 과정
1. 사용자가 자연수 \( n \)을 입력합니다. 만약 \( n \)이 -1이면 프로그램이 종료됩니다.
2. `aa` 함수가 호출되어 \( n \)의 약수를 찾습니다.
   - 약수를 찾기 위해 1부터 \( \sqrt{n} \)까지 반복하며, \( n \)이 \( i \)로 나누어 떨어지면 \( i \)와 \( n // i \)를 약수 리스트에 추가합니다.
   - 이때, \( i \)와 \( n // i \)가 같을 경우 중복 추가를 피합니다.
3. 약수 리스트에서 \( n \)을 제거하고 정렬합니다.
4. 약수들의 합을 계산하여 \( n \)과 비교합니다.
   - 만약 약수들의 합이 \( n \)과 같으면 완전수임을 출력하고, 그렇지 않으면 완전수가 아님을 출력합니다.

**예시 입력:**
- 사용자가 6을 입력하면:
  - 약수는 [1, 2, 3]이 되고, 이들의 합은 6이므로 "6 = 1 + 2 + 3"이 출력됩니다.
- 사용자가 12를 입력하면:
  - 약수는 [1, 2, 3, 4, 6]이 되고, 이들의 합은 16이므로 "12 is NOT perfect."가 출력됩니다.

### 시간 복잡도
이 코드의 시간 복잡도는 \( O(\sqrt{n}) \)입니다. 이는 약수를 찾기 위해 1부터 \( \sqrt{n} \)까지 반복하는 과정 때문입니다. 리스트 정렬과 약수의 합산 과정은 \( O(k \log k) \) 및 \( O(k) \)로 \( k \)는 약수의 개수이지만, 이 또한 \( O(\sqrt{n}) \)에 비해 상대적으로 작기 때문에 전체적으로는 \( O(\sqrt{n}) \)으로 간주할 수 있습니다.

---

## 코드
```python
import sys

def aa(n):
    arr = []
    for i in range(1, int(n ** 0.5) + 1):
        if n % i == 0:
            arr.append(i)
            if i * i != n:
                arr.append(n // i)
    arr.sort()
    arr.remove(n) 
    return arr

while True:
    n = int(input())
    if n == -1:
        sys.exit()
    
    a = aa(n)
    
    if n == sum(a):
        print(f"{n} = {' + '.join(map(str, a))}")
    else:
        print(f"{n} is NOT perfect.")

```