---
layout: post
title: "[백준] 9742번 순열 (Python)"
date: 2026-01-15
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "9742", 브루트포스 알고리즘, 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/9742](https://www.acmicpc.net/problem/9742)

---

## 문제
집합의 순열이란 집합의 서로 다른 원소를 모두 사용해 만들 수 있는 순서이다. 예를 들어, {2,3,5}의 순열은 다음과 같다.


	2 3 5
	2 5 3
	3 2 5
	3 5 2
	5 2 3
	5 3 2


각각의 순열은 숫자로 나타낼 수 있다. 위의 순열은 사전순으로 쓰여져 있으며, 등장하는 순서를 이용해 나타낸다. 즉, 3 5 2는 위치 4에 있고, 5 3 2는 마지막 위치인 6에 있다.

{b,e,i,n}으로 만들 수 있는 순열은 다음과 같다.


	b e i n
	b e n i
	b i e n
	b i n e
	b n e i
	b n i e
	e b i n
	e b n i
	e i b n
	e i n b
	e n b i 
	e n i b
	i b e n
	i b n e
	i e b n
	i e n b
	i n b e
	i n e b
	n b e i
	n b i e
	n e b i
	n e i b
	n i b e
	n i e b


서로 다른 숫자와 문자로 이루어진 집합과 위치가 주어졌을 때, 그 집합의 순열 중 주어진 위치의 순열을 구하는 프로그램을 작성하시오.

---

## 입력
입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있다. 첫 번째 문자열은 서로 다른 숫자와 알파벳으로 이루어져 있으며, 길이는 최대 10이다. 또한, 사전순 순서대로 주어진다. 문자열 다음에는 찾아야 하는 위치가 주어지며, 이 값은 3,628,800보다 작거나 같은 자연수이다.

---

## 출력
각각의 테스트 케이스마다, 입력으로 주어진 위치에 해당하는 순열을 공백없이 출력한다. 만약, 해당하는 순열이 없는 경우에는 "No permutation"을 출력한다.

---

## 성능 요약
메모리: 380072 KB, 시간: 2080 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 문자열의 순열을 구하고, 특정 위치에 해당하는 순열을 찾아 출력하는 문제입니다. 우선, 문자열의 길이를 기반으로 총 순열의 개수를 계산한 후, 요청된 위치가 유효한지 확인합니다. 유효하다면 백트래킹을 통해 모든 순열을 생성한 후, 사전순으로 정렬하고 요청된 위치의 순열을 반환합니다.

### 동작 과정
1. 입력으로 주어진 문자열과 위치를 읽어옵니다. 예를 들어, 입력이 `b e i n 12`라면, 문자열은 `bein`이고, 위치는 `12`입니다.
2. 문자열의 길이를 계산하여 총 순열의 개수를 `n!`로 계산합니다. 여기서 `n`은 문자열의 길이입니다.
3. 만약 요청된 위치가 총 순열 수보다 크면 "No permutation"을 출력합니다.
4. 백트래킹을 통해 모든 가능한 순열을 생성합니다. 이 과정에서 각 문자가 사용되었는지를 확인하기 위해 `visited` 리스트를 사용합니다.
5. 생성된 모든 순열을 사전순으로 정렬한 후, 위치 `b-1` (0-indexed)에서 해당하는 순열을 찾습니다.
6. 최종적으로 `b`와 해당 순열을 포맷에 맞춰 출력합니다.

예시:
- 입력: `b e i n 12`
- 총 순열: 24개 (4!)
- 순열 리스트: [be i n, ... , n i b e]
- 요청된 위치 `12`의 순열: `n i b e`
- 출력: `bein 12 = nib`

### 시간 복잡도
주어진 문자열의 길이가 최대 10이므로, 모든 순열을 생성하는 시간 복잡도는 O(n!), 여기서 n은 문자열의 길이입니다. 그러나, 사전순으로 정렬하기 위해 O(n! log(n!))의 추가적인 시간 복잡도가 발생할 수 있습니다. 전체적으로는 O(n! log(n!))로 볼 수 있습니다.

---

## 코드
```python
import sys, math
input = sys.stdin.readline

result = [] 
visited = [] 

def backtrack(arr, path):
    if len(path) == len(arr):
        result.append("".join(path))
        return
    
    for i in range(len(arr)):
        if not visited[i]:
            visited[i] = True
            backtrack(arr, path + [arr[i]])
            visited[i] = False

while True:
    try:
        a, b = input().split()
        b = int(b)
        a = list(a)
        n = len(a)
        total = math.factorial(n)

        if b > total:
            print(f"{''.join(a)} {b} = No permutation")
            continue

        result = []
        visited = [False] * n
        backtrack(a, [])

        result.sort()
        if b <= total // 2:
            ans = result[b-1]
        else:
            ans = result[-(total-b+1)]

        print(f"{''.join(a)} {b} = {ans}")
        
    except:
        break

```