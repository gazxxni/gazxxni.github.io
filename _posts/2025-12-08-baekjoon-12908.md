---
layout: post
title: "[백준] 12908번 텔레포트 3 (Python)"
date: 2025-12-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "12908", 그래프 이론, 브루트포스 알고리즘, 최단 경로, 플로이드–워셜]
---

## 문제 링크
[https://www.acmicpc.net/problem/12908](https://www.acmicpc.net/problem/12908)

---

## 문제
수빈이는 크기가 무한대인 격자판 위에 살고 있다. 격자판의 각 점은 두 정수의 쌍 (x, y)로 나타낼 수 있다.

제일 처음에 수빈이의 위치는 (xs, ys)이고, 집이 위치한 (xe, ye)로 이동하려고 한다.

수빈이는 두 가지 방법으로 이동할 수 있다. 첫 번째 방법은 점프를 하는 것이다. 예를 들어 (x, y)에 있는 경우에 (x+1, y), (x-1, y), (x, y+1), (x, y-1)로 이동할 수 있다. 점프는 1초가 걸린다.

두 번째 방법은 텔레포트를 사용하는 것이다. 텔레포트를 할 수 있는 방법은 총 세 가지가 있으며, 미리 정해져 있다. 텔레포트는 네 좌표 (x1, y1), (x2, y2)로 나타낼 수 있으며, (x1, y1)에서 (x2, y2)로 또는 (x2, y2)에서 (x1, y1)로 이동할 수 있다는 것이다. 텔레포트는 10초가 걸린다.

수빈이의 위치와 집의 위치가 주어졌을 때, 집에 가는 가장 빠른 시간을 구하는 프로그램을 작성하시오.

---

## 입력
첫째 줄에 xs와 ys가, 둘째 줄에 xe, ye가 주어진다. (0 ≤ xs, ys, xe, ye ≤ 1,000,000,000)

셋째 줄부터 세 개의 줄에는 텔레포트의 정보 x1, y1, x2, y2가 주어진다. (0 ≤ x1, y1, x2, y2 ≤ 1,000,000,000)

입력으로 주어지는 모든 좌표 8개는 서로 다르다.

---

## 출력
수빈이가 집에 가는 가장 빠른 시간을 출력한다.

---

## 성능 요약
메모리: 111284 KB, 시간: 120 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 수빈이의 시작 위치에서 집까지 가는 최단 경로를 찾는 문제로, 두 가지 이동 방법(점프와 텔레포트)을 사용하여 최단 시간을 계산한다. 다익스트라 알고리즘을 활용하여 텔레포트를 사용할 수 있는 지점들만 고려하고, 그 외의 거리 계산은 점프를 통해 수행하여 최종적으로 최소 시간을 구한다.

### 동작 과정
1. **입력 받기**: 수빈이의 시작 위치와 집의 위치, 그리고 세 개의 텔레포트 정보를 입력받는다.
2. **초기 설정**: 점프와 텔레포트를 각각 처리하기 위해 시작점과 텔레포트 지점들을 그래프로 구성한다. 각 점에 대한 초기 거리 값을 무한대로 설정하고 시작점의 거리는 0으로 초기화한다.
3. **최단 거리 계산**:
   - 우선, 시작점에서 집까지 점프만으로 이동할 경우의 거리를 계산하여 `min_cost`에 저장한다.
   - 다익스트라 알고리즘을 사용하여 우선순위 큐를 통해 현재 위치에서 텔레포트를 사용하거나 점프를 통해 다른 지점으로 이동할 때의 비용을 계산한다.
   - 텔레포트를 사용하거나 인접한 지점으로 이동할 때 새로운 비용이 기존 거리보다 작으면 업데이트하고 큐에 추가한다.
4. **최종 결과 출력**: 모든 가능성을 고려한 후, 계산한 최소 시간을 출력한다.

#### 예시 입력
```
0 0
10 10
1 1 2 2
3 3 4 4
5 5 6 6
```

- 수빈이의 시작 위치는 (0, 0)이고 집은 (10, 10)이다.
- 텔레포트는 (1, 1) ↔ (2, 2), (3, 3) ↔ (4, 4), (5, 5) ↔ (6, 6)이다.

1. 수빈이는 점프를 통해 직접 집까지 가는 경우, 거리는 20초(10 + 10)이다.
2. 텔레포트를 활용하면 (0, 0)에서 (1, 1)으로 1초, (1, 1)에서 (2, 2)로 10초, (2, 2)에서 (3, 3)으로 1초, (3, 3)에서 (4, 4)로 10초, (4, 4)에서 (5, 5)로 1초, (5, 5)에서 (6, 6)으로 10초, 그리고 (6, 6)에서 (10, 10)으로 점프하여 8초가 걸린다.
3. 최종적으로 두 가지 방법 중 빠른 방법(직접 20초 vs 텔레포트와 점프 조합 38초)을 선택하여 결과를 출력한다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 \(O((V + E) \log V)\)이다. 여기서 \(V\)는 그래프의 노드 수(텔레포트 지점 + 시작점), \(E\)는 간선 수(텔레포트 간선 + 점프 가능 간선)이다. 각 노드에 대해 다익스트라를 수행하므로 이 복잡도를 가진다.

---

## 코드
```python
import sys, heapq
from collections import defaultdict
'''
BFS로 풀면 모든 지점을 다 돌아야해서 시간초과
-> 다익스트라로 텔레포트 사용 구간만 검사, 텔레포트 안 쓰면 그냥 긴 거리가 답
'''
input = sys.stdin.readline

xs, ys = map(int, input().split())
xe, ye = map(int, input().split())

start_node = (xs, ys)
end_node = (xe, ye)

tp_dic = defaultdict(list)
tp_node = set()

for _ in range(3):
    x1, y1, x2, y2 = map(int, input().split())
    node1 = (x1, y1)
    node2 = (x2, y2)
    
    tp_node.add(node1)
    tp_node.add(node2)

    tp_dic[node1].append((node2, 10))
    tp_dic[node2].append((node1, 10))

key_nodes = list(tp_node)
key_nodes.append(start_node)

distances = {node: float('inf') for node in key_nodes}
distances[start_node] = 0

pq = [(0, start_node)]

# 시작점에서 도착점까지 가는 비용 (이게 기본 답)
min_cost = abs(xs - xe) + abs(ys - ye)

while pq:
    current_cost, current_node = heapq.heappop(pq)

    if current_cost > distances[current_node]:
        continue

    # 현재 위치에서 도착점까지 비용
    # (현재까지 비용 + 지금 위치에서 도착점까지 걷는 비용)
    cost_via_current = current_cost + abs(current_node[0] - end_node[0]) + abs(current_node[1] - end_node[1])
    min_cost = min(min_cost, cost_via_current)
    
    # 텔레포트 
    if current_node in tp_dic:
        for next_node, tele_cost in tp_dic[current_node]:
            new_cost = current_cost + tele_cost
            if new_cost < distances[next_node]:
                distances[next_node] = new_cost
                heapq.heappush(pq, (new_cost, next_node))

    # 현재 위치에서 모든 텔레포트 지점까지 비용 계산
    for next_tp_node in tp_node:
        if current_node == next_tp_node:
            continue
            
        walk_cost = abs(current_node[0] - next_tp_node[0]) + abs(current_node[1] - next_tp_node[1])
        new_cost = current_cost + walk_cost
        
        if new_cost < distances[next_tp_node]:
            distances[next_tp_node] = new_cost
            heapq.heappush(pq, (new_cost, next_tp_node))

print(min_cost)
```