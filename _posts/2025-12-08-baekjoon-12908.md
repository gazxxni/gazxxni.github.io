---
layout: post
title: "[백준] 12908번 텔레포트 3 (Python)"
date: 2025-12-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "12908", 그래프 이론, 브루트포스 알고리즘, 최단 경로, 플로이드–워셜]
---

## 문제 링크
[https://www.acmicpc.net/problem/12908](https://www.acmicpc.net/problem/12908)

---

## 문제
수빈이는 크기가 무한대인 격자판 위에 살고 있다. 격자판의 각 점은 두 정수의 쌍 (x, y)로 나타낼 수 있다.

제일 처음에 수빈이의 위치는 (xs, ys)이고, 집이 위치한 (xe, ye)로 이동하려고 한다.

수빈이는 두 가지 방법으로 이동할 수 있다. 첫 번째 방법은 점프를 하는 것이다. 예를 들어 (x, y)에 있는 경우에 (x+1, y), (x-1, y), (x, y+1), (x, y-1)로 이동할 수 있다. 점프는 1초가 걸린다.

두 번째 방법은 텔레포트를 사용하는 것이다. 텔레포트를 할 수 있는 방법은 총 세 가지가 있으며, 미리 정해져 있다. 텔레포트는 네 좌표 (x1, y1), (x2, y2)로 나타낼 수 있으며, (x1, y1)에서 (x2, y2)로 또는 (x2, y2)에서 (x1, y1)로 이동할 수 있다는 것이다. 텔레포트는 10초가 걸린다.

수빈이의 위치와 집의 위치가 주어졌을 때, 집에 가는 가장 빠른 시간을 구하는 프로그램을 작성하시오.

---

## 입력
첫째 줄에 xs와 ys가, 둘째 줄에 xe, ye가 주어진다. (0 ≤ xs, ys, xe, ye ≤ 1,000,000,000)

셋째 줄부터 세 개의 줄에는 텔레포트의 정보 x1, y1, x2, y2가 주어진다. (0 ≤ x1, y1, x2, y2 ≤ 1,000,000,000)

입력으로 주어지는 모든 좌표 8개는 서로 다르다.

---

## 출력
수빈이가 집에 가는 가장 빠른 시간을 출력한다.

---

## 성능 요약
메모리: 111284 KB, 시간: 120 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 수빈이가 집으로 가는 가장 빠른 경로를 찾는 문제로, 점프와 텔레포트를 이용한 이동 방식이 주어집니다. 텔레포트를 활용한 경로만 고려하고, 기본적으로 점프를 통해 이동하는 경우의 시간도 함께 계산하여 최단 시간을 구합니다. 다익스트라 알고리즘을 사용하여 최단 경로를 효과적으로 찾습니다.

### 동작 과정
1. **입력 받기**: 시작 위치 (xs, ys), 집 위치 (xe, ye) 및 3개의 텔레포트 지점을 입력 받습니다.
   
2. **다익스트라 알고리즘 초기화**:
   - 시작 위치에서의 비용을 0으로 설정하고, 나머지 위치는 무한대로 초기화합니다.
   - 우선순위 큐에 시작 노드를 추가합니다.

3. **경로 탐색**:
   - 우선순위 큐에서 현재 노드를 꺼내고, 해당 노드에서 집까지의 직선 거리로 초기 최단 시간을 갱신합니다.
   - 현재 노드에서 사용할 수 있는 텔레포트가 있다면, 텔레포트로 이동하는 경우를 고려하여 새로운 비용을 계산하고, 필요 시 큐에 추가합니다.
   - 현재 노드에서 모든 텔레포트 지점으로 점프하는 경우도 고려하여 거리 계산 후 큐에 추가합니다.

4. **최종 결과 출력**: 우선순위 큐가 비어질 때까지 반복하며 최단 시간을 계산하고, 최종적으로 집에 도착하는 최소 시간을 출력합니다.

**예시 입력**:
```
0 0
100 100
1 1 2 2
3 3 4 4
5 5 6 6
```
- 수빈이는 (0, 0)에서 (100, 100)으로 가야 하며, 3개의 텔레포트 지점이 존재합니다.
- 다익스트라 알고리즘을 통해 각 노드에서의 최단 거리를 계산하고, 텔레포트를 통해 빠르게 이동할 수 있는 경우를 고려하여 최종적으로 집까지의 최소 시간을 구합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O((V + E) log V)입니다. 여기서 V는 노드의 개수(텔레포트 지점 + 시작점), E는 간선의 개수(각 노드 간의 가능한 이동 경로)입니다. 텔레포트와 점프를 모두 고려하므로 최악의 경우 텔레포트 지점 개수에 비례하여 시간 복잡도가 증가합니다.

---

## 코드
```python
import sys, heapq
from collections import defaultdict
'''
BFS로 풀면 모든 지점을 다 돌아야해서 시간초과
-> 다익스트라로 텔레포트 사용 구간만 검사, 텔레포트 안 쓰면 그냥 긴 거리가 답
'''
input = sys.stdin.readline

xs, ys = map(int, input().split())
xe, ye = map(int, input().split())

start_node = (xs, ys)
end_node = (xe, ye)

tp_dic = defaultdict(list)
tp_node = set()

for _ in range(3):
    x1, y1, x2, y2 = map(int, input().split())
    node1 = (x1, y1)
    node2 = (x2, y2)
    
    tp_node.add(node1)
    tp_node.add(node2)

    tp_dic[node1].append((node2, 10))
    tp_dic[node2].append((node1, 10))

key_nodes = list(tp_node)
key_nodes.append(start_node)

distances = {node: float('inf') for node in key_nodes}
distances[start_node] = 0

pq = [(0, start_node)]

# 시작점에서 도착점까지 가는 비용 (이게 기본 답)
min_cost = abs(xs - xe) + abs(ys - ye)

while pq:
    current_cost, current_node = heapq.heappop(pq)

    if current_cost > distances[current_node]:
        continue

    # 현재 위치에서 도착점까지 비용
    # (현재까지 비용 + 지금 위치에서 도착점까지 걷는 비용)
    cost_via_current = current_cost + abs(current_node[0] - end_node[0]) + abs(current_node[1] - end_node[1])
    min_cost = min(min_cost, cost_via_current)
    
    # 텔레포트 
    if current_node in tp_dic:
        for next_node, tele_cost in tp_dic[current_node]:
            new_cost = current_cost + tele_cost
            if new_cost < distances[next_node]:
                distances[next_node] = new_cost
                heapq.heappush(pq, (new_cost, next_node))

    # 현재 위치에서 모든 텔레포트 지점까지 비용 계산
    for next_tp_node in tp_node:
        if current_node == next_tp_node:
            continue
            
        walk_cost = abs(current_node[0] - next_tp_node[0]) + abs(current_node[1] - next_tp_node[1])
        new_cost = current_cost + walk_cost
        
        if new_cost < distances[next_tp_node]:
            distances[next_tp_node] = new_cost
            heapq.heappush(pq, (new_cost, next_tp_node))

print(min_cost)
```