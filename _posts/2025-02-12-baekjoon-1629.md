---
layout: post
title: "[백준] 1629번 (Python)"
date: 2025-02-12
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1629"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1629](https://www.acmicpc.net/problem/1629)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 수 \( A \)의 거듭제곱을 \( C \)로 나눈 나머지를 구하는 문제입니다. Python의 재귀적인 분할 정복 방식을 활용하여 \( A^B \mod C \)를 효율적으로 계산합니다. 이 과정에서 거듭제곱을 반으로 나누어 계산하여 연산 횟수를 줄이는 방법을 사용합니다.

### 동작 과정
예를 들어, 입력으로 \( A = 3 \), \( B = 11 \), \( C = 5 \)가 주어진 경우를 살펴보겠습니다.

1. **초기 호출**: `multi(3, 11)`이 호출됩니다.
2. **재귀 호출**: \( n = 11 \)이 홀수이므로, `multi(3, 11)`은 `multi(3, 5)`와 \( 3 \)을 곱하는 방식으로 진행됩니다.
3. **재귀 호출**: `multi(3, 5)`가 호출됩니다. \( n = 5 \)가 다시 홀수이므로, `multi(3, 5)`는 `multi(3, 2)`와 \( 3 \)을 곱합니다.
4. **재귀 호출**: `multi(3, 2)`가 호출됩니다. \( n = 2 \)가 짝수이므로, `multi(3, 2)`는 `multi(3, 1)`을 두 번 곱합니다.
5. **재귀 호출**: `multi(3, 1)`이 호출됩니다. 여기서 \( n = 1 \)이므로 \( 3 \mod 5 \)를 반환합니다.
6. **결과 조합**: 이제 결과를 조합하여 올라갑니다. 
   - `multi(3, 1)`의 결과는 \( 3 \).
   - `multi(3, 2)`는 \( (3 * 3) \mod 5 = 4 \).
   - `multi(3, 5)`는 \( (4 * 4 * 3) \mod 5 = 2 \).
   - 마지막으로 `multi(3, 11)`은 \( (2 * 2 * 3) \mod 5 = 4 \).
7. **출력**: 최종적으로 \( 3^{11} \mod 5 = 4 \)가 출력됩니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 \( O(\log B) \)입니다. 이는 분할 정복 방식으로 거듭제곱을 반으로 나누어 계산하기 때문에 \( B \)의 크기에 따라 로그 시간에 처리가 가능하기 때문입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

a, b, c = map(int, input().split())

def multi(a, n):
    if n == 1:
        return a % c
    else:
        tmp = multi(a, n//2)
        if n % 2 == 0:
            return (tmp * tmp) % c
        else:
            return (tmp * tmp * a) % c

print(multi(a, b))




"""
A^m+n = A^m x A^n
(AxB)%C = (A%C) * (B%C) % C
(A^B)%C = (A^(B//2) * A^(B//2)) % C  (B 짝수)
        = (A^(B//2) * A^(B//2) * A) % C  (B 홀수)
"""
```