---
layout: post
title: "[백준] 9461번 (Python)"
date: 2024-09-28
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "9461"]
---

## 문제 링크
[https://www.acmicpc.net/problem/9461](https://www.acmicpc.net/problem/9461)

---

## 풀이

### 풀이 핵심 로직
이 문제는 특정 수의 판다리 수를 계산하는 문제로, DP(동적 계획법)를 이용해서 해결합니다. 판다리 수는 n이 1, 2, 3일 때는 각각 1이고, n이 4일 때는 2입니다. 그 이후의 수는 이전의 두 개 수와 세 개 수를 조합하여 얻을 수 있습니다. 즉, `P(n) = P(n-2) + P(n-3)`로 정의됩니다.

### 동작 과정
1. 입력을 통해 테스트 케이스의 수 `t`를 받습니다.
2. 판다리 수를 저장할 배열 `arr`을 초기화합니다. `arr`의 인덱스는 1부터 100까지의 판다리 수를 저장합니다.
3. 기본 판다리 수를 설정합니다:
   - `arr[1] = 1`
   - `arr[2] = 1`
   - `arr[3] = 1`
   - `arr[4] = 2`
4. 5부터 100까지의 판다리 수를 계산합니다. 각 `i`에 대해 `arr[i] = arr[i-2] + arr[i-3]`를 사용해 값을 업데이트합니다.
5. 각 테스트 케이스에 대해 n을 입력받고, 해당 n에 대한 판다리 수 `arr[n]`를 출력합니다.

**예시 입력**:
```
3
4
5
6
```
**예시 출력**:
```
2
2
3
```
- 4에 대한 출력은 2 (`arr[4]`)
- 5에 대한 출력은 2 (`arr[5]` = `arr[3] + arr[2]` = 1 + 1)
- 6에 대한 출력은 3 (`arr[6]` = `arr[4] + arr[3]` = 2 + 1)

### 시간 복잡도
O(n) - 여기서 n은 100으로 고정되어 있으므로, 상수 시간으로 간주할 수 있습니다. 각 판다리 수를 계산하는 데 필요한 반복문은 96번(iterating from 5 to 100) 실행되며, 이는 상수 시간으로 처리되므로 전체 시간 복잡도는 O(1)로 표현될 수 있습니다.

---

## 코드
```python
import sys

t=int(input())
arr = [0] * 101
arr[1] = 1
arr[2] = 1
arr[3] = 1
arr[4] = 2

for i in range(5,101):
    arr[i] = arr[i-2] + arr[i-3]

for _ in range(t):
    n=int(input())
    print(arr[n])

    
```