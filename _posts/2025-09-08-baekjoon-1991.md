---
layout: post
title: "[백준] 1991번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1991"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1991](https://www.acmicpc.net/problem/1991)

---

## 풀이

### 풀이 핵심 로직
이 문제에서는 이진 트리를 표현하고, 이를 전위(preorder), 중위(inorder), 후위(postorder) 순회하는 방법을 구현합니다. 이진 트리는 딕셔너리를 사용하여 각 노드와 그 자식 노드의 관계를 저장하고, 재귀 함수를 통해 깊이 우선 탐색을 수행하여 노드를 방문합니다.

### 동작 과정
1. 입력받은 노드 개수 `n`만큼 반복하여 각 노드와 그 자식 노드를 딕셔너리 `heap`에 저장합니다. 예를 들어, 입력이 다음과 같다면:
   ```
   7
   A B C
   B D .
   C E F
   D . .
   E . .
   F . G
   G . .
   ```
   이는 다음과 같은 구조의 이진 트리를 형성합니다:
   ```
       A
      / \
     B   C
    /   / \
   D   E   F
          /
         G
   ```

2. 각 순회 방식(전위, 중위, 후위)에 따라 해당하는 함수를 호출하여 노드를 방문합니다.
   - **전위 순회**: A → B → D → C → E → F → G
   - **중위 순회**: D → B → A → E → C → G → F
   - **후위 순회**: D → B → E → G → F → C → A

3. 각 함수는 현재 노드를 방문한 후, 왼쪽 자식과 오른쪽 자식을 재귀적으로 방문하면서 결과를 출력합니다. 빈 노드(`.`)는 방문하지 않습니다.

### 시간 복잡도
전체 노드 수가 `N`일 때, 각 노드를 한 번씩 방문하므로 시간 복잡도는 O(N)입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
heap = {}

for _ in range(n):
    a, b, c = input().split()
    heap[a] = [b, c]  # {노드: (왼쪽 자식, 오른쪽 자식)}

def preorder(node):  # 현재 노드를 방문 → 왼쪽 서브트리 → 오른쪽 서브트리
    if node == '.':
        return
    print(node, end='')
    preorder(heap[node][0])
    preorder(heap[node][1])

def inorder(node):  # 왼쪽 서브트리 → 현재 노드 방문 → 오른쪽 서브트리
    if node == '.':
        return
    inorder(heap[node][0])
    print(node, end='')
    inorder(heap[node][1])

def postorder(node):  # 왼쪽 서브트리 → 오른쪽 서브트리 → 현재 노드 방문
    if node == '.':
        return
    postorder(heap[node][0])
    postorder(heap[node][1])
    print(node, end='')

preorder('A')
print()
inorder('A')
print()
postorder('A')
print()




"""
노드 개수 N
방문 시간 O(1)
전체 연산 O(N)
"""
```