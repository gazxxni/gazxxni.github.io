---
layout: post
title: "[백준] 17103번 골드바흐 파티션 (Python)"
date: 2026-01-15
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "17103", 수학, 정수론, 소수 판정, 에라토스테네스의 체]
---

## 문제 링크
[https://www.acmicpc.net/problem/17103](https://www.acmicpc.net/problem/17103)

---

## 문제
골드바흐의 추측: 2보다 큰 짝수는 두 소수의 합으로 나타낼 수 있다.


짝수 N을 두 소수의 합으로 나타내는 표현을 골드바흐 파티션이라고 한다. 짝수 N이 주어졌을 때, 골드바흐 파티션의 개수를 구해보자. 두 소수의 순서만 다른 것은 같은 파티션이다.

---

## 입력
첫째 줄에 테스트 케이스의 개수 T (1 ≤ T ≤ 100)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 N은 짝수이고, 2

---

## 출력
각각의 테스트 케이스마다 골드바흐 파티션의 수를 출력한다.

---

## 성능 요약
메모리: 134592 KB, 시간: 212 ms

---

## 풀이

### 풀이 핵심 로직
골드바흐의 추측에 따라 주어진 짝수 N을 두 소수의 합으로 나타내는 방법의 개수를 구하기 위해, 먼저 에라토스테네스의 체를 사용하여 1,000,000 이하의 모든 소수를 미리 구합니다. 이후, 각 테스트 케이스에서 주어진 N에 대해 N/2 이하의 소수를 순회하며, N에서 현재 소수를 뺀 값이 소수 집합에 존재하는지를 확인하여 골드바흐 파티션의 개수를 셉니다.

### 동작 과정
1. **입력 예시**: 
   ```
   2
   8
   10
   ```
   여기서 첫 번째 줄은 테스트 케이스의 수 T=2, 다음 줄에 각각 짝수 N=8, 10이 주어집니다.

2. **소수 구하기**: 
   1,000,000 이하의 소수를 에라토스테네스의 체를 사용하여 구합니다. 결과적으로 소수 리스트 `a`와 소수 집합 `b`가 생성됩니다.

3. **골드바흐 파티션 계산**:
   - **N=8**:
     - 소수 리스트 `a`에서 2, 3, 5, 7을 확인합니다.
     - 2를 선택하면 8-2=6이 소수 집합에 없으므로 넘어갑니다.
     - 3을 선택하면 8-3=5가 소수 집합에 있으므로 카운트 증가 (cnt=1).
     - 5를 선택하면 8-5=3이 소수 집합에 있으므로 카운트 증가 (cnt=2).
     - 7을 선택하면 8-7=1이 소수 집합에 없으므로 넘어갑니다.
     - 최종 결과: 2.

   - **N=10**:
     - 소수 리스트 `a`에서 2, 3, 5, 7를 확인합니다.
     - 2를 선택하면 10-2=8이 소수 집합에 없으므로 넘어갑니다.
     - 3을 선택하면 10-3=7이 소수 집합에 있으므로 카운트 증가 (cnt=1).
     - 5를 선택하면 10-5=5가 소수 집합에 있으므로 카운트 증가 (cnt=2).
     - 7을 선택하면 10-7=3가 소수 집합에 있으므로 카운트 증가 (cnt=3).
     - 최종 결과: 3.

4. **출력**:
   ```
   2
   3
   ```

### 시간 복잡도
- 소수 구하기: 에라토스테네스의 체를 사용하여 O(N log log N) (N=1,000,000).
- 각 테스트 케이스에서의 소수 검색: O(N/2) (최대 500,000).
- 따라서 전체 시간 복잡도는 O(T * (N/2))로, 최악의 경우 O(100 * 500,000) = O(50,000,000)입니다.

---

## 코드
```python
def primenum(n):
    arr = [True] * (n + 1)
    arr[0] = arr[1] = False
    
    for i in range(2, int(n ** 0.5) + 1):
        if arr[i]:
            for j in range(i * i, n + 1, i):
                arr[j] = False
                
    brr = []
    for i in range(2, n + 1):
        if arr[i]:
            brr.append(i)
            
    return brr

a = primenum(1000000)
b = set(a)
t = int(input())

for _ in range(t):
    n = int(input())

    cnt = 0

    for i in a:
        if i > n // 2:
            break
        
        if (n - i) in b:
            cnt += 1
            
    print(cnt)
```