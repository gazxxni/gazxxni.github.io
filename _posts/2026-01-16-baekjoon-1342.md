---
layout: post
title: "[백준] 1342번 행운의 문자열 (Python)"
date: 2026-01-16
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1342", 브루트포스 알고리즘, 집합과 맵, 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/1342](https://www.acmicpc.net/problem/1342)

---

## 문제
민식이와 준영이는 자기 방에서 문자열을 공부하고 있다. 민식이가 말하길 인접해 있는 모든 문자가 같지 않은 문자열을 행운의 문자열이라고 한다고 한다. 준영이는 문자열 S를 분석하기 시작했다. 준영이는 문자열 S에 나오는 문자를 재배치하면 서로 다른 행운의 문자열이 몇 개 나오는지 궁금해졌다. 만약 원래 문자열 S도 행운의 문자열이라면 그것도 개수에 포함한다.

---

## 입력
첫째 줄에 문자열 S가 주어진다. S의 길이는 최대 10이고, 알파벳 소문자로만 이루어져 있다.

---

## 출력
첫째 줄에 위치를 재배치해서 얻은 서로 다른 행운의 문자열의 개수를 출력한다.

---

## 성능 요약
메모리: 113412 KB, 시간: 1512 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 문자열에서 인접한 문자가 같지 않은 문자열을 만들기 위해, 백트래킹을 이용하여 가능한 모든 조합을 탐색하는 방식으로 해결합니다. 먼저 주어진 문자열의 각 문자의 개수를 세고, 이를 기반으로 재배치 가능한 문자열을 생성할 때 인접한 문자가 같지 않도록 조건을 설정하여 탐색합니다.

### 동작 과정
1. 입력으로 주어진 문자열 `S`를 리스트로 변환하고, 각 문자의 빈도를 세기 위해 딕셔너리 `dic`를 사용합니다.
   - 예시 입력: `"aabb"`
   - `dic`의 결과: `{'a': 2, 'b': 2}`

2. 재귀 함수 `back(dic, before, use)`를 정의하여, 현재 사용된 문자와 이전에 사용한 문자를 비교하여 인접한 문자가 같지 않은지를 체크합니다. 
   - `before`는 이전에 사용한 문자, `use`는 현재까지 사용한 문자 수를 나타냅니다.

3. 재귀 호출을 통해 가능한 문자를 선택하고, 선택한 문자의 개수를 줄인 후 다시 재귀 호출합니다. 모든 문자를 사용했을 때 (즉, `use`가 문자열의 길이와 같을 때) 카운트를 증가시킵니다.

4. 모든 경우의 수를 탐색한 후, 최종적으로 카운트를 출력합니다.

   **단계별 예시**:
   - 문자열 `"aabb"`의 경우, 가능한 행운의 문자열은:
     - `abab`, `abba`, `baab`, `baba`, `aabb` 등 8개가 생성됩니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(N!)입니다. N은 문자열의 길이로, 각 문자를 재배치하는 모든 경우를 탐색하게 됩니다. 문자열 길이가 최대 10이므로, 10! (3628800)까지의 경우를 탐색할 수 있습니다. 하지만 중복 문자가 있는 경우에는 같은 조합이 여러 번 계산되는 것을 방지하여 최적화할 수 있습니다.

---

## 코드
```python
s = list(input().rstrip())
l = len(s)
dic = {}

for i in s:
    dic[i] = dic.get(i, 0) + 1

cnt = 0
def back(dic, before, use):
    global cnt
    if use == l:
        cnt += 1
        return
    
    for k, v in dic.items():
        if v > 0 and k != before:
            dic[k] -= 1
            back(dic, k, use + 1)
            dic[k] += 1

back(dic, None, 0)
print(cnt)

```