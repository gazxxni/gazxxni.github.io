---
layout: post
title: "[백준] 11724번 (Python)"
date: 2024-09-28
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "11724"]
---

## 문제 링크
[https://www.acmicpc.net/problem/11724](https://www.acmicpc.net/problem/11724)

---

## 풀이

### 풀이 핵심 로직
이 문제는 연결 요소의 개수를 찾는 문제로, BFS(너비 우선 탐색) 알고리즘을 사용하여 그래프를 탐색합니다. 각 노드에 대해 방문하지 않은 노드를 발견할 때마다 BFS를 시작하고, 이로 인해 탐색된 모든 노드를 하나의 연결 요소로 간주하여 카운트합니다.

### 동작 과정
예를 들어, 입력이 다음과 같다고 가정합시다:
```
5 4
1 2
2 3
4 5
```
1. 첫 번째 줄에서 `n=5`, `m=4`를 읽어들입니다. 즉, 5개의 노드와 4개의 간선이 있습니다.
2. 그래프를 초기화합니다: `graph = [[], [], [], [], [], []]`.
3. 주어진 간선 정보를 통해 그래프를 구성합니다:
   - `1 2`를 추가하면 `graph = [[], [2], [1], [], [], []]`.
   - `2 3`을 추가하면 `graph = [[], [2], [1, 3], [2], [], []]`.
   - `4 5`를 추가하면 `graph = [[], [2], [1, 3], [2], [5], [4]]`.
4. 방문 배열을 초기화합니다: `visited = [False, False, False, False, False, False]`.
5. 노드 1부터 5까지 반복하면서 방문하지 않은 노드를 찾습니다:
   - 노드 1을 방문하지 않았으므로, BFS를 시작합니다. BFS는 노드 1에서 시작하여 노드 2, 3을 방문하게 됩니다. 이 과정에서 `cnt`를 1 증가시킵니다.
   - 노드 2, 3은 이미 방문했으므로 스킵됩니다.
   - 노드 4는 방문하지 않았으므로, BFS를 시작하여 노드 5를 방문하게 됩니다. 이 과정에서 `cnt`를 1 증가시킵니다.
6. 최종적으로 `cnt`의 값은 2로 출력됩니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(V + E)입니다. 여기서 V는 정점의 수(n), E는 간선의 수(m)입니다. BFS는 모든 정점을 한 번씩 방문하고, 각 간선을 한 번씩 탐색하기 때문에 이와 같은 복잡도를 가집니다.

---

## 코드
```python
from collections import deque
import sys
input = sys.stdin.readline

def bfs(graph, start, visited):
    queue = deque([start])  # 큐에 시작점을 넣고 시작
    visited[start] = True  # 시작점을 방문했다고 표시

    while queue:  # 큐가 빌 때까지 반복
        v = queue.popleft()  # 큐에서 노드를 하나 꺼냄
        for i in graph[v]: 
            if not visited[i]: 
                queue.append(i)
                visited[i] = True 

n, m = map(int, input().split()) 
graph = [[] for _ in range(n+1)] 

for i in range(m):
    u, v = map(int, input().split()) 
    graph[u].append(v)  # u에서 v 간선 추가
    graph[v].append(u)  # v에서 u 간선 추가 (무방향 그래프)

cnt = 0 
visited = [False] * (n+1)  # 각 노드의 방문 여부를 저장

for i in range(1, n+1): 
    if not visited[i]: 
        bfs(graph, i, visited) 
        cnt += 1  # BFS가 끝나면 하나의 연결 요소를 모두 방문, cnt 증가

print(cnt)

```