---
layout: post
title: "[백준] 1027번 고층 건물 (Python)"
date: 2026-01-27
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1027", 수학, 브루트포스 알고리즘, 기하학]
---

## 문제 링크
[https://www.acmicpc.net/problem/1027](https://www.acmicpc.net/problem/1027)

---

## 문제
세준시에는 고층 빌딩이 많다. 세준시의 서민 김지민은 가장 많은 고층 빌딩이 보이는 고층 빌딩을 찾으려고 한다. 빌딩은 총 N개가 있는데, 빌딩은 선분으로 나타낸다. i번째 빌딩 (1부터 시작)은 (i,0)부터 (i,높이)의 선분으로 나타낼 수 있다. 고층 빌딩 A에서 다른 고층 빌딩 B가 볼 수 있는 빌딩이 되려면, 두 지붕을 잇는 선분이 A와 B를 제외한 다른 고층 빌딩을 지나거나 접하지 않아야 한다. 가장 많은 고층 빌딩이 보이는 빌딩을 구하고, 거기서 보이는 빌딩의 수를 출력하는 프로그램을 작성하시오.

---

## 입력
첫째 줄에 빌딩의 수 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에 1번 빌딩부터 그 높이가 주어진다. 높이는 1,000,000,000보다 작거나 같은 자연수이다.

---

## 출력
첫째 줄에 문제의 정답을 출력한다.

---

## 성능 요약
메모리: 109544 KB, 시간: 92 ms

---

## 풀이

### 풀이 핵심 로직
주어진 문제에서는 각 고층 빌딩에서 볼 수 있는 다른 고층 빌딩의 수를 계산해야 합니다. 이를 위해 두 빌딩을 연결하는 선의 기울기를 계산하여, 이 기울기가 현재까지 확인한 다른 빌딩의 높이보다 크거나 작아야만 해당 빌딩을 볼 수 있다고 판단합니다. 이 과정을 모든 빌딩에 대해 반복하여 최대 볼 수 있는 빌딩의 수를 찾습니다.

### 동작 과정
1. 입력으로 `N`과 각 빌딩의 높이를 받습니다.
2. 각 빌딩 `i`에 대해 왼쪽 방향과 오른쪽 방향으로 볼 수 있는 빌딩의 수를 별도로 계산합니다.
   - 왼쪽 방향에서는 `i-1`부터 0번 빌딩까지 거꾸로 탐색하며, 현재 빌딩의 기울기와 비교하여 볼 수 있는 빌딩을 카운트합니다. 기울기는 `cal(x1, y1, x2, y2)` 함수를 통해 계산합니다.
   - 오른쪽 방향도 마찬가지로 `i+1`부터 N-1까지 탐색하여 카운트합니다.
3. 각 빌딩에서 카운트한 볼 수 있는 빌딩의 수를 합산하여 최대값을 갱신합니다.
4. 최종적으로 최대 볼 수 있는 빌딩의 수를 출력합니다.

예시 입력:
```
5
3 5 4 2 1
```
- 1번 빌딩(높이 3)은 2, 3, 4번 빌딩을 볼 수 있습니다. (3개)
- 2번 빌딩(높이 5)은 3, 4, 5번 빌딩을 볼 수 있습니다. (3개)
- 3번 빌딩(높이 4)은 4, 5번 빌딩을 볼 수 있습니다. (2개)
- 4번 빌딩(높이 2)은 5번 빌딩을 볼 수 있습니다. (1개)
- 5번 빌딩(높이 1)은 볼 수 있는 빌딩이 없습니다. (0개)

최대 볼 수 있는 빌딩의 수는 3입니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(N^2)입니다. 각 빌딩에 대해 최대 N-1개의 빌딩을 확인하므로, 전체적으로 N개의 빌딩에 대해 N-1개의 탐색을 수행하게 됩니다.

---

## 코드
```python
n = int(input())
arr = list(map(int, input().split()))\
    
def cal(x1, y1, x2, y2):
    return (y2 - y1) / (x2 - x1)

if n == 1:
    print(0)

else:
    ans = 0

    for i in range(n):
        cnt = 0
        cur = float('inf')

        for j in range(i - 1, -1, -1):
            nxt = cal(i, arr[i], j , arr[j])
            
            if nxt < cur:
                cur = nxt
                cnt += 1
                
        cur = -float('inf')
        
        for j in range(i + 1, n):
            nxt = cal(i, arr[i], j, arr[j])
            
            if nxt > cur:
                cur = nxt
                cnt += 1
                
        ans = max(ans, cnt)
        
    print(ans)
```