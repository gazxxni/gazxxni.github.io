---
layout: post
title: "[백준] 17103번 (Python)"
date: 2025-10-14
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "17103"]
---

## 문제 링크
[https://www.acmicpc.net/problem/17103](https://www.acmicpc.net/problem/17103)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 '골드바흐의 추측'을 이용하여 주어진 짝수 \( n \)을 두 개의 소수의 합으로 표현할 수 있는 방법의 수를 구하는 것이다. 먼저, 에라토스테네스의 체를 사용하여 \( 1,000,000 \)까지의 모든 소수를 미리 구한 후, 각 테스트 케이스에서 주어진 짝수 \( n \)에 대해 \( n \)을 구성하는 두 소수의 쌍을 찾아 그 개수를 센다.

### 동작 과정
1. **소수 생성**: `primenum` 함수가 호출되어 \( 1,000,000 \)까지의 소수를 구한다. 이 과정에서 에라토스테네스의 체를 사용하여 소수를 판별하고, 소수를 리스트 `brr`에 저장한다.
2. **입력 처리**: 사용자가 입력한 테스트 케이스 수 \( t \)만큼 반복한다.
3. **짝수 \( n \)에 대한 소수 쌍 계산**:
   - 각 \( n \)에 대해, 리스트 `a`의 소수들 중 \( n/2 \)보다 작은 소수를 순회한다.
   - 현재 소수 \( i \)에 대해 \( n - i \)가 소수 집합 `b`에 존재하는지 확인한다. 존재하면 카운트를 증가시킨다.
4. **결과 출력**: 각 테스트 케이스에 대해 가능한 소수 쌍의 수를 출력한다.

예를 들어, 입력이 4일 경우:
- \( n = 4 \)일 때, 소수 리스트는 [2, 3].
- \( i = 2 \)일 때, \( n - i = 2 \), 2는 소수이므로 카운트 증가.
- \( i = 3 \)일 때 \( 3 > 4/2 \)이므로 반복 종료.
- 최종적으로 1을 출력.

### 시간 복잡도
소수를 구하는 과정의 시간 복잡도는 \( O(n \log \log n) \)이고, 각 테스트 케이스에서 소수 쌍을 찾는 과정의 시간 복잡도는 \( O(k) \) (여기서 \( k \)는 \( n/2 \)보다 작은 소수의 개수)이다. 따라서 전체 시간 복잡도는 \( O(n \log \log n + t \cdot k) \)로 볼 수 있다.

---

## 코드
```python
def primenum(n):
    arr = [True] * (n + 1)
    arr[0] = arr[1] = False
    
    for i in range(2, int(n ** 0.5) + 1):
        if arr[i]:
            for j in range(i * i, n + 1, i):
                arr[j] = False
                
    brr = []
    for i in range(2, n + 1):
        if arr[i]:
            brr.append(i)
            
    return brr

a = primenum(1000000)
b = set(a)
t = int(input())

for _ in range(t):
    n = int(input())

    cnt = 0

    for i in a:
        if i > n // 2:
            break
        
        if (n - i) in b:
            cnt += 1
            
    print(cnt)
```