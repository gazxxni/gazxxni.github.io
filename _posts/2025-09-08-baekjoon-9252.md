---
layout: post
title: "[백준] 9252번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "9252"]
---

## 문제 링크
[https://www.acmicpc.net/problem/9252](https://www.acmicpc.net/problem/9252)

---

## 풀이

### 풀이 핵심 로직
이 문제는 두 문자열의 가장 긴 공통 부분 수열(Longest Common Subsequence, LCS)을 찾는 문제입니다. 이를 위해 동적 계획법(Dynamic Programming)을 사용하여 각 문자열의 모든 조합에서 LCS의 길이를 계산하고, 최종적으로 LCS 문자열을 복원합니다.

### 동작 과정
1. **입력**: 두 문자열 `a`와 `b`를 입력받습니다.
   - 예시 입력:
     ```
     ACAYKP
     CAPCAK
     ```
   
2. **LCS 테이블 초기화**: `lcs`라는 2차원 리스트를 생성하여, 각 문자열의 길이에 1을 더한 크기로 초기화합니다. 각 요소는 0으로 초기화됩니다.

3. **LCS 길이 계산**: 이중 루프를 통해 `a`와 `b`의 각 문자를 비교합니다.
   - 만약 `a[i-1]`와 `b[j-1]`가 같다면, `lcs[i][j]`는 `lcs[i-1][j-1] + 1`이 됩니다.
   - 다르면, `lcs[i][j]`는 `lcs[i][j-1]`와 `lcs[i-1][j]` 중 큰 값을 선택합니다.
   - 이 과정을 통해 `lcs` 테이블을 채웁니다.

4. **LCS 문자열 복원**: 테이블을 바탕으로 LCS 문자열을 역추적합니다.
   - 두 문자열의 끝에서 시작하여, 문자가 같으면 해당 문자를 LCS 문자열에 추가하고, 각각의 인덱스를 하나씩 감소시킵니다.
   - 문자가 다르면 LCS 길이가 더 큰 쪽으로 인덱스를 이동합니다.
   
5. **출력**: 최종 LCS의 길이 (`lcs[len(a)][len(b)]`)와 LCS 문자열을 출력합니다.
   - 예시 출력:
     ```
     4
     ACAY
     ```

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(N * M)입니다. 여기서 N은 첫 번째 문자열의 길이, M은 두 번째 문자열의 길이입니다. 이중 루프를 통해 모든 부분 문제를 계산하고, 각 문자열을 한 번씩만 탐색하여 LCS를 복원하기 때문에 이 복잡도를 갖습니다.

---

## 코드
```python
import sys

a = list(input())
b = list(input())

lcs = [[0] * (len(b) + 1) for _ in range(len(a) + 1)]

for i in range(1, len(a) + 1):  
    for j in range(1, len(b) + 1):  
        if a[i-1] == b[j-1]:
            lcs[i][j] = lcs[i-1][j-1] + 1
        else:
            lcs[i][j] = max(lcs[i][j-1], lcs[i-1][j])

i, j = len(a), len(b)
lcs_chars = []

while i > 0 and j > 0:
    if a[i-1] == b[j-1]:
        lcs_chars.append(a[i-1])
        i -= 1; j -= 1

    else:
        if lcs[i-1][j] >= lcs[i][j-1]:
            i -= 1
        else:
            j -= 1

ans = ''.join(reversed(lcs_chars))

print(lcs[len(a)][len(b)])
print(ans)
```