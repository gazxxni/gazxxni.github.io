---
layout: post
title: "[백준] 1654번 (Python)"
date: 2024-07-23
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1654"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1654](https://www.acmicpc.net/problem/1654)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 랜선의 길이로부터 n개의 랜선을 만들기 위해 가장 긴 랜선의 길이를 이진 탐색을 사용하여 찾는 문제입니다. 이진 탐색을 통해 가능한 랜선의 길이를 탐색하고, 각 길이에 대해 만들 수 있는 랜선의 개수를 계산하여 조건을 만족하는 최대 길이를 찾습니다.

### 동작 과정
예를 들어, 입력이 `4 11`이 주어지고 랜선의 길이가 `802`, `743`, `457`, `539`인 경우를 생각해봅시다.

1. **초기 설정**: 
   - 랜선의 개수 `k = 4`, 필요한 랜선의 개수 `n = 11`
   - 랜선 길이 목록 `lan = [802, 743, 457, 539]`
   - 시작점 `start = 1`, 끝점 `end = 802` (최대 랜선 길이)

2. **첫 번째 이진 탐색**:
   - `mid = (1 + 802) // 2 = 401`
   - 각 랜선에서 `401`로 나누어 몇 개의 랜선을 만들 수 있는지 계산:
     - `802 // 401 = 2`
     - `743 // 401 = 1`
     - `457 // 401 = 1`
     - `539 // 401 = 1`
   - 총 랜선 개수 `lines = 5`, 이는 `11`보다 작으므로 `end = mid - 1 = 400`으로 이동.

3. **두 번째 이진 탐색**:
   - `mid = (1 + 400) // 2 = 200`
   - 랜선 길이로부터 만들 수 있는 랜선 개수 계산:
     - `802 // 200 = 4`
     - `743 // 200 = 3`
     - `457 // 200 = 2`
     - `539 // 200 = 2`
   - 총 랜선 개수 `lines = 11`, 현재 조건을 만족하므로 `start = mid + 1 = 201`로 이동.

4. **계속 이진 탐색**:
   - 이 과정을 반복하여 `start`가 `end`보다 커질 때까지 진행합니다.
   - 최종적으로 `end` 값이 최대 랜선 길이를 나타냅니다.

5. **출력**:
   - `end` 값을 출력하여 답을 구합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(k log(max_length))입니다. 
- 여기서 `k`는 랜선의 개수이며, `log(max_length)`는 이진 탐색을 수행하는 데 필요한 시간입니다.

---

## 코드
```python
import sys

k,n=map(int,input().split())

lan=[int(sys.stdin.readline())for _ in range(k)]

start,end=1,max(lan)

while start <=end:
    mid=(start+end)//2
    lines=0

    for i in lan:
        lines+=i//mid

    if lines>=n:
        start=mid+1

    else:
        end=mid-1

print(end)


```