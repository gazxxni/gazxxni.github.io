---
layout: post
title: "[백준] 31995번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "31995"]
---

## 문제 링크
[https://www.acmicpc.net/problem/31995](https://www.acmicpc.net/problem/31995)

---

## 풀이

### 풀이 핵심 로직
주어진 문제는 연속된 증가하는 수열의 개수를 계산하는 것입니다. 이를 위해, 배열의 연속된 두 요소의 크기를 비교하여 증가하는 구간을 확인하고, 각 증가하는 구간의 길이에 따라 조합을 계산하여 해당 구간의 모든 부분 증가 수열의 개수를 구합니다.

### 동작 과정
1. **입력 받기**: 첫째 줄에 수의 개수 `n`을, 둘째 줄에 `n`개의 정수를 입력받습니다.
2. **증가 여부 체크**: `check` 리스트를 생성하여, 각 요소가 다음 요소보다 작은지를 비교하여 True/False 값을 저장합니다. 예를 들어, 입력이 `5 2 3 4 1`일 경우 `check`는 `[True, True, False, False]`가 됩니다.
3. **카운팅**: `ans` 변수를 `n`으로 초기화하고, 증가하는 구간의 길이를 세기 위한 `t` 변수를 초기화합니다. `check` 리스트를 순회하며:
   - True인 경우 `t`를 증가시킵니다.
   - False인 경우, 현재까지의 증가 구간 `t`에 대해 모든 부분 수열의 개수를 계산하여 `ans`에 더하고, `t`를 0으로 초기화합니다.
4. **마무리**: 반복이 끝난 후 남아있는 증가 구간에 대해서도 계산하여 `ans`에 더합니다.
5. **결과 출력**: 최종적으로 `ans` 값을 출력합니다.

예시 입력: `5` (수의 개수)  
예시 배열: `2 3 4 1 5`  
- `check`는 `[True, True, False, True]`가 됨.
- 증가 구간: `2, 3, 4`의 길이는 3 (부분 수열: 2, 3, 4, 2 3, 2 4, 3 4, 2 3 4) → `3*(3+1)/2 = 6`을 `ans`에 더함.
- `ans`는 최종적으로 8이 됨.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n)입니다. 입력 배열을 한 번 순회하여 증가 여부를 체크하고, 다시 한 번 순회하여 증가하는 구간을 계산하기 때문입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
arr = list(map(int, input().split()))

check = [arr[i] < arr[i+1] for i in range(n-1)]

ans = n
t = 0
for b in check:
    if b:
        t += 1
    else:
        ans += t * (t + 1) // 2
        t = 0
ans += t * (t + 1) // 2 

print(ans)

```