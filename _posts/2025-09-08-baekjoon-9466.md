---
layout: post
title: "[백준] 9466번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "9466"]
---

## 문제 링크
[https://www.acmicpc.net/problem/9466](https://www.acmicpc.net/problem/9466)

---

## 풀이

### 풀이 핵심 로직
이 문제는 학생들이 선택한 조가 서로 연결된 그래프를 구성하고, 이 그래프에서 사이클을 찾아내어 사이클에 포함된 학생 수를 계산하는 문제입니다. 최종적으로 사이클에 포함되지 않은 학생 수를 출력합니다. 각 학생이 선택한 조를 따라가며 사이클을 탐색하고, 사이클을 형성하는 학생을 카운트하여 해결합니다.

### 동작 과정
예를 들어, 입력이 다음과 같다고 가정해 보겠습니다:
```
1
5
2 3 1 5 4
```

1. **입력 처리**: 테스트 케이스 수 `t`가 1임을 읽고, `n`은 5, 배열 `arr`은 `[0, 2, 3, 1, 5, 4]`가 됩니다. 여기서 `arr`의 인덱스는 학생 번호, 값은 그 학생이 선택한 조의 번호입니다.
   
2. **사이클 탐색**:
   - `check` 배열은 각 학생의 상태를 나타내며, `0`은 미방문, `1`은 방문 중, `2`는 방문 완료를 의미합니다.
   - 학생 1부터 시작하여, 학생 1이 선택한 학생(2)으로 이동하고, 계속해서 선택한 학생으로 이동합니다. 이 과정을 반복하여 학생 3(1)로 돌아오면 사이클이 발견됩니다.
   - 사이클의 크기를 계산하며, 학생 1, 2, 3이 사이클에 포함됨을 알게 됩니다. `res`에 사이클 크기(3)를 더합니다.

3. **방문 완료 처리**: 사이클 내의 모든 학생(1, 2, 3)에 대해 `check`를 업데이트하여 `2`로 설정합니다.

4. **결과 출력**: 사이클에 포함되지 않은 학생 수는 총 학생 수(5)에서 사이클 내 학생 수(3)를 빼서 `2`입니다. 이를 출력합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n)입니다. 각 학생에 대해 최대 한 번씩 사이클을 탐색하므로, 모든 학생을 처리하는 데 선형 시간만 소요됩니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

t = int(input())

for _ in range(t):
    n = int(input())
    arr = [0] + list(map(int, input().split()))
    check = [0] * (n + 1)
    res = 0

    for i in range(1, n + 1):
        if check[i] != 0:
            continue

        cur = i

        while check[cur] == 0:
            check[cur] = 1
            cur = arr[cur]

        if check[cur] == 1:
            cycle_start = cur
            cnt = 1
            nxt = arr[cur]

            while nxt != cycle_start:
                cnt += 1
                nxt = arr[nxt]

            res += cnt

        cur = i

        while check[cur] == 1:
            check[cur] = 2
            cur = arr[cur]

    print(n - res)
```