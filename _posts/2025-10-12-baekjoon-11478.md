---
layout: post
title: "[백준] 11478번 (Python)"
date: 2025-10-12
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "11478"]
---

## 문제 링크
[https://www.acmicpc.net/problem/11478](https://www.acmicpc.net/problem/11478)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 주어진 문자열의 모든 부분 문자열을 생성하여, 중복을 제거한 후 그 개수를 세는 것입니다. `defaultdict`를 사용하여 각 부분 문자열을 키로 하고 해당 문자열의 빈도를 값으로 저장함으로써 자동으로 중복을 처리할 수 있습니다.

### 동작 과정
1. 입력 문자열을 읽어온다. 예를 들어, 입력이 "abc"라고 가정하자.
2. `defaultdict`를 사용하여 빈 딕셔너리를 생성한다.
3. 두 개의 반복문을 사용하여 모든 가능한 부분 문자열을 생성한다.
   - 첫 번째 반복문은 부분 문자열의 길이를 결정한다. (1부터 문자열 길이까지)
   - 두 번째 반복문은 시작 인덱스를 결정하여 해당 길이의 부분 문자열을 생성한다.
4. 각 부분 문자열을 딕셔너리에 추가하며 빈도를 증가시킨다.
5. 마지막으로 딕셔너리의 길이를 출력하여 서로 다른 부분 문자열의 개수를 출력한다.

예시 입력 "abc"에 대한 단계별 설명:
- i=1: 부분 문자열은 "a", "b", "c" (3개)
- i=2: 부분 문자열은 "ab", "bc" (2개)
- i=3: 부분 문자열은 "abc" (1개)
- 최종적으로 딕셔너리에 저장된 부분 문자열은 {"a", "b", "c", "ab", "bc", "abc"}로 총 6개가 된다.

### 시간 복잡도
시간 복잡도는 O(n^2)입니다. 여기서 n은 문자열의 길이입니다. 두 개의 반복문이 중첩되어 있으므로, 각 반복문은 최악의 경우 n번씩 실행되기 때문입니다.

---

## 코드
```python
from collections import defaultdict
s = input().rstrip()
dic = defaultdict(int)
for i in range(1, len(s) + 1):
    for j in range(0, len(s)):
        a = s[j:j + i]
        dic[a] += 1
        
print(len(dic))
```