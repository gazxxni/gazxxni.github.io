---
layout: post
title: "[백준] 12865번 (Python)"
date: 2025-02-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "12865"]
---

## 문제 링크
[https://www.acmicpc.net/problem/12865](https://www.acmicpc.net/problem/12865)

---

## 풀이

### 풀이 핵심 로직
문제는 0-1 배낭 문제로, 주어진 물건들 중에서 무게의 합이 최대 k를 넘지 않도록 선택하여 가치의 합을 최대화하는 문제입니다. 이 문제는 동적 계획법을 사용하여 해결하며, 각 물건에 대해 넣거나 넣지 않는 경우를 비교하여 최적의 가치를 구합니다.

### 동작 과정
주어진 예시 입력으로 설명하겠습니다. 예를 들어, n = 3 (물건의 개수), k = 7 (배낭의 최대 용량)이고, 물건의 정보가 다음과 같다고 가정합니다:
```
물건 1: 무게 6, 가치 30
물건 2: 무게 3, 가치 14
물건 3: 무게 4, 가치 16
```

1. **초기화**: dp 배열을 생성하여 dp[i][j]는 i번째 물건까지 고려했을 때, 무게 j 이하에서의 최대 가치를 저장합니다. 초기에는 모두 0으로 설정합니다.

2. **첫 번째 물건 (무게 6, 가치 30)**:
   - j = 0부터 5까지는 이 물건을 넣을 수 없으므로 dp[1][j] = 0입니다.
   - j = 6부터 7까지는 물건을 넣을 수 있으므로 dp[1][6] = 30, dp[1][7] = 30으로 업데이트됩니다.

3. **두 번째 물건 (무게 3, 가치 14)**:
   - j = 0부터 2까지는 이 물건을 넣을 수 없으므로 dp[2][j] = dp[1][j]입니다.
   - j = 3: dp[2][3] = max(dp[1][3], dp[1][0] + 14) = max(0, 14) = 14
   - j = 4: dp[2][4] = max(dp[1][4], dp[1][1] + 14) = max(0, 14) = 14
   - j = 5: dp[2][5] = max(dp[1][5], dp[1][2] + 14) = max(0, 14) = 14
   - j = 6: dp[2][6] = max(dp[1][6], dp[1][3] + 14) = max(30, 14) = 30
   - j = 7: dp[2][7] = max(dp[1][7], dp[1][4] + 14) = max(30, 14) = 30

4. **세 번째 물건 (무게 4, 가치 16)**:
   - j = 0부터 3까지는 이 물건을 넣을 수 없으므로 dp[3][j] = dp[2][j].
   - j = 4: dp[3][4] = max(dp[2][4], dp[2][0] + 16) = max(14, 16) = 16
   - j = 5: dp[3][5] = max(dp[2][5], dp[2][1] + 16) = max(14, 16) = 16
   - j = 6: dp[3][6] = max(dp[2][6], dp[2][2] + 16) = max(30, 16) = 30
   - j = 7: dp[3][7] = max(dp[2][7], dp[2][3] + 16) = max(30, 30) = 30

최종적으로 dp[3][7] (즉, n=3, k=7)에 저장된 값인 30이 최대 가치입니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n * k)입니다. n은 물건의 개수, k는 배낭의 최대 용량입니다. 각 물건에 대해 최대 k만큼의 무게를 고려하여 dp 테이블을 업데이트하기 때문에 이러한 복잡도가 발생합니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n, k = map(int, input().split())
bag = [list(map(int, input().split())) for _ in range(n)]
dp = [[0] * (k + 1) for _ in range(n + 1)]

for i in range(1, n + 1):
    w, v = bag[i - 1]  # 현재 물건의 무게와 가치
    for j in range(k + 1):
        if j >= w:  # 물건을 넣을 경우와 넣지 않을 경우 비교
            dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w] + v)
        else:  # 물건을 넣을 수 없는 경우, 이전 값 그대로 유지
            dp[i][j] = dp[i - 1][j] 

print(dp[n][k])  # 최종 결과 출력

```