---
layout: post
title: "[백준] 14003번 가장 긴 증가하는 부분 수열 5 (Python)"
date: 2026-01-15
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "14003", 이분 탐색, 역추적, 가장 긴 증가하는 부분 수열 문제]
---

## 문제 링크
[https://www.acmicpc.net/problem/14003](https://www.acmicpc.net/problem/14003)

---

## 문제
수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.

---

## 입력
첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (-1,000,000,000 ≤ Ai ≤ 1,000,000,000)

---

## 출력
첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.

둘째 줄에는 정답이 될 수 있는 가장 긴 증가하는 부분 수열을 출력한다.

---

## 성능 요약
메모리: 259860 KB, 시간: 604 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 가장 긴 증가하는 부분 수열(LIS)을 찾기 위한 알고리즘으로 이분 탐색을 이용합니다. 우리는 tails 배열을 사용하여 현재까지 발견된 증가 부분 수열의 끝값들을 관리하고, prev_idx 배열을 사용하여 각 원소가 LIS에 포함될 때 이전 원소의 인덱스를 추적하여 최종적으로 수열을 복원합니다.

### 동작 과정
1. **입력 처리**: 수열 A의 크기 N과 각 원소를 입력받아 arr 리스트에 저장합니다.
   
2. **이분 탐색 함수 정의**: `search` 함수를 정의하여, 배열 a에서 x를 삽입할 위치를 찾습니다. 이는 tails 배열에서 x보다 크거나 같은 첫 번째 원소의 인덱스를 찾는 작업입니다.

3. **LIS 탐색**:
   - `for` 루프를 통해 각 원소 x에 대해 이분 탐색을 수행하여, x가 tails 배열에서 들어갈 위치 j를 찾습니다.
   - `prev_idx` 배열에 현재 원소가 LIS에 포함될 때, 그 바로 이전 원소의 인덱스를 기록합니다.
   - j가 tails의 길이와 같으면 x를 tails에 추가하고, 그렇지 않으면 j 위치의 값을 x로 갱신하여 더 작은 끝값으로 대체합니다.

4. **수열 복원**:
   - tails 배열의 마지막 인덱스에서부터 prev_idx를 따라가며 수열을 역추적하고, 최종적으로 얻은 수열을 반전시켜 출력합니다.

#### 예시 입력
```
6
10 20 10 30 20 50
```
- arr = [10, 20, 10, 30, 20, 50]
- tails = []
- tails_pos = []
- prev_idx = [-1, -1, -1, -1, -1, -1]

**단계별 진행**:
- x=10: j=0 → tails=[10], tails_pos=[0], prev_idx=[-1, -1, -1, -1, -1, -1]
- x=20: j=1 → tails=[10, 20], tails_pos=[0, 1], prev_idx=[-1, 0, -1, -1, -1, -1]
- x=10: j=1 → tails=[10, 20], tails_pos=[0, 1], prev_idx=[-1, 0, 0, -1, -1, -1]
- x=30: j=2 → tails=[10, 20, 30], tails_pos=[0, 1, 3], prev_idx=[-1, 0, 0, 1, -1, -1]
- x=20: j=2 → tails=[10, 20, 30], tails_pos=[0, 1, 3], prev_idx=[-1, 0, 0, 1, 1, -1]
- x=50: j=3 → tails=[10, 20, 30, 50], tails_pos=[0, 1, 3, 5], prev_idx=[-1, 0, 0, 1, 1, 3]

**최종 수열 복원**: 5 (LIS의 길이)와 [10, 20, 30, 50] (LIS 수열)

### 시간 복잡도
O(N log N) - 여기서 N은 수열의 크기입니다. 이분 탐색을 사용하여 각 원소에 대해 최대 log N의 시간이 소요되므로 전체적으로 O(N log N)의 시간 복잡도를 가집니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
arr = list(map(int, input().split()))

# tails[k] = 길이 (k+1)인 증가 부분수열의 최소 끝값
# tails_pos[k] = 위 tails[k]를 만든 인덱스
tails = []
tails_pos = []

# prev_idx[i] = arr[i]가 LIS에 포함될 때 바로 이전 원소의 인덱스
prev_idx = [-1] * n

def search(a, x):
    lo, hi = 0, len(a)
    while lo < hi:
        mid = (lo + hi) // 2
        if a[mid] < x:
            lo = mid + 1
        else:
            hi = mid
    return lo

for i, x in enumerate(arr):
    j = search(tails, x)

    # j-1 길이의 꼬리에 이어 붙이므로, 경로의 마지막 인덱스를 prev로 기록
    prev_idx[i] = tails_pos[j - 1] if j > 0 else -1

    if j == len(tails):  # 길이 확장
        tails.append(x)
        tails_pos.append(i)
    else:    # 꼬리값 갱신
        tails[j] = x
        tails_pos[j] = i

# 실가장 긴 길이의 마지막 인덱스부터 prev_idx를 따라 역추적
lis_len = len(tails)
k = tails_pos[-1] if tails_pos else -1

seq = []
while k != -1:
    seq.append(arr[k])
    k = prev_idx[k]
seq.reverse()

print(lis_len)
print(*seq)
```