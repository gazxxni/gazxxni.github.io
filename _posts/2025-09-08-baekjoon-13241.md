---
layout: post
title: "[백준] 13241번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "13241"]
---

## 문제 링크
[https://www.acmicpc.net/problem/13241](https://www.acmicpc.net/problem/13241)

---

## 풀이

### 풀이 핵심 로직
주어진 문제는 두 수의 최소공배수(LCM)를 구하는 것입니다. 최소공배수는 두 수의 곱을 두 수의 최대공약수(GCD)로 나눈 값으로 정의됩니다. 이 알고리즘은 유클리드 호제법을 사용하여 GCD를 구하고, 이를 이용하여 LCM을 계산합니다.

### 동작 과정
1. 입력으로 두 개의 정수 `a`와 `b`를 받습니다.
   - 예시 입력: `12 18`
   
2. `gcd` 함수를 통해 `a`와 `b`의 최대공약수(GCD)를 구합니다.
   - `gcd(12, 18)`을 호출하면 다음과 같이 진행됩니다:
     - `b`가 0이 아닐 경우, `a`를 `b`로, `b`를 `a % b`로 업데이트합니다.
     - 첫 번째 호출: `a = 18`, `b = 12` (12로 나눈 나머지)
     - 두 번째 호출: `a = 12`, `b = 6`
     - 세 번째 호출: `a = 6`, `b = 0`
     - GCD는 6입니다.
   
3. LCM을 계산하기 위해 `lcm2` 함수를 호출합니다:
   - LCM은 `a * b // gcd(a, b)`로 계산됩니다.
   - 여기서 `12 * 18 // 6` = `216 // 6` = `36`이 됩니다.

4. 결과로 LCM인 36을 출력합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(log(min(a, b)))입니다. 유클리드 호제법을 사용하여 GCD를 계산하는 과정이 로그 시간에 수행되기 때문입니다. LCM 계산은 상수 시간에 이루어지므로 전체 시간 복잡도는 GCD의 시간 복잡도에 의해 결정됩니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

a, b = map(int, input().split())

# def lcm(a, b):
#     for i in range(max(a, b), (a * b) + 1):
#         if i % a == 0 and i % b == 0:
#             return i
        
# print(lcm(a, b))

def gcd(a, b):
    while b > 0:
        a, b = b, a % b
    return a

def lcm2(a, b):
    return a * b // gcd(a, b)

print(lcm2(a, b))
```