---
layout: post
title: "[백준] 1904번 (Python)"
date: 2025-10-29
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1904"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1904](https://www.acmicpc.net/problem/1904)

---

## 풀이

### 풀이 핵심 로직
이 문제는 2진 수열의 경우의 수를 계산하는 문제로, 피보나치 수열과 유사한 점화식을 활용하여 해결합니다. 주어진 n에 대해, n자리 이진 수열을 만들기 위한 마지막 자리 수에 따라 가능한 경우의 수를 나누어 계산하고, 이를 DP 배열을 사용하여 누적합으로 저장합니다.

### 동작 과정
1. 입력으로 n을 받습니다. (예: n = 5)
2. dp 배열을 초기화합니다. dp[1] = 1 (1자리 수열: 0, 1), dp[2] = 2 (2자리 수열: 00, 01, 10, 11)로 설정합니다.
3. k=3부터 n까지 반복합니다. 각 k에 대해 다음과 같은 점화식을 사용하여 dp[k] 값을 계산합니다:
   - dp[k] = (dp[k-1] + dp[k-2]) % 15746
   - 예를 들어, n=5일 경우:
     - dp[3] = (dp[2] + dp[1]) % 15746 = (2 + 1) % 15746 = 3
     - dp[4] = (dp[3] + dp[2]) % 15746 = (3 + 2) % 15746 = 5
     - dp[5] = (dp[4] + dp[3]) % 15746 = (5 + 3) % 15746 = 8
4. 최종적으로 dp[n] (이 경우 dp[5])의 값을 출력합니다.

### 시간 복잡도
O(n) - n까지의 DP 배열을 채우기 위해 n-2번의 반복을 수행합니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
dp = [0] * 1000001
dp[1] = 1
dp[2] = 2

for k in range(3,n+1):
    dp[k] = (dp[k-1]+ dp[k-2])%15746
print(dp[n])
```