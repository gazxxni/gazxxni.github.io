---
layout: post
title: "[백준] 1527번 금민수의 개수 (Python)"
date: 2026-01-16
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1527", 브루트포스 알고리즘]
---

## 문제 링크
[https://www.acmicpc.net/problem/1527](https://www.acmicpc.net/problem/1527)

---

## 문제
은민이는 4와 7을 좋아하고, 나머지 숫자는 싫어한다. 금민수는 어떤 수가 4와 7로만 이루어진 수를 말한다.

A와 B가 주어졌을 때, A보다 크거나 같고, B보다 작거나 같은 자연수 중에 금민수인 것의 개수를 출력하는 프로그램을 작성하시오.

---

## 입력
첫째 줄에 A와 B가 주어진다. A는 1보다 크거나 같고, 1,000,000,000보다 작거나 같은 자연수이다. B는 A보다 크거나 같고, 1,000,000,000보다 작거나 같은 자연수이다.

---

## 출력
첫째 줄에 A보다 크거나 같고, B보다 작거나 같은 자연수 중에 금민수인 것의 개수를 출력한다.

---

## 성능 요약
메모리: 108384 KB, 시간: 92 ms

---

## 풀이

### 풀이 핵심 로직
문제는 주어진 범위 내에서 4와 7로만 이루어진 수, 즉 금민수를 찾는 것입니다. 이를 위해 모든 금민수를 생성하고, 생성된 수가 주어진 범위 A와 B에 포함되는지를 체크합니다. 브루트포스 방식으로 금민수를 생성하는데, 이는 재귀적으로 4와 7을 추가하여 이루어집니다.

### 동작 과정
1. **입력받기**: A와 B를 입력받습니다. 예를 들어, A = 1, B = 100.
2. **금민수 생성**: 4와 7로만 이루어진 수를 생성합니다.
   - 1자리부터 시작해서 최대 10자리까지 금민수를 생성합니다.
   - 각 자리수에 대해 이전에 생성된 금민수에 4와 7을 추가하여 새로운 금민수를 만듭니다.
3. **범위 체크**: 생성된 금민수가 A와 B 사이에 있는지를 확인합니다.
   - 예를 들어, 생성된 금민수 리스트가 [4, 7, 44, 47, 74, 77]일 때, 이 중 A(1)와 B(100) 사이에 있는 수를 카운트합니다.
4. **결과 출력**: 최종적으로 카운트된 금민수의 개수를 출력합니다.

예시로 A = 1, B = 100일 때, 생성된 금민수는 4, 7, 44, 47, 74, 77이며, 이 수들이 A와 B 사이에 있으므로 총 6개가 출력됩니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(2^n)입니다. n은 생성할 금민수의 최대 자리수(여기서는 10자리)로, 각 자리에서 4와 7을 선택하는 경우의 수가 2씩 늘어나기 때문입니다. 하지만 실제로는 10자리 이하의 금민수만 생성되므로, 실행시간은 제한적입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

a, b = map(int, input().split())
arr = [[] for _ in range(10)]
brr = [[] for _ in range(10)]
arr[0].append('4')
brr[0].append('7')

for i in range(1,10):
    for j in arr[i - 1]:
        arr[i].append('4' + j)
        arr[i].append('7' + j)
    for k in brr[i - 1]:
        brr[i].append('4' + k)
        brr[i].append('7' + k)

aa = len(str(a))
bb = len(str(b))
cnt = 0
for i in range(10):
    for j in arr[i]:
        if a <= int(j) <= b:
            cnt += 1
    
    for k in brr[i]:
        if a <= int(k) <= b:
            cnt += 1
            
print(cnt)
```