---
layout: post
title: "[백준] 1647번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1647"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1647](https://www.acmicpc.net/problem/1647)

---

## 풀이

### 풀이 핵심 로직
이 문제는 최소 신장 트리(MST)를 구성하여 도로를 연결하는 최소 비용을 구하는 문제입니다. 하지만, 주어진 도로 중 가장 비싼 도로를 제외한 최소 비용을 구해야 하므로, Kruskal 알고리즘을 사용하여 MST를 구한 후, 가장 큰 간선을 제외하고 총 비용을 계산합니다.

### 동작 과정
1. **입력받기**: `n`(도시의 수)과 `m`(도로의 수)을 입력받고, 다음으로 `m`개의 도로 정보를 (비용, 도시1, 도시2) 형태로 리스트에 저장합니다.
   
2. **간선 정렬**: 도로 정보를 비용을 기준으로 오름차순 정렬합니다.

3. **초기화**: 각 도시를 대표(parent)로 가지는 리스트와 랭크(rank)를 초기화합니다.

4. **Kruskal 알고리즘**:
   - 간선을 하나씩 확인하며, 두 도시가 연결되지 않은 경우(unite 함수 호출시 True 반환), 해당 간선을 MST에 추가하고 총 비용(total)을 갱신합니다.
   - 추가한 간선의 비용이 최대 비용(max_edge)일 경우 이를 갱신합니다.
   - MST의 간선 수가 `n-1`이 되면 반복을 종료합니다.

5. **결과 출력**: MST의 총 비용에서 최대 간선 비용을 빼서 결과를 출력합니다.

#### 예시 입력
```
4 5
1 2 3
1 3 2
2 3 5
2 4 4
3 4 1
```
- 도시 수 n=4, 도로 수 m=5
- 도로 리스트: [(3, 1, 2), (2, 1, 3), (5, 2, 3), (4, 2, 4), (1, 3, 4)]

#### 단계별 설명
1. 도로를 비용 기준으로 정렬: [(1, 3, 4), (2, 1, 3), (3, 1, 2), (4, 2, 4), (5, 2, 3)]
2. Kruskal 알고리즘을 이용해 MST 구성:
   - (1, 3, 4): 추가, 총 비용 1, max_edge 1
   - (2, 1, 3): 추가, 총 비용 3, max_edge 2
   - (3, 1, 2): 추가, 총 비용 6, max_edge 3
   - (4, 2, 4): 추가 시, 연결된 도시이므로 스킵
   - (5, 2, 3): 추가 시, 연결된 도시이므로 스킵
3. MST의 총 비용은 6, max_edge는 3
4. 결과 출력: 6 - 3 = 3

### 시간 복잡도
O(m log m) - 도로 정보를 정렬하는 데 O(m log m)의 시간이 소요되고, Kruskal 알고리즘의 unite 및 find 연산은 거의 상수 시간에 수행됩니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n, m = map(int, input().split())

edges = []
for _ in range(m):
    a, b, c = map(int, input().split())
    edges.append((c, a, b))

edges.sort()

parent = list(range(n+1))
rank = [0] * (n+1)

def find(x):
    while parent[x] != x:
        parent[x] = parent[parent[x]]
        x = parent[x]
    return x

def unite(a, b):
    ra, rb = find(a), find(b)
    if ra == rb:
        return False
    if rank[ra] < rank[rb]:
        parent[ra] = rb
    else:
        parent[rb] = ra
        if rank[ra] == rank[rb]:
            rank[ra] += 1
    return True

total = 0
max_edge = 0
cnt = 0

for w, u, v in edges:
    if unite(u, v):
        total += w
        if w > max_edge:
            max_edge = w
        cnt += 1
        if cnt == n-1:
            break

print(total - max_edge)

```