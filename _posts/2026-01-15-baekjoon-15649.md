---
layout: post
title: "[백준] 15649번 N과 M (1) (Python)"
date: 2026-01-15
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "15649", 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/15649](https://www.acmicpc.net/problem/15649)

---

## 문제
자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.


	1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열

---

## 입력
첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)

---

## 출력
한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.

수열은 사전 순으로 증가하는 순서로 출력해야 한다.

---

## 성능 요약
메모리: 113968 KB, 시간: 164 ms

---

## 풀이

### 풀이 핵심 로직
문제는 1부터 N까지의 자연수 중에서 중복 없이 M개의 수를 선택하여 수열을 만드는 것입니다. 백트래킹 기법을 사용하여 현재 선택된 수열을 유지하면서 조건을 만족하는 모든 수열을 탐색합니다. 수열의 길이가 M이 되었을 때, 수열을 출력하고, 그렇지 않으면 가능한 숫자를 선택해 재귀적으로 다음 수를 추가합니다.

### 동작 과정
1. **입력**: 예를 들어, N=4, M=2가 입력되었다고 가정합니다.
2. **초기화**: 빈 리스트 `arr`를 만들어 현재 선택된 수열을 저장합니다.
3. **재귀 함수 호출**: `aa()` 함수를 호출하여 수열 생성 과정을 시작합니다.
4. **수열 생성**:
   - 첫 번째 호출에서는 `arr`이 비어 있으므로 1부터 4까지의 숫자를 차례로 시도합니다.
   - 숫자 1을 선택하면 `arr`은 `[1]`이 되고, 다시 `aa()`가 호출됩니다.
   - 다음 단계에서는 2, 3, 4 중 하나를 선택하여 수열을 계속 확장합니다.
   - 만약 숫자 2를 선택하면 `arr`은 `[1, 2]`가 되고, 이때 `arr`의 길이가 M(2)이므로 `[1, 2]`를 출력합니다.
   - 이후에는 `arr.pop()`을 통해 마지막 선택된 숫자를 제거하고 다시 다른 숫자를 시도합니다.
5. **모든 경우의 수 탐색**: 이 과정을 반복하여 모든 가능한 조합을 출력합니다. 출력되는 수열은 사전 순으로 정렬되어 있습니다.

예시 과정:
- 입력: `4 2`
- 출력:
```
1 2
1 3
1 4
2 1
2 3
2 4
3 1
3 2
3 4
4 1
4 2
4 3
```

### 시간 복잡도
백트래킹을 이용한 이 문제의 시간 복잡도는 O(N!)입니다. N이 최대 8이므로, 모든 가능한 조합을 생성하는 방식으로 효율적으로 처리할 수 있습니다.

---

## 코드
```python
n, m = map(int, input().split())
arr = []

def aa():
    if len(arr) == m:
        print(*arr)
        return
    
    for i in range(1, n + 1):
        if i not in arr:
            arr.append(i)
            aa()
            arr.pop()
            
aa()
```