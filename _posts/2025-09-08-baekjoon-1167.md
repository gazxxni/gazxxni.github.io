---
layout: post
title: "[백준] 1167번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1167"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1167](https://www.acmicpc.net/problem/1167)

---

## 풀이

### 풀이 핵심 로직
이 문제는 비슷한 방식으로 두 번의 BFS(너비 우선 탐색)를 통해 트리의 지름을 구하는 방식입니다. 첫 번째 BFS를 수행하여 가장 먼 노드를 찾고, 그 노드에서 다시 BFS를 수행하여 최대 거리를 계산함으로써 트리의 지름을 구합니다.

### 동작 과정
1. **입력 처리**: 트리의 정점 개수 `v`와 각 정점 간의 연결 정보를 입력받아 인접 리스트 형태로 저장합니다.
   - 예를 들어, 입력이 다음과 같다고 가정합니다:
     ```
     5
     1 2 3 3 4 2
     2 1 3 3 5 1
     3 1 2 2
     4 3 1 1
     5 2 1 1
     ```
   - 이 입력은 정점 1에서 2(가중치 3)와 4(가중치 2)로 연결되어 있고, 정점 2에서 1(가중치 3)과 3(가중치 2)으로 연결되어 있다는 것을 의미합니다. 인접 리스트 `arr`는 다음과 같습니다:
     ```
     arr = [
       [], 
       [(2, 3), (4, 2)],
       [(1, 3), (3, 3), (5, 1)],
       [(1, 2), (2, 2)],
       [(1, 1)],
       [(2, 1)]
     ]
     ```

2. **첫 번째 BFS 수행**: 노드 1에서 시작하여 가장 먼 노드 `a`와 그 거리를 `b`를 계산합니다.
   - BFS 중에 모든 노드를 방문하고, 노드 간의 거리를 계산합니다.

3. **두 번째 BFS 수행**: 첫 번째 BFS에서 찾은 노드 `a`에서 다시 BFS를 수행하여 가장 먼 노드 `c`와 그 거리를 `d`를 계산합니다. 이 `d`가 트리의 지름입니다.

4. **결과 출력**: 최종적으로 트리의 지름 `d`를 출력합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(V + E)입니다. 여기서 V는 정점의 수, E는 간선의 수입니다. BFS는 각 노드를 한 번 방문하므로 이 복잡도를 가집니다. 트리는 항상 E = V - 1이므로, 최악의 경우 O(V)로 간주할 수 있습니다.

---

## 코드
```python
from collections import deque

v = int(input())
arr = [[] for _ in range(v+1)]

for i in range(v):
    a = list(map(int, input().split()))
    for j in range(1, len(a)-1, 2):
        arr[a[0]].append((a[j], a[j+1]))
    for j in range(1, len(a)-1, 2):
        arr[a[j]].append((a[0], a[j+1]))

def bfs(s):
    q = deque()
    q.append((s, 0))
    visited = [0] * (v+1)
    visited[s] = 1
    max_dist = 0
    max_node = s

    while q:
        node, dist = q.popleft()

        for i in arr[node]:
            if not visited[i[0]]:
                visited[i[0]] = 1
                q.append((i[0], dist + i[1]))
                if dist + i[1] > max_dist:
                    max_dist = dist + i[1]
                    max_node = i[0]

    return max_node, max_dist

a, b = bfs(1)
c, d = bfs(a)
print(d)
```