---
layout: post
title: "[백준] 1942번 (Python)"
date: 2025-09-22
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1942"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1942](https://www.acmicpc.net/problem/1942)

---

## 풀이

### 풀이 핵심 로직
이 문제는 연속된 부분 배열의 최대 합을 구하는 문제로, 동적 프로그래밍(DP) 기법을 사용하여 해결합니다. 각 원소까지의 최대 부분 배열 합을 저장하는 `dp` 배열을 사용하고, 현재 원소를 포함한 경우와 포함하지 않은 경우 중 큰 값을 선택하여 현재 위치의 최대 합을 업데이트합니다.

### 동작 과정
예를 들어, 입력이 `5`와 `-2 1 -3 4 -1`이라고 가정해봅시다.
1. `n`은 5입니다.
2. `arr`는 `[-2, 1, -3, 4, -1]`입니다.
3. `dp` 배열은 `[0, 0, 0, 0, 0]`으로 초기화되며, `dp[0]`은 `arr[0]`인 `-2`로 설정됩니다. `ans`는 `-2`로 초기화됩니다.
4. 1번째 원소(`1`)를 고려할 때:
   - `dp[1] = max(arr[1], dp[0] + arr[1]) = max(1, -2 + 1) = 1`
   - `ans`는 `max(-2, 1) = 1`
5. 2번째 원소(`-3`)를 고려할 때:
   - `dp[2] = max(arr[2], dp[1] + arr[2]) = max(-3, 1 - 3) = -2`
   - `ans`는 `max(1, -2) = 1`
6. 3번째 원소(`4`)를 고려할 때:
   - `dp[3] = max(arr[3], dp[2] + arr[3]) = max(4, -2 + 4) = 4`
   - `ans`는 `max(1, 4) = 4`
7. 4번째 원소(`-1`)를 고려할 때:
   - `dp[4] = max(arr[4], dp[3] + arr[4]) = max(-1, 4 - 1) = 3`
   - `ans`는 `max(4, 3) = 4`

최종적으로 `ans`는 `4`로 출력됩니다. 이는 연속된 부분 배열 `[4]`의 최대 합입니다.

### 시간 복잡도
O(n) - n개의 원소를 한 번씩만 순회하기 때문에 시간 복잡도는 선형적입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
arr = list(map(int, input().split()))

dp = [0] * (n + 1)
dp[0] = arr[0]
ans = arr[0]

for i in range(1, n):
    dp[i] = max(arr[i], dp[i - 1] + arr[i])
    ans = max(ans, dp[i])


print(ans)
```