---
layout: post
title: "[백준] 9251번 (Python)"
date: 2025-02-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "9251"]
---

## 문제 링크
[https://www.acmicpc.net/problem/9251](https://www.acmicpc.net/problem/9251)

---

## 풀이

### 풀이 핵심 로직
이 문제는 두 문자열의 Longest Common Subsequence (LCS)를 찾는 문제입니다. LCS는 두 문자열에서 순서를 유지하면서 공통으로 나타나는 가장 긴 부분 수열을 의미합니다. 이를 위해 동적 프로그래밍(DP)을 사용하여 문자열의 길이에 따라 2차원 DP 테이블을 구성하고, 서로 비교하여 LCS의 길이를 계산합니다.

### 동작 과정
1. 입력: 두 문자열 `a`와 `b`를 입력받습니다. 예를 들어, `a = "ABCBDAB"`와 `b = "BDCAB"`라고 가정합니다.
2. DP 테이블 초기화: `lcs`라는 2차원 리스트를 생성하여 크기는 `(len(a) + 1) x (len(b) + 1)`로 초기화합니다. 모든 요소는 0으로 초기화됩니다.
3. 중첩 루프: 
   - 첫 번째 루프는 문자열 `a`의 각 문자에 대해 반복하고, 두 번째 루프는 문자열 `b`의 각 문자에 대해 반복합니다.
   - 만약 `a[i-1]`와 `b[j-1]`가 같으면, `lcs[i][j]`는 `lcs[i-1][j-1] + 1`로 설정합니다. 이는 현재 문자가 LCS에 포함된다는 의미입니다.
   - 만약 다르면, `lcs[i][j]`는 `max(lcs[i][j-1], lcs[i-1][j])`로 설정하여 이전의 LCS 값 중에서 더 큰 값을 선택합니다.
4. 결과: 모든 비교가 끝난 후, `max(map(max, lcs))`를 통해 DP 테이블에서 가장 큰 값을 찾아서 LCS의 길이를 출력합니다.

예시:
- 입력:
  ```
  ABCBDAB
  BDCAB
  ```
- DP 테이블 구성 과정:
  ```
  lcs[0][0] = 0
  lcs[1][1] = 0 (A != B)
  lcs[1][2] = 0 (A != D)
  lcs[1][3] = 1 (A == A)
  ...
  lcs[7][5] = 4 (A, B, C, D)
  ```
- 최종 결과: LCS의 길이는 4입니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(m * n)입니다. 여기서 m은 문자열 `a`의 길이, n은 문자열 `b`의 길이입니다. DP 테이블을 채우기 위해 각 문자열의 모든 문자 쌍을 비교해야 하므로 이 복잡도를 가집니다.

---

## 코드
```python
import sys

a = list(input())
b = list(input())

lcs = [[0] * (len(b) + 1) for _ in range(len(a) + 1)]

for i in range(1, len(a) + 1):  # 문자열 `a`를 순회
    for j in range(1, len(b) + 1):  # 문자열 `b`를 순회
        # 두 문자가 같으면 이전 대각선 값 + 1
        if a[i-1] == b[j-1]:
            lcs[i][j] = lcs[i-1][j-1] + 1
        else:
            # 다르면 왼쪽 값과 위쪽 값 중 최대값을 선택
            lcs[i][j] = max(lcs[i][j-1], lcs[i-1][j])

print(max(map(max, lcs)))  # 각 행의 최댓값 중 큰 값 출력

```