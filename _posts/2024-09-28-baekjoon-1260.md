---
layout: post
title: "[백준] 1260번 (Python)"
date: 2024-09-28
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1260"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1260](https://www.acmicpc.net/problem/1260)

---

## 풀이

### 풀이 핵심 로직
이 문제는 그래프 탐색 알고리즘인 깊이 우선 탐색(DFS)과 너비 우선 탐색(BFS)을 이용하여 주어진 정점에서 시작하여 연결된 정점들을 방문하는 방법을 구현하는 것입니다. 그래프는 인접 리스트 방식으로 표현되며, DFS는 재귀적으로, BFS는 큐를 사용하여 구현됩니다.

### 동작 과정
예시 입력:
```
4 5 1
1 2
1 3
2 4
3 4
```
1. 첫 번째 줄에서 `N`, `M`, `V`의 값을 읽어옵니다. 여기서 `N`은 정점의 수, `M`은 간선의 수, `V`는 시작 정점입니다. 주어진 예시에서는 `N=4`, `M=5`, `V=1`입니다.
2. 그래프를 표현하기 위해 `graph` 리스트를 초기화합니다. `graph`는 1부터 N까지의 정점을 가리키는 리스트로, 각 인덱스에 해당하는 정점과 연결된 정점의 리스트를 저장합니다.
3. 다음으로, 주어진 간선 정보를 이용해 그래프를 구성합니다. 예를 들어 `1 2`, `1 3`, `2 4`, `3 4`의 간선이 추가됩니다.
4. 각 정점의 연결 리스트를 정렬합니다. 이 단계는 DFS와 BFS에서 정점 방문 순서를 결정하는 데 중요합니다.
5. DFS 탐색을 시작합니다. 시작 정점 `V`에서 방문한 정점을 출력하고, 그 정점과 연결된 모든 정점으로 재귀적으로 DFS를 호출하여 방문합니다. 예를 들어, 정점 1에서 시작하면 1 -> 2 -> 4 -> 3의 순서로 방문할 수 있습니다.
6. DFS가 완료된 후 줄바꿈을 출력합니다.
7. BFS 탐색을 수행합니다. 큐를 사용하여 정점 1에서 시작하고, 현재 정점을 방문한 후 연결된 모든 정점을 큐에 추가합니다. 이 과정은 큐가 비어질 때까지 반복되며, 예시에서는 1 -> 2 -> 3 -> 4 순서로 방문하게 됩니다.

### 시간 복잡도
그래프 탐색의 시간 복잡도는 O(V + E)입니다. 여기서 V는 정점의 수, E는 간선의 수입니다. DFS와 BFS 모두 모든 정점과 간선을 한 번씩 방문하므로 이와 같은 복잡도를 가집니다.

---

## 코드
```python
import sys

from collections import deque


def dfs(start):
    visited[start] = True
    print(start, end=" ")

    for i in graph[start]:
        if not visited[i]:
            dfs(i)


def bfs(start):
    queue = deque([start])
    visited[start] = True
    while queue:

        v = queue.popleft()
        print(v, end=" ")
        for i in graph[v]:
            if not visited[i]:
                visited[i] = True
                queue.append(i)


N, M, V = map(int, input().split())
graph = [[] for _ in range(N + 1)]

for _ in range(M):
    a, b = map(int, input().split())
    graph[a].append(b)
    graph[b].append(a)

# 정렬
for i in graph:
    i.sort()

# dfs
visited = [False] * (N + 1)
dfs(V)
print()

# bfs
visited = [False] * (N + 1)
bfs(V)
```