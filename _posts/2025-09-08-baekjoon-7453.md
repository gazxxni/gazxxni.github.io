---
layout: post
title: "[백준] 7453번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "7453"]
---

## 문제 링크
[https://www.acmicpc.net/problem/7453](https://www.acmicpc.net/problem/7453)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 네 개의 수 (A, B, C, D)를 선택하여 A + B = - (C + D)라는 식을 만족하는 경우의 수를 세는 것이다. 이를 위해 A와 B의 합을 미리 계산하여 그 빈도를 저장한 후, C와 D의 합을 계산해 - (C + D)와 일치하는 A + B의 빈도를 찾아 결과를 누적한다.

### 동작 과정
1. 입력으로 주어진 n개의 수를 읽는다. 각 줄마다 A, B, C, D 값을 입력받아 각각의 리스트에 저장한다.
2. A와 B의 모든 조합의 합을 계산하여 `ab_freq` 딕셔너리에 저장한다. 이때, 합의 값이 키가 되고, 그 합을 만드는 경우의 수가 값이 된다.
   - 예를 들어, A와 B가 각각 [1, 2]와 [3, 4]라면, 가능한 A + B의 합은 4 (1+3), 5 (1+4), 5 (2+3), 6 (2+4)로, `ab_freq`는 {4: 1, 5: 2, 6: 1}이 된다.
3. C와 D의 모든 조합을 순회하며, 각 조합의 합을 계산하고 그 값을 - (C + D)로 변환한다.
   - 예를 들어, C와 D가 각각 [5, 6]와 [7, 8]라면, 가능한 C + D의 합은 12 (5+7), 13 (5+8), 13 (6+7), 14 (6+8)로, - (C + D)는 -12, -13, -13, -14가 된다.
4. `ab_freq`에서 - (C + D)와 일치하는 키의 값을 찾아서 결과에 더한다. 이를 통해 해당 합을 만들 수 있는 A와 B의 조합 수를 누적한다.
5. 모든 조합을 순회한 후 최종 결과를 출력한다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n^2)이다. A와 B의 조합을 계산하는 데 O(n^2) 시간이 소요되고, C와 D의 조합을 계산하여 A + B와의 일치를 찾는 과정도 O(n^2) 시간에 이루어지므로 전체적으로 O(n^2) 복잡도를 가진다.

---

## 코드
```python
import sys
input = sys.stdin.readline

'''
항상 A+B = -(C+D) 로 식을 맞춘다.
C,D를 순회하며 ab_freq[-(c+d)](= A+B의 빈도)를 누적해 정답을 구한다.
'''
n = int(input())
arr, brr, crr, drr = [], [], [], []
for _ in range(n):
    a, b, c, d = map(int, input().split())
    arr.append(a); brr.append(b); crr.append(c); drr.append(d)

ab_freq = {}
for a in arr:
    for b in brr:
        s = a + b
        ab_freq[s] = ab_freq.get(s, 0) + 1

ans = 0
for c in crr:
    base = -c
    for d in drr:
        ans += ab_freq.get(base - d, 0)

print(ans)

```