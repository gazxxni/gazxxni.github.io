---
layout: post
title: "[백준] 9184번 신나는 함수 실행 (Python)"
date: 2025-12-06
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "9184", 다이나믹 프로그래밍, 재귀]
---

## 문제 링크
[https://www.acmicpc.net/problem/9184](https://www.acmicpc.net/problem/9184)

---

## 문제
재귀 호출만 생각하면 신이 난다! 아닌가요?

다음과 같은 재귀함수 w(a, b, c)가 있다.

if a  20 or b > 20 or c > 20, then w(a, b, c) returns:
    w(20, 20, 20)

if a 

위의 함수를 구현하는 것은 매우 쉽다. 하지만, 그대로 구현하면 값을 구하는데 매우 오랜 시간이 걸린다. (예를 들면, a=15, b=15, c=15)

a, b, c가 주어졌을 때, w(a, b, c)를 출력하는 프로그램을 작성하시오.

---

## 입력
입력은 세 정수 a, b, c로 이루어져 있으며, 한 줄에 하나씩 주어진다. 입력의 마지막은 -1 -1 -1로 나타내며, 세 정수가 모두 -1인 경우는 입력의 마지막을 제외하면 없다.

---

## 출력
입력으로 주어진 각각의 a, b, c에 대해서, w(a, b, c)를 출력한다.

---

## 성능 요약
메모리: 112656 KB, 시간: 460 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 재귀 함수를 사용하여 세 개의 정수 \(a\), \(b\), \(c\)에 대해 특정 값을 계산하는 함수 \(w(a, b, c)\)를 정의합니다. 이 함수는 특정 조건에 따라 값을 반환하며, 재귀 호출로 인해 많은 중복 계산이 발생할 수 있습니다. 이를 피하기 위해 메모이제이션을 사용하여 이미 계산한 결과를 저장합니다.

### 동작 과정
1. **초기화:** 전역 배열 `dp`를 생성하여 모든 가능한 \(a\), \(b\), \(c\)의 조합에 대해 결과를 저장합니다. 이 배열은 21x21x21 크기를 가지고 초기값으로 0을 설정합니다.
  
2. **입력 처리:** 입력을 받아 \(a\), \(b\), \(c\)의 조합을 반복적으로 처리합니다. 입력이 -1 -1 -1일 경우 종료합니다.

3. **함수 호출:** 주어진 \(a\), \(b\), \(c\)에 대해 함수 \(w(a, b, c)\)를 호출합니다. 함수 내부에서는 먼저 조건을 확인하여:
   - \(a\), \(b\), \(c\)가 0 이하일 경우 1을 반환합니다.
   - \(a\), \(b\), \(c\) 중 하나라도 20을 초과할 경우 \(w(20, 20, 20)\)을 계산하여 반환합니다.
   - 이미 계산된 결과가 `dp` 배열에 존재하면 해당 값을 반환합니다.

4. **재귀 호출:** \(a < b < c\)일 경우와 그렇지 않은 경우에 따라 다른 형태의 재귀 호출을 수행하여 값을 계산하고, 계산된 값을 `dp` 배열에 저장합니다.

5. **출력:** 각 입력에 대해 \(w(a, b, c)\)의 결과를 출력합니다.

예시 입력: `15 15 15`
- \(w(15, 15, 15)\)를 호출하면 \(w\) 함수가 내부적으로 여러 번 호출되어 결과를 계산하고, 최종적으로 \(w(15, 15, 15)\)의 결과를 출력합니다.

### 시간 복잡도
시간 복잡도는 \(O(1)\)입니다. 이는 \(a\), \(b\), \(c\)의 최대값이 20으로 제한되어 있기 때문에 (즉, 계산할 수 있는 조합의 수가 정해져 있어) 모든 가능한 경우의 수가 미리 계산되어 저장됩니다. 따라서 실제 호출 시에는 저장된 값을 반환하는 경우가 대부분이므로 상수 시간 복잡도를 가집니다.

---

## 코드
```python
def w(a, b, c):
    if a <= 0 or b <= 0 or c <= 0:
        return 1
    
    if a > 20 or b > 20 or c > 20:
        return w(20, 20, 20)
    
    if dp[a][b][c]:
        return dp[a][b][c]
    
    if a < b < c:
        dp[a][b][c] = w(a, b, c - 1) + w(a, b - 1, c- 1) - w(a, b - 1, c)
        return dp[a][b][c]
    
    dp[a][b][c] = w(a - 1, b, c) + w(a - 1, b - 1, c) + w(a - 1, b, c - 1) - w(a - 1, b - 1, c - 1)
    return dp[a][b][c]

dp = [[[0] * 21 for _ in range(21)] for _ in range(21)]

while True:
    a, b, c = map(int, input().split())

    if a == -1 and b == -1 and c == -1:
        exit()
    
    print(f'w({a}, {b}, {c}) = {w(a, b, c)}')
```