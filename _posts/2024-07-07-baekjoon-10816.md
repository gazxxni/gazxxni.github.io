---
layout: post
title: "[백준] 10816번 (Python)"
date: 2024-07-07
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "10816"]
---

## 문제 링크
[https://www.acmicpc.net/problem/10816](https://www.acmicpc.net/problem/10816)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 카드의 숫자와 내가 가진 숫자의 빈도를 비교하여, 내가 가진 숫자가 카드에 몇 개 있는지를 세는 문제입니다. 입력으로 주어진 카드 숫자를 정렬한 후, 각 숫자의 빈도를 딕셔너리에 저장하고, 내가 가진 숫자에 대해 이 빈도를 조회하여 결과를 출력합니다.

### 동작 과정
1. **입력 처리**: 먼저, 카드의 개수 `n`과 카드 숫자 `card`를 입력받습니다. 예를 들어, `n = 5`이고 `card`는 `[6, 3, 2, 4, 1]`일 수 있습니다.
2. **정렬**: `card`를 정렬하여 `[1, 2, 3, 4, 6]`로 만듭니다.
3. **빈도 계산**: 빈 딕셔너리 `dic`를 생성하고, `card`의 각 숫자에 대해 반복문을 돌리며 해당 숫자의 빈도를 세어 저장합니다. 예를 들어, `dic`는 `{1: 1, 2: 1, 3: 1, 4: 1, 6: 1}`이 됩니다.
4. **내 카드 조회**: 내 카드 숫자 `mine`의 개수 `m`을 입력받고, `mine`의 각 숫자에 대해 `dic`에서 빈도를 조회합니다. 예를 들어, `mine = [1, 4, 7]`라면, 결과는 `1 1 0`이 됩니다. 
5. **출력**: 각 숫자의 빈도를 공백으로 구분하여 출력합니다.

### 시간 복잡도
- 카드 배열을 정렬하는 데 `O(n log n)`이 소요됩니다.
- 딕셔너리에 빈도를 저장하는 데 `O(n)`, 각 숫자를 조회하는 데 `O(m)`이 소요됩니다.
- 따라서 전체 시간 복잡도는 `O(n log n + n + m)`으로, 최종적으로 `O(n log n + m)`으로 표현할 수 있습니다.

---

## 코드
```python
import sys
input=sys.stdin.readline

n = int(input())
card = sorted(map(int, input().split()))
m = int(input())
mine = list(map(int, input().split()))

dic = {}

for x in card:
  if x in dic :
    dic[x] += 1
  else:
    dic[x] = 1

for x in mine:
  if x in dic:
    print(dic[x], end=' ')
  else:
    print('0', end= ' ')
```