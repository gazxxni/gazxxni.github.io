---
layout: post
title: "[백준] 1342번 행운의 문자열 (Python)"
date: 2026-01-15
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1342", 브루트포스 알고리즘, 집합과 맵, 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/1342](https://www.acmicpc.net/problem/1342)

---

## 문제
민식이와 준영이는 자기 방에서 문자열을 공부하고 있다. 민식이가 말하길 인접해 있는 모든 문자가 같지 않은 문자열을 행운의 문자열이라고 한다고 한다. 준영이는 문자열 S를 분석하기 시작했다. 준영이는 문자열 S에 나오는 문자를 재배치하면 서로 다른 행운의 문자열이 몇 개 나오는지 궁금해졌다. 만약 원래 문자열 S도 행운의 문자열이라면 그것도 개수에 포함한다.

---

## 입력
첫째 줄에 문자열 S가 주어진다. S의 길이는 최대 10이고, 알파벳 소문자로만 이루어져 있다.

---

## 출력
첫째 줄에 위치를 재배치해서 얻은 서로 다른 행운의 문자열의 개수를 출력한다.

---

## 성능 요약
메모리: 113412 KB, 시간: 1512 ms

---

## 풀이

### 풀이 핵심 로직
문자열에서 인접한 문자가 같지 않은 "행운의 문자열"을 생성하기 위해 백트래킹 방법을 사용한다. 각 문자의 사용 가능 여부를 체크하면서, 이전에 사용한 문자와 다를 경우에만 다음 문자를 선택하여 재귀적으로 문자열을 생성한다. 이를 통해 중복되는 경우를 피하고, 가능한 모든 행운의 문자열을 카운트한다.

### 동작 과정
1. 입력 문자열 S에서 각 문자의 빈도를 저장하기 위해 딕셔너리 `dic`를 생성한다.
   - 예시 입력: `aab`
   - `dic`의 결과: `{'a': 2, 'b': 1}`

2. 재귀 함수 `back()`을 호출하여 현재까지 사용된 문자(`before`), 사용된 문자 수(`use`), 그리고 가능한 문자들을 기반으로 다음 문자를 선택한다.
   - `use`가 문자열 길이와 같을 때마다 `cnt`를 1 증가시킨다.

3. 각 문자에 대해, 사용 가능한 경우 (즉, 현재 문자 수가 0보다 크고 이전 문자와 다를 때)에만 선택하고, 선택한 문자의 수를 감소시키고 재귀 호출 후 다시 증가시킨다.

4. 최종적으로 가능한 "행운의 문자열"의 개수를 출력한다.

### 시간 복잡도
이 알고리즘은 문자열의 길이를 n이라고 할 때, 모든 가능한 조합을 탐색하므로 시간 복잡도는 O(n!)이다. n이 최대 10인 경우, 최대 10! = 3,628,800의 경우의 수를 탐색하게 된다. 하지만, 중복 문자가 있을 경우 가지치기를 통해 빠르게 계산할 수 있다.

---

## 코드
```python
s = list(input().rstrip())
l = len(s)
dic = {}

for i in s:
    dic[i] = dic.get(i, 0) + 1

cnt = 0
def back(dic, before, use):
    global cnt
    if use == l:
        cnt += 1
        return
    
    for k, v in dic.items():
        if v > 0 and k != before:
            dic[k] -= 1
            back(dic, k, use + 1)
            dic[k] += 1

back(dic, None, 0)
print(cnt)

```