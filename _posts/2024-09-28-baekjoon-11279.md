---
layout: post
title: "[백준] 11279번 (Python)"
date: 2024-09-28
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "11279"]
---

## 문제 링크
[https://www.acmicpc.net/problem/11279](https://www.acmicpc.net/problem/11279)

---

## 풀이

### 풀이 핵심 로직
이 문제는 최대 힙을 사용하여 주어진 숫자를 처리하는 방식입니다. Python의 `heapq` 모듈은 최소 힙을 기본으로 제공하므로, 최대 힙을 구현하기 위해 숫자를 음수로 변환하여 저장합니다. 입력된 숫자가 0일 때는 최대 힙에서 가장 큰 값을 꺼내어 출력하고, 힙이 비어있으면 0을 출력합니다.

### 동작 과정
1. 입력값 `n`을 받아 `heap`이라는 빈 리스트를 초기화합니다.
2. `n`번의 반복문을 통해 다음과 같은 작업을 수행합니다:
   - 정수 `x`를 입력받습니다.
   - 만약 `x`가 0보다 크면, `-x`를 힙에 추가하여 최대 힙으로서의 기능을 유지합니다.
   - 만약 `x`가 0이면, 힙에서 가장 큰 값을 꺼내어 출력합니다. 이 때, 음수로 저장된 값을 원래의 값으로 되돌리기 위해 다시 -1을 곱합니다. 힙이 비어있을 경우에는 0을 출력합니다.

**예시 입력:**
```
5
1
2
0
3
0
```
**단계별 설명:**
- `n`이 5이므로 5번의 입력을 받는다.
- 첫 번째 입력 1: `heap`에 -1을 추가 → `heap = [-1]`
- 두 번째 입력 2: `heap`에 -2를 추가 → `heap = [-2, -1]`
- 세 번째 입력 0: `heap`에서 가장 큰 값(-2)을 꺼내어 출력 → 출력: 2, `heap = [-1]`
- 네 번째 입력 3: `heap`에 -3을 추가 → `heap = [-3, -1]`
- 다섯 번째 입력 0: `heap`에서 가장 큰 값(-3)을 꺼내어 출력 → 출력: 3, `heap = [-1]`

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n log n)입니다. 이는 각각의 `heappush`와 `heappop` 연산이 O(log k) 시간에 수행되기 때문입니다. 여기서 k는 힙의 현재 크기이며, 최악의 경우 입력된 모든 수가 힙에 추가되는 상황을 고려할 수 있습니다.

---

## 코드
```python
import sys, heapq

input=sys.stdin.readline

n=int(input())
heap=[]

for _ in range(n):
    x=int(input())
    
    if x>0:
        heapq.heappush(heap,-x)    # 최대 힙에 숫자를 넣는 함수
    elif x==0:
        try:
            print(-(heapq.heappop(heap)))  # 입력된 숫자가 0이면 가장 큰 값 꺼냄
        except:
            print(0)  # 힙이 비어 있는 경우 0을 출력


```