---
layout: post
title: "[백준] 13549번 (Python)"
date: 2024-09-28
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "13549"]
---

## 문제 링크
[https://www.acmicpc.net/problem/13549](https://www.acmicpc.net/problem/13549)

---

## 풀이

### 풀이 핵심 로직
이 문제는 너비 우선 탐색(BFS) 알고리즘을 사용하여 두 위치(n, k) 사이의 최단 시간을 계산하는 문제입니다. BFS는 그래프의 노드를 레벨 순서로 탐색하여 최단 경로를 보장하므로, 이 문제에서 동생을 찾기 위한 최적의 이동 경로를 찾는 데 적합합니다.

### 동작 과정
1. **초기 설정**: 입력으로 주어진 위치 n(자신의 위치)과 k(동생의 위치)를 읽습니다. 방문 배열은 최대 100001 크기로 초기화되며, 각 위치에서 걸린 시간을 저장합니다. 시작점 n의 시간은 0으로 설정합니다.
   
2. **BFS 탐색 시작**:
   - 큐에 시작 위치 n을 추가합니다.
   - 큐가 빌 때까지 반복하며, 현재 위치를 deque에서 꺼냅니다.
   
3. **도착 확인**: 현재 위치가 k와 같으면, 방문 배열에서 해당 위치의 값을 반환하여 소요된 시간을 출력합니다.

4. **가능한 이동 확인**: 현재 위치에서 이동 가능한 다음 위치(current - 1, current + 1, current * 2)를 모두 검사합니다.
   - 각 위치가 방문되지 않았다면:
     - 만약 다음 위치가 current * 2라면, 이동 시간이 0이므로 방문 시간을 현재 위치의 시간과 동일하게 설정하고 큐의 앞에 추가합니다.
     - 그 외의 위치는 방문 시간을 현재 위치의 시간 + 1로 설정한 후 큐의 뒤에 추가합니다.
     
5. **최종 출력**: 동생의 위치 k에 도착하면 해당 시간을 출력합니다.

예시 입력: `5 17`
- BFS는 다음과 같은 경로를 통해 동생의 위치에 도달합니다: 5 → 10 → 9 → 8 → 7 → 6 → 5 → 17. 이 과정은 각 위치에서의 가능한 이동을 탐색하여 최단 경로를 찾습니다.

### 시간 복잡도
시간 복잡도는 O(N), 여기서 N은 100001입니다. 모든 위치에 대해 한 번씩 방문하게 되므로, 최악의 경우 모든 위치를 탐색해야 할 수 있습니다. BFS의 특성상 최단 경로를 보장하며, 각 노드를 한 번만 처리하기 때문에 이 복잡도는 효율적입니다.

---

## 코드
```python
from collections import deque
import sys
input = sys.stdin.readline

def bfs(n, k):
    # 방문 배열을 선언하고 -1로 초기화
    max_limit = 100001
    visited = [-1] * max_limit
    queue = deque([n])
    visited[n] = 0  # 시작점의 시간은 0

    while queue:
        current = queue.popleft()
        
        # 동생 위치에 도착하면 시간 반환
        if current == k:
            return visited[current]
        
        # 가능한 다음 이동 위치들
        for next_pos in (current - 1, current + 1, current * 2):
            if 0 <= next_pos < max_limit and visited[next_pos] == -1:
                if next_pos == current * 2:
                    visited[next_pos] = visited[current]
                    queue.appendleft(next_pos)
                    # 가중치가 0, 1이기 때문에 
                    # 0인 부분을 먼저 처리해야하므로 큐 앞에 넣음
                else:
                    visited[next_pos] = visited[current] + 1
                    queue.append(next_pos)

n, k = map(int, input().split())
print(bfs(n, k))

```