---
layout: post
title: "[백준] 10870번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "10870"]
---

## 문제 링크
[https://www.acmicpc.net/problem/10870](https://www.acmicpc.net/problem/10870)

---

## 풀이

### 풀이 핵심 로직
이 문제는 피보나치 수열의 n번째 수를 구하는 문제입니다. 피보나치 수열은 다음과 같이 정의됩니다: F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2) (n ≥ 2). 이 코드는 동적 프로그래밍을 사용하여 피보나치 수열의 값을 효율적으로 계산합니다.

### 동작 과정
1. 사용자로부터 정수 `n`을 입력받습니다.
2. `n`이 2보다 클 경우:
   - 크기가 `n+1`인 리스트 `dp`를 생성하여 초기화합니다.
   - `dp[1]`과 `dp[2]`에 각각 1과 1을 저장합니다 (피보나치 수열의 시작 값).
   - `dp[2]`는 2로 잘못 설정되어 있으므로 이는 수정이 필요합니다. (올바르게는 `dp[2] = 1`이 맞습니다)
   - `for` 루프를 통해 3부터 `n`까지의 피보나치 값을 계산하여 `dp[i] = dp[i - 1] + dp[i - 2]`를 통해 리스트에 저장합니다.
   - 마지막으로 `dp[n]`의 값을 출력합니다.
3. `n`이 1 또는 2일 경우, 피보나치 수열의 정의에 따라 1을 출력합니다.
4. `n`이 0일 경우 0을 출력합니다.

예를 들어, `n = 5`인 경우:
- dp 배열은 다음과 같이 업데이트됩니다:
  - dp[1] = 1
  - dp[2] = 1
  - dp[3] = dp[2] + dp[1] = 1 + 1 = 2
  - dp[4] = dp[3] + dp[2] = 2 + 1 = 3
  - dp[5] = dp[4] + dp[3] = 3 + 2 = 5
- 최종적으로 `dp[5]`의 값인 5가 출력됩니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n)입니다. 피보나치 수를 계산하기 위해 n-2번의 반복이 필요하기 때문입니다.

---

## 코드
```python
n = int(input())

if n > 2:
    dp = [0] * (n + 1)
    dp[1] = 1
    dp[2] = 1
    dp[2] = 2

    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
        
    print(dp[n - 1])
    
elif n == 2 or n == 1:
    print(1)

else:
    print(0)
```