---
layout: post
title: "[백준] 17103번 골드바흐 파티션 (Python)"
date: 2025-12-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "17103", 수학, 정수론, 소수 판정, 에라토스테네스의 체]
---

## 문제 링크
[https://www.acmicpc.net/problem/17103](https://www.acmicpc.net/problem/17103)

---

## 문제
골드바흐의 추측: 2보다 큰 짝수는 두 소수의 합으로 나타낼 수 있다.


짝수 N을 두 소수의 합으로 나타내는 표현을 골드바흐 파티션이라고 한다. 짝수 N이 주어졌을 때, 골드바흐 파티션의 개수를 구해보자. 두 소수의 순서만 다른 것은 같은 파티션이다.

---

## 입력
첫째 줄에 테스트 케이스의 개수 T (1 ≤ T ≤ 100)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 N은 짝수이고, 2

---

## 출력
각각의 테스트 케이스마다 골드바흐 파티션의 수를 출력한다.

---

## 성능 요약
메모리: 134592 KB, 시간: 212 ms

---

## 풀이

### 풀이 핵심 로직
골드바흐의 추측에 따르면, 짝수 N은 두 소수의 합으로 표현될 수 있습니다. 이 문제에서는 주어진 짝수 N을 두 소수의 합으로 나타내는 방법의 개수를 구하는 것이 목표입니다. 소수를 미리 계산해 놓고, 각 테스트 케이스에 대해 N/2 이하의 소수를 선택하여 그 소수와 N에서 그 소수를 뺀 값을 모두 소수 집합에 포함되는지 확인하여 카운트합니다.

### 동작 과정
1. **소수 계산**: 먼저, 2부터 1,000,000까지의 소수를 계산합니다. 이를 위해 에라토스테네스의 체를 사용하여 소수 리스트를 만듭니다.
2. **입력 처리**: 테스트 케이스의 수 T를 입력받고, 각 테스트 케이스마다 짝수 N을 입력받습니다.
3. **골드바흐 파티션 개수 계산**:
   - N이 주어지면, 2부터 N/2까지의 소수를 반복합니다.
   - 각 소수 `i`에 대해, `n - i`가 소수 집합에 포함되어 있는지 확인합니다.
   - 포함된다면 카운트를 증가시킵니다.
4. **결과 출력**: 각 테스트 케이스에 대한 골드바흐 파티션의 개수를 출력합니다.

**예시 입력**:
```
3
8
10
12
```

**단계별 설명**:
- **첫 번째 테스트 케이스 (N=8)**: 
    - 소수 리스트에서 2, 3, 5, 7을 확인합니다.
    - 2를 선택하면 8 - 2 = 6 (소수 아님), 
    - 3을 선택하면 8 - 3 = 5 (소수), 
    - 5를 선택하면 8 - 5 = 3 (소수).
    - 총 2개의 파티션 (3+5, 5+3) 존재하므로 카운트는 1로 기록됩니다.

- **두 번째 테스트 케이스 (N=10)**: 
    - 2, 3, 5, 7을 확인합니다.
    - 2 (8), 3 (7), 5 (5) 중 5를 선택했을 때 10-5=5 (소수).
    - 총 2개의 파티션 (3+7, 7+3) 존재하므로 카운트는 2로 기록됩니다.

- **세 번째 테스트 케이스 (N=12)**: 
    - 2, 3, 5, 7, 11을 확인합니다.
    - 2 (10), 3 (9), 5 (7), 7 (5), 11 (1) 중 5와 7을 선택했을 때 12-5=7와 12-7=5 모두 소수.
    - 총 3개의 파티션 (5+7, 7+5, 2+10) 존재하므로 카운트는 3으로 기록됩니다.

### 시간 복잡도
소수를 미리 계산하는 과정은 O(n log log n)입니다. 각 테스트 케이스에 대해 N/2까지 소수를 확인하는 과정은 O(k) (k는 소수의 개수)입니다. 따라서 총 시간 복잡도는 O(T * k)로, T는 테스트 케이스 수, k는 최대 소수의 개수입니다.

---

## 코드
```python
def primenum(n):
    arr = [True] * (n + 1)
    arr[0] = arr[1] = False
    
    for i in range(2, int(n ** 0.5) + 1):
        if arr[i]:
            for j in range(i * i, n + 1, i):
                arr[j] = False
                
    brr = []
    for i in range(2, n + 1):
        if arr[i]:
            brr.append(i)
            
    return brr

a = primenum(1000000)
b = set(a)
t = int(input())

for _ in range(t):
    n = int(input())

    cnt = 0

    for i in a:
        if i > n // 2:
            break
        
        if (n - i) in b:
            cnt += 1
            
    print(cnt)
```