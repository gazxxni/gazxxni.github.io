---
layout: post
title: "[백준] 1562번 계단 수 (Python)"
date: 2026-01-15
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1562", 다이나믹 프로그래밍, 비트마스킹, 비트필드를 이용한 다이나믹 프로그래밍]
---

## 문제 링크
[https://www.acmicpc.net/problem/1562](https://www.acmicpc.net/problem/1562)

---

## 문제
45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N이면서 0부터 9까지 숫자가 모두 등장하는 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. 0으로 시작하는 수는 계단수가 아니다.

---

## 입력
첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

---

## 출력
첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

---

## 성능 요약
메모리: 116564 KB, 시간: 116 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 다이나믹 프로그래밍을 사용하여 길이가 N인 계단 수를 세는 것이다. 각 자리수의 차이가 1이어야 하며, 0부터 9까지 모든 숫자가 나타나야 한다. 비트마스킹을 활용하여 각 숫자가 나타났는지를 기록하고, 이를 통해 모든 숫자가 포함된 계단 수의 개수를 효율적으로 계산한다.

### 동작 과정
1. **초기화**: 길이가 1인 계단 수는 1부터 9까지의 숫자만 사용할 수 있으며, 각 숫자에 대해 해당 숫자만 등장한 상태를 초기화한다. 예를 들어, `dp[1][2][4]`는 숫자 2로 이루어진 계단 수가 1개 있음을 나타낸다 (비트마스크 4는 0100이므로 숫자 2가 등장함을 의미).

2. **상태 전이**: 길이가 i인 계단 수에서 각 자리수 j에 대해 다음 자리수는 j-1 또는 j+1이 될 수 있으므로, 이를 통해 길이 i+1인 계단 수의 상태를 업데이트한다. 예를 들어, 현재 `dp[i][3][mask]`에서 다음 숫자가 2일 경우, `dp[i + 1][2][new_mask]`를 업데이트하며 `new_mask`는 현재 비트마스크에 숫자 2를 추가한 것이다.

3. **결과 계산**: 모든 길이가 n인 계단 수 중에서 0부터 9까지의 모든 숫자가 포함된 경우를 찾아 합산한다. 이때 비트마스크 `(1 << 10) - 1`은 모든 숫자가 포함된 상태를 의미한다.

예시 입력: N = 3
- 길이 1의 계단 수: 1, 2, 3, 4, 5, 6, 7, 8, 9
- 길이 2의 계단 수: 12, 21, 23, 32, 34, 43, 45, 54, 56, 65, 67, 76, 78, 87, 89, 98
- 길이 3의 계단 수: 123, 210, 234, 321, 345, 432, 456, 543, 567, 654, 678, 765, 789, 876, 890 등

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(N * 10 * 2^10)이다. 여기서 N은 최대 100, 10은 자리수의 개수, 2^10은 비트마스킹으로 나타낼 수 있는 숫자의 조합 수이다.

---

## 코드
```python
import sys
input = sys.stdin.readline

MOD = 1_000_000_000
n = int(input())
dp = [[[0] * 1024 for _ in range(10)] for _ in range(n + 1)]

# 길이 1의 계단 수 초기화
for j in range(1, 10):
    dp[1][j][1 << j] = 1

for i in range(1, n):
    for j in range(10):
        for k in range(1 << 10):
            if dp[i][j][k] == 0:
                continue
            
            # Case 1: 다음 숫자가 j-1일 경우
            if j > 0:
                new_digit = j - 1
                new_mask = k | (1 << new_digit)
                dp[i + 1][new_digit][new_mask] = (dp[i + 1][new_digit][new_mask] + dp[i][j][k]) % MOD
            
            # Case 2: 다음 숫자가 j+1일 경우
            if j < 9:
                new_digit = j + 1
                new_mask = k | (1 << new_digit)
                dp[i + 1][new_digit][new_mask] = (dp[i + 1][new_digit][new_mask] + dp[i][j][k]) % MOD

result = 0
for j in range(10):
    result = (result + dp[n][j][(1 << 10) - 1]) % MOD
    
print(result)
```