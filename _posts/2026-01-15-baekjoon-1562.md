---
layout: post
title: "[백준] 1562번 계단 수 (Python)"
date: 2026-01-15
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1562", 다이나믹 프로그래밍, 비트마스킹, 비트필드를 이용한 다이나믹 프로그래밍]
---

## 문제 링크
[https://www.acmicpc.net/problem/1562](https://www.acmicpc.net/problem/1562)

---

## 문제
45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N이면서 0부터 9까지 숫자가 모두 등장하는 계단 수가 총 몇 개 있는지 구하는 프로그램을 작성하시오. 0으로 시작하는 수는 계단수가 아니다.

---

## 입력
첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

---

## 출력
첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

---

## 성능 요약
메모리: 116564 KB, 시간: 116 ms

---

## 풀이

### 풀이 핵심 로직
계단 수를 구하기 위해 동적 프로그래밍(DP)과 비트마스킹을 사용합니다. 여기서는 길이가 N인 계단 수에서 각 자리 숫자가 0부터 9까지 모두 포함되어야 하므로, DP 테이블을 `dp[length][last_digit][mask]` 형태로 정의하여 `length` 자리 숫자의 마지막 숫자 `last_digit`와 그 숫자들로 구성된 비트마스크 `mask`를 저장합니다.

### 동작 과정
1. **초기화**: 길이가 1인 계단 수의 경우, 각 숫자 1부터 9까지를 시작으로 하여 비트마스크를 설정합니다. 예를 들어, `dp[1][1][2] = 1`은 길이가 1이고 마지막 숫자가 1인 경우의 수를 의미합니다.

2. **DP 테이블 채우기**: 길이 1부터 N-1까지 반복하면서 각 숫자와 비트마스크를 기반으로 다음 숫자를 결정합니다.
   - 현재 자리 숫자 `j`가 0보다 크면, 다음 자리 숫자가 `j-1`일 수 있습니다. 이 경우 새로운 비트마스크를 만들어 DP 테이블을 갱신합니다.
   - 현재 자리 숫자 `j`가 9보다 작으면, 다음 자리 숫자가 `j+1`일 수 있습니다. 이 경우에도 마찬가지로 새로운 비트마스크로 DP 테이블을 갱신합니다.

3. **결과 계산**: N 자리의 모든 계단 수 중 0부터 9까지 모든 숫자가 포함된 경우를 세기 위해, 마지막 자리 숫자에 대해 `(1 << 10) - 1` 비트마스크(모든 숫자가 포함된 경우)에 해당하는 DP 값을 합산하여 결과를 도출합니다.

4. **출력**: 최종 결과를 1,000,000,000으로 나눈 나머지를 출력합니다.

예시 입력으로 N이 3일 경우, 가능한 계단 수는 101, 121, 210, 212, 321, 323, 432, 434 등으로, 이 중 0부터 9까지 모두 포함된 경우는 없으므로 출력은 0이 됩니다.

### 시간 복잡도
DP 테이블을 계산하는 과정에서 길이 N에 대해 10개의 마지막 숫자, 그리고 1024개의 비트마스크를 사용하므로, 전체 시간 복잡도는 O(N * 10 * 1024) 즉, O(N)입니다. N의 최대값이 100이므로, 이는 충분히 빠른 성능을 제공합니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

MOD = 1_000_000_000
n = int(input())
dp = [[[0] * 1024 for _ in range(10)] for _ in range(n + 1)]

# 길이 1의 계단 수 초기화
for j in range(1, 10):
    dp[1][j][1 << j] = 1

for i in range(1, n):
    for j in range(10):
        for k in range(1 << 10):
            if dp[i][j][k] == 0:
                continue
            
            # Case 1: 다음 숫자가 j-1일 경우
            if j > 0:
                new_digit = j - 1
                new_mask = k | (1 << new_digit)
                dp[i + 1][new_digit][new_mask] = (dp[i + 1][new_digit][new_mask] + dp[i][j][k]) % MOD
            
            # Case 2: 다음 숫자가 j+1일 경우
            if j < 9:
                new_digit = j + 1
                new_mask = k | (1 << new_digit)
                dp[i + 1][new_digit][new_mask] = (dp[i + 1][new_digit][new_mask] + dp[i][j][k]) % MOD

result = 0
for j in range(10):
    result = (result + dp[n][j][(1 << 10) - 1]) % MOD
    
print(result)
```