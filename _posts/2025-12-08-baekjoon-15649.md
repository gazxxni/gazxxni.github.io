---
layout: post
title: "[백준] 15649번 N과 M (1) (Python)"
date: 2025-12-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "15649", 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/15649](https://www.acmicpc.net/problem/15649)

---

## 문제
자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.


	1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열

---

## 입력
첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)

---

## 출력
한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.

수열은 사전 순으로 증가하는 순서로 출력해야 한다.

---

## 성능 요약
메모리: 113968 KB, 시간: 164 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 백트래킹을 이용하여 1부터 N까지의 자연수 중에서 중복 없이 M개를 고르는 모든 수열을 생성하는 것입니다. 각 수열의 길이가 M이 될 때까지 자연수를 추가하고, 이 조건을 만족하면 결과를 출력합니다. 이 과정에서 중복을 피하기 위해 리스트에 이미 추가된 숫자는 다시 추가하지 않습니다.

### 동작 과정
예를 들어, 입력이 `3 2`인 경우를 생각해 보겠습니다.

1. **초기 상태**: `arr`은 비어 있습니다.
2. **1단계**: 첫 번째 숫자 1을 추가합니다. `arr`은 `[1]`이 됩니다.
3. **2단계**: 두 번째 숫자 1로는 중복이므로, 2를 추가하여 `arr`은 `[1, 2]`가 됩니다.
4. **3단계**: M(2)에 도달했으므로 `[1, 2]`를 출력합니다. 이후 2를 제거하고 `arr`은 `[1]`이 됩니다.
5. **4단계**: 3을 추가하여 `arr`은 `[1, 3]`이 됩니다. M에 도달했으므로 `[1, 3]`을 출력합니다. 이후 3을 제거하고 `arr`은 다시 `[1]`이 됩니다.
6. **5단계**: 1을 제거하여 `arr`은 비어 있습니다. 이제 2를 추가합니다.
7. **이 과정을 반복하여** `[2, 1]`, `[2, 3]`, `[3, 1]`, `[3, 2]`를 출력합니다.

최종적으로 출력되는 수열은 `[1, 2]`, `[1, 3]`, `[2, 1]`, `[2, 3]`, `[3, 1]`, `[3, 2]`입니다. 

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(N!/(N-M)!)입니다. 이는 모든 조합을 고려하기 때문에 발생하는 복잡도입니다. 최대 N이 8이므로, 이 범위 내에서는 실행 속도가 충분히 빠릅니다.

---

## 코드
```python
n, m = map(int, input().split())
arr = []

def aa():
    if len(arr) == m:
        print(*arr)
        return
    
    for i in range(1, n + 1):
        if i not in arr:
            arr.append(i)
            aa()
            arr.pop()
            
aa()
```