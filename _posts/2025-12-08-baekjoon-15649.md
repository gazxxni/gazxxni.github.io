---
layout: post
title: "[백준] 15649번 N과 M (1) (Python)"
date: 2025-12-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "15649", 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/15649](https://www.acmicpc.net/problem/15649)

---

## 문제
자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.


	1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열

---

## 입력
첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)

---

## 출력
한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.

수열은 사전 순으로 증가하는 순서로 출력해야 한다.

---

## 성능 요약
메모리: 113968 KB, 시간: 164 ms

---

## 풀이

### 풀이 핵심 로직
문제는 1부터 N까지의 자연수 중에서 M개를 중복 없이 고른 수열을 생성하는 것입니다. 이를 위해 백트래킹 기법을 사용하여, 현재 선택한 수열의 길이가 M이 될 때까지 재귀적으로 수를 선택하고, 수열의 길이가 M이 되었을 때 수열을 출력합니다.

### 동작 과정
입력으로 N과 M이 주어졌다고 가정하겠습니다. 예를 들어, N=4, M=2인 경우 단계별로 동작 과정을 설명하겠습니다.

1. 빈 배열 `arr`를 생성합니다.
2. `aa()` 함수를 호출합니다.
3. 함수 내에서 현재 `arr`의 길이가 M(2)인지 확인합니다. 만약 맞다면, `arr`을 출력합니다.
4. 그 다음, 1부터 N(4)까지 반복하면서 각 숫자를 선택합니다. 선택한 숫자가 현재 `arr`에 없다면:
   - 선택한 숫자를 `arr`에 추가합니다.
   - `aa()` 함수를 재귀적으로 호출하여 다음 숫자를 선택합니다.
   - 재귀 호출이 끝나면, 마지막에 추가한 숫자를 `arr`에서 제거합니다(백트래킹).
5. 이 과정을 반복하여 모든 수열을 생성합니다.

위의 과정에서 출력되는 수열은 사전순으로 정렬되어 나타납니다. 예를 들어, 위의 입력값에 대해 출력되는 수열은 다음과 같습니다:
```
1 2
1 3
1 4
2 1
2 3
2 4
3 1
3 2
3 4
4 1
4 2
4 3
```

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(M * N!)입니다. M개의 숫자를 선택하기 위해 N!의 경우의 수가 필요하며, 각 수열을 출력하는 데 O(M)의 시간이 필요합니다. N이 최대 8이므로, 이 알고리즘은 문제의 범위 내에서 효율적으로 동작합니다.

---

## 코드
```python
n, m = map(int, input().split())
arr = []

def aa():
    if len(arr) == m:
        print(*arr)
        return
    
    for i in range(1, n + 1):
        if i not in arr:
            arr.append(i)
            aa()
            arr.pop()
            
aa()
```