---
layout: post
title: "[백준] 2238번 경매 (Python)"
date: 2025-12-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2238", 구현]
---

## 문제 링크
[https://www.acmicpc.net/problem/2238](https://www.acmicpc.net/problem/2238)

---

## 문제
경매는 여러 사람이 하나의 물건을 사려고 할 때, 각 사람이 원하는 가격을 제시하면 그 중 가장 높은 가격으로 물건을 팔게 되는 방식이다. 이러한 고전적인 경매 방식은 꽤 널리 쓰이는데, 최근에는 인터넷 쇼핑몰에서 반대의 경매 방식을 택하기도 한다. 즉, 여러 사람이 가격을 제시하면, 그 중 가장 낮은 가격으로 물건을 팔게 되는 방식도 쓰인다.

하지만 이럴 경우, 모든 사람들이 1원에 물건을 사겠다고 하는 사태가 발생할 수 있다. 따라서 같은 가격을 제시한 사람이 둘 이상일 경우에는 무효로 하는 방식이 쓰인다. 하지만 모든 가격을 여러 사람이 제시하는 경우도 있을 수 있기 때문에, 다음과 같은 방식으로 경매 당첨자를 선택하기로 한다.

우선 가장 적은 수의 사람이 제시한 가격을 찾는다. 이러한 경우가 여럿 있다면, 가장 낮은 가격으로 물건을 팔게 된다. 이때, 그 가격을 제시한 사람들 중에서 가장 먼저 제시한 사람이 물건을 살 수 있게 된다.

각각의 사람들이 제시한 가격이 주어졌을 때, 경매에 낙찰(당첨)되는 사람을 구하는 프로그램을 작성하시오.

---

## 입력
첫째 줄에 두 정수 U(1 ≤ U ≤ 10,000), N(1 ≤ N ≤ 100,000)이 주어진다. U는 금액의 상한이고, N은 경매에 참여한 회수이다. 다음 N개의 줄에는 사람 이름 S(공백 없는 알파벳 대소문자 10자 이하)와, 그 사람이 제시한 가격 P(1 ≤ P ≤ U, 정수)이 경매에 참여한(가격을 제시한) 순서대로 주어진다.

---

## 출력
첫째 줄에 낙찰된 사람의 이름과 그 가격을 출력한다.

---

## 성능 요약
메모리: 117104 KB, 시간: 148 ms

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 각 가격을 제시한 사람들의 수를 세고, 가장 적은 수의 사람들이 제시한 가격을 찾는 것입니다. 만약 여러 가격이 동일하게 적은 수의 제시자를 가질 경우, 그 중에서 가장 낮은 가격을 선택하며, 해당 가격을 제시한 사람 중에서 가장 먼저 제시한 사람을 낙찰자로 결정합니다.

### 동작 과정
1. 입력을 받아서 금액의 상한 `U`와 경매에 참여한 회수 `N`을 읽습니다.
2. 각 가격을 인덱스로 사용하는 배열 `brr`를 만들어 가격을 제시한 사람의 수를 저장합니다. 가격을 제시한 사람의 이름들을 저장하기 위해 이차원 리스트 `arr`를 사용합니다.
3. 각 입력을 처리하며, 가격을 제시한 사람의 이름을 해당 가격 인덱스에 추가하고, 그 가격에 해당하는 사람 수를 증가시킵니다.
4. 모든 가격에 대해 사람 수를 확인하여 가장 적은 수의 제시자를 가진 가격을 찾습니다.
5. 해당 가격 중에서 가장 먼저 제시한 사람의 이름과 가격을 출력합니다.

예시 입력:
```
100 5
Alice 10
Bob 20
Charlie 10
David 30
Eve 20
```
- `U=100`, `N=5`로 설정됩니다.
- 가격 제시 결과는 다음과 같습니다:
  - 가격 10: Alice, Charlie (2명)
  - 가격 20: Bob, Eve (2명)
  - 가격 30: David (1명)
- 가장 적은 수의 제시자를 가진 가격은 30이며, 이 가격을 제시한 David가 낙찰자로 선정됩니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(N)입니다. 가격을 제시한 사람 수를 세는 과정과 가장 적은 수의 제시자를 찾는 과정이 모두 N에 비례하기 때문입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

u, n = map(int, input().split())
m = 10001
arr = [[] for _ in range(m)]
brr = [0 for _ in range(m)]
max_num = m

for _ in range(n):
    s, p = input().split()
    p = int(p)
    arr[p].append(s) 
    brr[p] += 1

for i in range(m): 
    if brr[i] != 0:  
        max_num = min(brr[i], max_num)
        
for i in range(m): 
    if max_num == brr[i]:
        print(arr[i][0], i)
        break
```