---
layout: post
title: "[백준] 2003번 수들의 합 2 (Python)"
date: 2026-01-29
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2003", 브루트포스 알고리즘, 누적 합, 두 포인터]
---

## 문제 링크
[https://www.acmicpc.net/problem/2003](https://www.acmicpc.net/problem/2003)

---

## 문제
N개의 수로 된 수열 A[1], A[2], …, A[N] 이 있다. 이 수열의 i번째 수부터 j번째 수까지의 합 A[i] + A[i+1] + … + A[j-1] + A[j]가 M이 되는 경우의 수를 구하는 프로그램을 작성하시오.

---

## 입력
첫째 줄에 N(1 ≤ N ≤ 10,000), M(1 ≤ M ≤ 300,000,000)이 주어진다. 다음 줄에는 A[1], A[2], …, A[N]이 공백으로 분리되어 주어진다. 각각의 A[x]는 30,000을 넘지 않는 자연수이다.

---

## 출력
첫째 줄에 경우의 수를 출력한다.

---

## 성능 요약
메모리: 110916 KB, 시간: 172 ms

---

## 풀이

### 풀이 핵심 로직
주어진 수열에서 두 포인터를 사용하여 연속 부분 수열의 합을 구하고, 이 합이 M과 일치할 때 카운트를 증가시키는 방법을 사용합니다. 한 포인터는 시작 위치를, 다른 포인터는 끝 위치를 나타내며, 현재 합이 M보다 작으면 끝 포인터를 증가시키고, 크면 시작 포인터를 증가시킵니다.

### 동작 과정
예를 들어 입력이 다음과 같다고 가정해 봅시다:
```
5 5
1 2 3 2 5
```
1. 초기 상태: `st = 0`, `ed = 0`, `cur = 1` (A[0:1]의 합)
   - `cur < M` → `ed`를 증가시켜 `ed = 1`, `cur = 3` (A[0:2]의 합)
   
2. `cur < M` → `ed`를 증가시켜 `ed = 2`, `cur = 6` (A[0:3]의 합)
   - `cur > M` → `st`를 증가시켜 `st = 1`, `cur = 5` (A[1:3]의 합)
   - `cur == M` → 카운트 증가, `cnt = 1` → `ed`를 증가시켜 `ed = 3`, `cur = 5` (A[1:4]의 합)
   - `cur == M` → 카운트 증가, `cnt = 2` → `ed`를 증가시켜 `ed = 4`, `cur = 10` (A[1:5]의 합)
   - `cur > M` → `st`를 증가시켜 `st = 2`, `cur = 8` (A[2:5]의 합)
   - `cur > M` → `st`를 증가시켜 `st = 3`, `cur = 5` (A[3:5]의 합)
   - `cur == M` → 카운트 증가, `cnt = 3` → `ed`를 증가시켜 `ed = 5` (이제 배열의 끝)

최종적으로 카운트 `cnt`는 3이 되어 출력됩니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(N)입니다. 각 포인터 `st`와 `ed`는 배열을 한 번씩만 순회하므로 전체적으로 최대 N번의 연산이 발생합니다.

---

## 코드
```python
n, m = map(int, input().split())
arr = list(map(int, input().split()))

cnt = 0
ed = 0
st = 0
while ed < n:
    cur = sum(arr[st:ed+1])
    
    if cur == m:
        cnt += 1
        ed += 1
    elif cur > m:
        st += 1
    else:
        ed += 1
        
print(cnt)
```