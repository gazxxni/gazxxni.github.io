---
layout: post
title: "[백준] 13172번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "13172"]
---

## 문제 링크
[https://www.acmicpc.net/problem/13172](https://www.acmicpc.net/problem/13172)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 쿼리에서 주어진 분수를 계산한 후, 그것의 합을 구하는 문제입니다. 각 쿼리에서는 \( s \)를 \( n \)으로 나눈 값을 구해야 하는데, 나누기를 수행하기 위해서는 모듈러 역원을 사용합니다. 이때, 페르마의 소정리를 이용하여 \( n \)에 대한 나누기 연산을 효율적으로 수행합니다.

### 동작 과정
1. 입력을 통해 쿼리의 개수 \( m \)을 읽어옵니다.
2. 각 쿼리에서는 두 개의 정수 \( n \)과 \( s \)를 입력받습니다.
3. 분수를 계산하기 위해 \( n \)의 모듈러 역원을 구합니다. 이는 \( n^{MOD-2} \mod MOD \)로 계산되며, 이는 페르마의 소정리에 의해 성립합니다.
4. 각 쿼리에서 \( s \)와 \( n \)의 모듈러 역원을 곱한 값을 결과에 누적합산합니다.
5. 최종 결과를 출력합니다.

예시 입력:
```
2
3 6
5 10
```
- 첫 번째 쿼리: \( n = 3, s = 6 \)
  - \( n \)의 모듈러 역원: \( 3^{1000000005} \mod 1000000007 \)
  - 결과에 \( 6 \times (n^{-1} \mod MOD) \)를 더합니다.
  
- 두 번째 쿼리: \( n = 5, s = 10 \)
  - \( n \)의 모듈러 역원: \( 5^{1000000005} \mod 1000000007 \)
  - 결과에 \( 10 \times (n^{-1} \mod MOD) \)를 더합니다.
  
마지막으로, 모든 쿼리의 결과를 모듈러 연산을 통해 최종 결과를 출력합니다.

### 시간 복잡도
이 코드의 시간 복잡도는 \( O(m \cdot \log n) \)입니다. 
- 여기서 \( m \)은 쿼리의 수이고, \( n \)은 각 쿼리에서 최대 입력되는 정수입니다. 모듈러 역원을 구하는 과정에서 이진 거듭제곱을 사용하여 \( O(\log n) \)의 시간이 소요됩니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

m = int(input())
MOD = 1000000007

def cal(a, b = MOD - 2):
    result = 1

    while b > 0:
        if b % 2 == 1:
            result = (result * a) % MOD
        a = (a * a) % MOD
        b //= 2
    return result
    

result = 0

for _ in range(m):
    n, s = map(int, input().split())
    result = (result + (s * cal(n))) % MOD

print(result)
```