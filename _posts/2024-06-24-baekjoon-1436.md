---
layout: post
title: "[백준] 1436번 (Python)"
date: 2024-06-24
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1436"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1436](https://www.acmicpc.net/problem/1436)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 666이 포함된 숫자를 차례대로 찾는 것입니다. 주어진 n번째 666이 포함된 숫자를 찾기 위해, 666부터 시작하여 숫자를 하나씩 증가시키며 666이 포함된 수를 카운트합니다. n번째 수를 찾을 때까지 이 과정을 반복합니다.

### 동작 과정
1. 입력으로 2가 주어졌다고 가정합니다. 즉, 2번째 666이 포함된 수를 찾고자 합니다.
2. `result`를 666으로 초기화합니다.
3. 반복문을 시작합니다.
   - `result`가 666인 경우, '666'이 포함되어 있으므로 `cnt`를 1 증가시킵니다. (현재 카운트: 1)
   - `cnt`가 n(2)와 같지 않으므로, `result`를 1 증가시킵니다. (현재 `result`: 667)
4. `result`가 667인 경우, '666'이 포함되어 있지 않으므로 `cnt`는 증가하지 않습니다. 다시 `result`를 1 증가시킵니다. (현재 `result`: 668)
5. 이 과정을 반복하여 `result`가 666, 1666, 2666, ...와 같이 666이 포함된 숫자가 나올 때마다 `cnt`를 증가시킵니다.
6. 결국 `cnt`가 2가 되면 반복문을 종료하고, `result`를 출력합니다.

예시 입력 2에 대해 최종적으로 출력되는 값은 1666입니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(k)입니다. 여기서 k는 n번째 666이 포함된 수를 찾기 위해 반복해야 하는 숫자의 개수입니다. 최악의 경우, n이 커질수록 k도 크게 증가할 수 있으므로, 특히 n이 클 경우 비효율적일 수 있습니다. 하지만 일반적으로 이 문제의 제한된 범위에서는 충분히 해결 가능한 속도입니다.

---

## 코드
```python
import sys

n=int(input())
cnt=0
result=666

while True:
    if '666' in str(result):
        cnt+=1

    if cnt==n:
        break

    result+=1

print(result)


```