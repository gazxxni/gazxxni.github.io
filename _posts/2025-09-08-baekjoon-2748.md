---
layout: post
title: "[백준] 2748번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2748"]
---

## 문제 링크
[https://www.acmicpc.net/problem/2748](https://www.acmicpc.net/problem/2748)

---

## 풀이

### 풀이 핵심 로직
이 문제는 피보나치 수열을 계산하는 문제로, 주어진 정수 n에 대해 n번째 피보나치 수를 구하는 방법을 다룹니다. 동적 프로그래밍(DP)을 이용해 이전 두 수를 바탕으로 현재 수를 계산함으로써, 중복 계산을 방지하고 효율적으로 결과를 도출합니다.

### 동작 과정
1. 입력을 받아 n을 정수형으로 변환합니다.
2. 길이가 n+1인 리스트 dp를 생성하고, dp[0]은 0, dp[1]은 1로 초기화합니다.
3. 반복문을 통해 2부터 n까지의 각 인덱스 i에 대해 dp[i] = dp[i-1] + dp[i-2]로 피보나치 수를 계산합니다.
4. 마지막으로 dp[n]을 출력합니다.

예시 입력: `5`
- 초기화: dp = [0, 1, 0, 0, 0, 0]
- i=2: dp[2] = dp[1] + dp[0] = 1 + 0 = 1 → dp = [0, 1, 1, 0, 0, 0]
- i=3: dp[3] = dp[2] + dp[1] = 1 + 1 = 2 → dp = [0, 1, 1, 2, 0, 0]
- i=4: dp[4] = dp[3] + dp[2] = 2 + 1 = 3 → dp = [0, 1, 1, 2, 3, 0]
- i=5: dp[5] = dp[4] + dp[3] = 3 + 2 = 5 → dp = [0, 1, 1, 2, 3, 5]
- 출력: 5

### 시간 복잡도
O(n) - n번째 피보나치 수를 계산하기 위해 n-1번의 반복문을 수행하므로 시간 복잡도는 O(n)입니다.

---

## 코드
```python
n = int(input())

dp = [0] * (n + 1)
dp[0] = 0
dp[1] = 1

for i in range(2, n + 1):
    dp[i] = dp[i - 1] + dp[i - 2]
    
print(dp[n])
```