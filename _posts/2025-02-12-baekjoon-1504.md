---
layout: post
title: "[백준] 1504번 (Python)"
date: 2025-02-12
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1504"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1504](https://www.acmicpc.net/problem/1504)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 그래프에서 특정 두 정점을 반드시 경유하는 최단 경로를 찾는 문제이다. 다익스트라 알고리즘을 사용하여 모든 정점에서 각 정점까지의 최단 거리를 계산한 후, 두 가지 경로를 고려하여 최단 거리를 구한다. 이때, 두 경유 정점을 포함하는 경로의 비용을 계산하고, 그 중 최소값을 선택한다.

### 동작 과정
1. **입력 예시**: 
   ```
   4 6
   1 2 1
   1 3 2
   2 3 2
   2 4 1
   3 4 3
   1 4 5
   2 3
   ```

2. **그래프 구성**: 
   - 노드와 간선의 정보를 기반으로 그래프를 인접 리스트 형태로 구성한다.
   - `graph`의 결과는 다음과 같다:
     ```
     [
       [],
       [(2, 1), (3, 2), (4, 5)],
       [(1, 1), (3, 2), (4, 1)],
     ...
     ]
     ```

3. **다익스트라 알고리즘 적용**:
   - 1번 노드에서 시작하여 `dijk(1)`을 호출하여 1번 노드에서 모든 노드까지의 최단 거리 배열 `a`를 생성한다. 결과: `a = [0, 0, 1, 2, 2]` (1에서 2까지 1, 1에서 3까지 2, 1에서 4까지 2).
   - v1과 v2에서 각각 `dijk(v1)`과 `dijk(v2)`를 호출하여 두 노드에서 각 노드까지의 최단 거리 배열을 생성한다.
   - 예를 들어, `v1 = 2`에서의 거리 배열은 `v1_dist = [0, 1, 0, 2, 2]`.

4. **경로 비용 계산**:
   - 두 경로를 고려하여 각각의 비용을 계산한다:
     - `path1 = a[v1] + v1_dist[v2] + v2_dist[v]` (1 → 2 → 3 → 4)
     - `path2 = a[v2] + v2_dist[v1] + v1_dist[v]` (1 → 3 → 2 → 4)
   - 이 경우 두 경로의 비용을 계산하여 최솟값을 선택한다.

5. **결과 출력**: 
   - 최단 경로 비용이 무한대보다 작으면 그 값을 출력하고, 그렇지 않으면 -1을 출력한다.

### 시간 복잡도
- 다익스트라 알고리즘을 사용하여 각 정점에서 최단 거리를 계산하는 데 O((V + E) log V)의 시간 복잡도를 가진다. 이 문제에서는 세 번의 다익스트라 호출이 필요하므로 전체 시간 복잡도는 O((V + E) log V)이다.

---

## 코드
```python
import sys, heapq
input = sys.stdin.readline
INF = int(1e9)

v, e = map(int, input().split())
graph = [[] for _ in range(v + 1)]

for _ in range(e):
    x, y, c = map(int, input().split())
    graph[x].append((y, c))
    graph[y].append((x, c))

def dijk(st):
    q = []
    dist = [INF] * (v+1)
    heapq.heappush(q, (0, st))
    dist[st] = 0

    while q:
        d, now = heapq.heappop(q)

        if dist[now] < d:
            continue

        for i in graph[now]:
            cost = d + i[1]

            if dist[i[0]] > cost:
                dist[i[0]] = cost
                heapq.heappush(q, (cost, i[0]))
        
    return dist

v1, v2 = map(int, input().split())

a = dijk(1)  # 1번 노드에서 시작하는 최단 거리 배열
v1_dist = dijk(v1)  # v1번 노드에서 시작하는 최단 거리 배열
v2_dist = dijk(v2)  # v2번 노드에서 시작하는 최단 거리 배열

path1 = a[v1] + v1_dist[v2] + v2_dist[v]  # 경로 1: 1 → v1 → v2 → v (v번 정점까지)
path2 = a[v2] + v2_dist[v1] + v1_dist[v]  # 경로 2: 1 → v2 → v1 → v (v번 정점까지)

result = min(path1, path2)
print(result if result < INF else -1)
```