---
layout: post
title: "[백준] 12908번 텔레포트 3 (Python)"
date: 2025-10-18
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "12908", 그래프 이론, 브루트포스 알고리즘, 최단 경로, 플로이드–워셜]
---

## 문제 링크
[https://www.acmicpc.net/problem/12908](https://www.acmicpc.net/problem/12908)

---

## 문제
수빈이는 크기가 무한대인 격자판 위에 살고 있다. 격자판의 각 점은 두 정수의 쌍 (x, y)로 나타낼 수 있다.

제일 처음에 수빈이의 위치는 (xs, ys)이고, 집이 위치한 (xe, ye)로 이동하려고 한다.

수빈이는 두 가지 방법으로 이동할 수 있다. 첫 번째 방법은 점프를 하는 것이다. 예를 들어 (x, y)에 있는 경우에 (x+1, y), (x-1, y), (x, y+1), (x, y-1)로 이동할 수 있다. 점프는 1초가 걸린다.

두 번째 방법은 텔레포트를 사용하는 것이다. 텔레포트를 할 수 있는 방법은 총 세 가지가 있으며, 미리 정해져 있다. 텔레포트는 네 좌표 (x1, y1), (x2, y2)로 나타낼 수 있으며, (x1, y1)에서 (x2, y2)로 또는 (x2, y2)에서 (x1, y1)로 이동할 수 있다는 것이다. 텔레포트는 10초가 걸린다.

수빈이의 위치와 집의 위치가 주어졌을 때, 집에 가는 가장 빠른 시간을 구하는 프로그램을 작성하시오.

---

## 입력
첫째 줄에 xs와 ys가, 둘째 줄에 xe, ye가 주어진다. (0 ≤ xs, ys, xe, ye ≤ 1,000,000,000)

셋째 줄부터 세 개의 줄에는 텔레포트의 정보 x1, y1, x2, y2가 주어진다. (0 ≤ x1, y1, x2, y2 ≤ 1,000,000,000)

입력으로 주어지는 모든 좌표 8개는 서로 다르다.

---

## 출력
수빈이가 집에 가는 가장 빠른 시간을 출력한다.

---

## 성능 요약
메모리: 111284 KB, 시간: 120 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 수빈이가 집으로 가는 최단 시간을 구하는 문제로, 이동 방법은 점프와 텔레포트 두 가지가 있다. 텔레포트를 사용하는 경우와 점프를 사용하는 경우를 고려하여 다익스트라 알고리즘을 사용해 최단 경로를 계산한다. 초기 위치에서 집까지의 거리와 텔레포트 지점을 경유하는 거리 중 최소값을 찾아내는 방식으로 해결한다.

### 동작 과정
1. **입력 받기**: 시작 위치 `(xs, ys)`와 집 위치 `(xe, ye)`를 입력받고, 세 개의 텔레포트 지점을 저장한다.
   
2. **초기 설정**: 시작 노드와 집 노드를 설정하고, 텔레포트 정보를 사전 형태로 저장한다. 또한, 각 지점마다 거리 정보를 무한대로 초기화한다.

3. **기본 거리 계산**: 수빈이가 점프만으로 집에 가는 경우의 거리, 즉 `abs(xs - xe) + abs(ys - ye)`를 계산하여 `min_cost`에 저장한다.

4. **다익스트라 알고리즘 실행**:
   - 우선순위 큐를 사용하여 최소 비용의 노드를 추출하고, 해당 노드에서 집까지의 거리를 갱신한다.
   - 현재 노드에서 텔레포트 가능한 노드로의 비용을 계산하고, 이를 큐에 추가한다.
   - 현재 노드에서 모든 텔레포트 지점까지의 비용을 계산하여 거리 정보를 갱신하고 큐에 추가한다.

5. **결과 출력**: 최소 비용인 `min_cost`를 출력하여 수빈이가 집에 가는 가장 빠른 시간을 구한다.

**예시 입력**:
```
0 0
10 10
2 2 8 8
1 1 9 9
3 3 7 7
```

**예시 동작 과정**:
- 처음 위치는 `(0, 0)`이고 집은 `(10, 10)`이다.
- 점프만으로 가는 경우: `20초` (10+10)
- 텔레포트를 통해 이동하는 경우:
  1. `(0, 0)`에서 `(2, 2)`로 점프: `2초`
  2. `(2, 2)`에서 `(8, 8)`로 텔레포트: `10초`
  3. `(8, 8)`에서 `(10, 10)`로 점프: `4초`
  
  총 시간: `2 + 10 + 4 = 16초`

이와 같이 여러 경로를 계산하여 `min_cost`를 업데이트하고 최종적으로 최소 시간을 출력한다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O((N + E) log N)으로, 여기서 N은 텔레포트 지점의 수, E는 간선의 수입니다. 텔레포트 간선이 적고, 각 간선에 대해 다익스트라 알고리즘을 수행하므로 효율적으로 동작합니다.

---

## 코드
```python
import sys, heapq
from collections import defaultdict
'''
BFS로 풀면 모든 지점을 다 돌아야해서 시간초과
-> 다익스트라로 텔레포트 사용 구간만 검사, 텔레포트 안 쓰면 그냥 긴 거리가 답
'''
input = sys.stdin.readline

xs, ys = map(int, input().split())
xe, ye = map(int, input().split())

start_node = (xs, ys)
end_node = (xe, ye)

tp_dic = defaultdict(list)
tp_node = set()

for _ in range(3):
    x1, y1, x2, y2 = map(int, input().split())
    node1 = (x1, y1)
    node2 = (x2, y2)
    
    tp_node.add(node1)
    tp_node.add(node2)

    tp_dic[node1].append((node2, 10))
    tp_dic[node2].append((node1, 10))

key_nodes = list(tp_node)
key_nodes.append(start_node)

distances = {node: float('inf') for node in key_nodes}
distances[start_node] = 0

pq = [(0, start_node)]

# 시작점에서 도착점까지 가는 비용 (이게 기본 답)
min_cost = abs(xs - xe) + abs(ys - ye)

while pq:
    current_cost, current_node = heapq.heappop(pq)

    if current_cost > distances[current_node]:
        continue

    # 현재 위치에서 도착점까지 비용
    # (현재까지 비용 + 지금 위치에서 도착점까지 걷는 비용)
    cost_via_current = current_cost + abs(current_node[0] - end_node[0]) + abs(current_node[1] - end_node[1])
    min_cost = min(min_cost, cost_via_current)
    
    # 텔레포트 
    if current_node in tp_dic:
        for next_node, tele_cost in tp_dic[current_node]:
            new_cost = current_cost + tele_cost
            if new_cost < distances[next_node]:
                distances[next_node] = new_cost
                heapq.heappush(pq, (new_cost, next_node))

    # 현재 위치에서 모든 텔레포트 지점까지 비용 계산
    for next_tp_node in tp_node:
        if current_node == next_tp_node:
            continue
            
        walk_cost = abs(current_node[0] - next_tp_node[0]) + abs(current_node[1] - next_tp_node[1])
        new_cost = current_cost + walk_cost
        
        if new_cost < distances[next_tp_node]:
            distances[next_tp_node] = new_cost
            heapq.heappush(pq, (new_cost, next_tp_node))

print(min_cost)
```