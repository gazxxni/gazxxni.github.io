---
layout: post
title: "[백준] 1003번 (Python)"
date: 2024-09-28
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1003"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1003](https://www.acmicpc.net/problem/1003)

---

## 풀이

### 풀이 핵심 로직
이 문제는 피보나치 수열의 n번째 항을 구하는 과정에서, 0이 호출된 횟수와 1이 호출된 횟수를 기록하는 것이다. 동적 프로그래밍(DP)을 이용하여 각 n에 대한 0과 1의 호출 횟수를 미리 계산하여 효율적으로 결과를 도출한다.

### 동작 과정
1. 첫 번째 줄에서 테스트 케이스의 수 `t`를 입력받는다.
2. 각 테스트 케이스에 대해 다음을 수행:
   - `n`을 입력받는다.
   - `dp`라는 리스트를 생성하여 0부터 40까지의 피보나치 수열에 대한 호출 횟수를 저장할 준비를 한다. 각 값은 두 개의 요소를 가진 리스트로, 첫 번째 요소는 0의 호출 횟수, 두 번째 요소는 1의 호출 횟수를 나타낸다.
   - `dp[0]`는 [1, 0] (n=0일 때 0이 1회 호출), `dp[1]`는 [0, 1] (n=1일 때 1이 1회 호출), `dp[2]`는 [1, 1] (n=2일 때 0과 1이 각각 1회 호출)로 초기화한다.
   - 이후 `n`까지의 피보나치 값을 채우기 위해 반복문을 사용하여 `dp[i]`를 `dp[i-1]`과 `dp[i-2]`의 값을 이용해 계산한다.
   - 마지막으로 `dp[n]`에서 0과 1의 호출 횟수를 출력한다.

예시 입력:
```
3
0
1
2
```
출력:
```
1 0
0 1
1 1
```

### 시간 복잡도
시간 복잡도는 O(n)이다. 입력된 n에 대해 최대 40까지의 피보나치 값을 계산하므로, 반복문이 n에 비례하여 수행된다.

---

## 코드
```python
import sys

# t=int(input())

# def fibonacci(n):
#     global cnt0, cnt1
#     if n==0:
#         cnt0+=1
#         return 0
#     elif n==1:
#         cnt1+=1
#         return 1
#     else:
#         return fibonacci(n-1) + fibonacci(n-2)
    
# for _ in range(t):
#     cnt0=0
#     cnt1=0
#     fibonacci(int(input()))
#     print(cnt0,cnt1)


t = int(input())

for _ in range(t):
    n = int(input())

    dp = [[]]*41
    dp[0] = [1,0]
    dp[1] = [0,1]
    dp[2] = [1,1]

    for i in range(3, n+1):
        dp[i] = [dp[i-1][0]+dp[i-2][0],dp[i-1][1]+dp[i-2][1]]

    print(dp[n][0], dp[n][1])

```