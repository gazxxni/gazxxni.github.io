---
layout: post
title: "[백준] 10986번 나머지 합 (Python)"
date: 2025-12-07
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "10986", 수학, 누적 합]
---

## 문제 링크
[https://www.acmicpc.net/problem/10986](https://www.acmicpc.net/problem/10986)

---

## 문제
수 N개 A1, A2, ..., AN이 주어진다. 이때, 연속된 부분 구간의 합이 M으로 나누어 떨어지는 구간의 개수를 구하는 프로그램을 작성하시오.

즉, Ai + ... + Aj (i ≤ j) 의 합이 M으로 나누어 떨어지는 (i, j) 쌍의 개수를 구해야 한다.

---

## 입력
첫째 줄에 N과 M이 주어진다. (1 ≤ N ≤ 106, 2 ≤ M ≤ 103)

둘째 줄에 N개의 수 A1, A2, ..., AN이 주어진다. (0 ≤ Ai ≤ 109)

---

## 출력
첫째 줄에 연속된 부분 구간의 합이 M으로 나누어 떨어지는 구간의 개수를 출력한다.

---

## 성능 요약
메모리: 258100 KB, 시간: 356 ms

---

## 풀이

### 풀이 핵심 로직
주어진 문제에서 연속된 부분 구간의 합이 M으로 나누어 떨어진다는 것은 누적합의 나머지가 같은 경우를 찾는 것으로 변환할 수 있습니다. 즉, 두 인덱스의 누적합의 나머지가 같으면 그 구간의 합은 M으로 나누어 떨어지므로, 누적합을 M으로 나눈 나머지를 카운트하여 해당 나머지를 가진 구간의 개수를 구합니다.

### 동작 과정
1. **입력**: N과 M을 입력받고, N개의 수를 리스트로 저장합니다.
2. **나머지 카운트 배열**: M의 크기만큼의 배열을 생성하여 각 나머지를 카운트합니다. 나머지가 0인 경우는 초기값으로 1을 설정합니다.
3. **누적합 계산**: 배열을 순회하면서 현재 요소를 누적합에 더하고, 이 누적합을 M으로 나눈 나머지를 계산합니다.
4. **나머지 카운트**: 현재 나머지를 카운트 배열에서 증가시킵니다.
5. **쌍의 개수 계산**: 카운트 배열을 순회하면서 각 나머지의 개수를 바탕으로 가능한 쌍의 개수를 계산합니다. cnt > 1인 경우, cnt개의 수에서 쌍을 선택하는 경우의 수는 `cnt * (cnt - 1) // 2`로 계산됩니다.
6. **출력**: 최종적으로 구한 쌍의 개수를 출력합니다.

**예시 입력**:
```
5 3
1 2 3 1 2
```

**단계별 설명**:
- N = 5, M = 3
- 배열 A = [1, 2, 3, 1, 2]
- 누적합과 나머지 계산:
  - i=0: 누적합 = 1, r = 1 (remainder_count[1] = 1)
  - i=1: 누적합 = 3, r = 0 (remainder_count[0] = 2)
  - i=2: 누적합 = 6, r = 0 (remainder_count[0] = 3)
  - i=3: 누적합 = 7, r = 1 (remainder_count[1] = 2)
  - i=4: 누적합 = 9, r = 0 (remainder_count[0] = 4)
- 나머지 카운트: [4, 2, 0]
- 쌍의 개수 계산: 
  - 나머지 0: (4 * 3) // 2 = 6 쌍
  - 나머지 1: (2 * 1) // 2 = 1 쌍
- 최종 결과: 6 + 1 = 7

### 시간 복잡도
O(N) - 배열을 한 번 순회하여 누적합을 계산하고 나머지를 카운트하므로, 총 시간 복잡도는 O(N)입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

'''
1. 구간 합이 M으로 나누어 떨어진다는 것은 
(prefix_sum[j] - prefix_sum[i-1]) % M == 0이라는 뜻

2. 이 식을 이항하면 prefix_sum[j] % M == prefix_sum[i-1] % M

3. 즉, 누적합을 M으로 나눈 나머지가 같은 인덱스들을 찾으면 됨
'''
n, m = map(int, input().split())
arr = list(map(int, input().split()))

# 1. 나머지를 카운트할 배열 또는 딕셔너리 준비
remainder_count = [0] * m

# 2. 누적합 변수 초기화
current_sum = 0

# 3. 나머지가 0인 경우를 미리 카운트
remainder_count[0] = 1 

# 4. 수열을 순회하면서 누적합과 나머지 계산
for x in arr:
    current_sum += x
    r = current_sum % m
    remainder_count[r] += 1

ans = 0
for cnt in remainder_count:
    # 해당 나머지를 가진 누적합의 개수가 2개 이상일 때만 쌍을 만들 수 있음
    if cnt > 1:
        ans += (cnt * (cnt - 1)) // 2

print(ans)
```