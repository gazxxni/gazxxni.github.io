---
layout: post
title: "[백준] 2623번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2623"]
---

## 문제 링크
[https://www.acmicpc.net/problem/2623](https://www.acmicpc.net/problem/2623)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 순서를 기반으로 한 위상 정렬을 통해 해결합니다. 각 팀의 순서를 그래프로 표현하고, 각 팀의 선행 조건을 간선으로 나타내어, 선행 조건이 없는 팀부터 차례로 출력하는 방식입니다. 위상 정렬을 통해 팀 순서를 결정하고, 만약 모든 팀을 정렬할 수 없다면 0을 출력합니다.

### 동작 과정
1. 입력: `n`팀과 `m`개의 순서 정보가 주어집니다. 예를 들어 `n=5`, `m=3`이고 주어진 순서 정보가 다음과 같다고 가정합니다:
   ```
   3 1 2 3
   2 4 5
   1 4
   ```
   이는 팀 1, 2, 3이 순서대로 나오고, 팀 4와 5가 그 뒤에 나와야 한다는 의미입니다.

2. 그래프 생성: 각 팀을 노드로 하고, 주어진 순서를 기반으로 간선을 추가합니다. `indegree` 배열을 사용해 각 팀이 몇 개의 선행 팀을 가지고 있는지 기록합니다.

3. 위상 정렬 수행:
   - `indegree`가 0인 팀을 큐에 추가합니다.
   - 큐에서 팀을 하나 꺼내고, 그 팀과 연결된 다른 팀의 `indegree`를 감소시킵니다.
   - 만약 `indegree`가 0이 된 팀이 있다면 큐에 추가합니다.
   - 이 과정을 큐가 빌 때까지 반복합니다.

4. 결과 확인: 결과 리스트의 길이가 `n`과 같으면, 모든 팀의 순서를 올바르게 정렬한 것이므로 순서를 출력합니다. 그렇지 않으면, 0을 출력합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n + m)입니다. 여기서 `n`은 팀의 수, `m`은 주어진 순서의 수입니다. 그래프의 모든 간선과 노드를 한 번씩 방문하므로 선형 시간 복잡도를 가집니다.

---

## 코드
```python
import sys
input = sys.stdin.readline
from collections import deque

n, m = map(int, input().split())
graph = [[] for _ in range(n + 1)]
indegree = [0] * 10001

for _ in range(m):
    data = list(map(int, input().split()))
    order = data[1:] 

    for i in range(len(order) - 1):
        a, b = order[i], order[i + 1]
        graph[a].append(b)
        indegree[b] += 1



def topological_sort():
    q = deque()

    for i in range(1, n + 1): 
        if indegree[i] == 0:
            q.append(i)

    result = []

    while q:
        node = q.popleft()
        result.append(node)

        for neighbor in graph[node]:
            indegree[neighbor] -= 1
            if indegree[neighbor] == 0:
                q.append(neighbor)

    return result

ans = topological_sort()

if len(ans) == n:
    for x in ans:
        print(x)
else:
    print(0)


```