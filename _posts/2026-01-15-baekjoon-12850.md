---
layout: post
title: "[백준] 12850번 본대 산책2 (Python)"
date: 2026-01-15
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "12850", 수학, 그래프 이론, 분할 정복을 이용한 거듭제곱]
---

## 문제 링크
[https://www.acmicpc.net/problem/12850](https://www.acmicpc.net/problem/12850)

---

## 문제
숭실 대학교 정보 과학관은 유배를 당해서  캠퍼스의 길 건너편에 있다. 그래서 컴퓨터 학부 학생들은 캠퍼스를 ‘본대’ 라고 부르고 정보 과학관을 ‘정보대’ 라고 부른다. 준영이 또한 컴퓨터 학부 소속 학생이라서 정보 과학관에 박혀있으며 항상 꽃 이 활짝 핀 본 대를 선망한다. 어느 날 준영이는 본 대를 산책하기로 결심하였다. 숭실 대학교 캠퍼스 지도는 아래와 같다.



(편의 상 문제에서는 위 건물만 등장한다고 가정하자)

한 건물에서 바로 인접한 다른 건물로 이동 하는 데 1분이 걸린다. 준영이는 산책 도중에 한번도 길이나 건물에 멈춰서 머무르지 않는다. 준영이는 할 일이 많아서 딱 D분만 산책을 할 것이다. (산책을 시작 한 지 D분 일 때, 정보 과학관에 도착해야 한다.) 이때 가능한 경로의 경우의 수를 구해주자.

---

## 입력
D 가 주어진다 (1 ≤ D ≤ 1,000,000,000)

---

## 출력
가능한 경로의 수를 1,000,000,007로 나눈 나머지를 출력한다.

---

## 성능 요약
메모리: 109544 KB, 시간: 96 ms

---

## 풀이

### 풀이 핵심 로직
주어진 그래프를 행렬로 표현하여, 행렬의 거듭제곱을 통해 D분 후 본대로 도달할 수 있는 경로의 수를 구합니다. 이 과정에서 행렬의 곱셈을 사용하여 각 건물 간의 연결 정보를 유지하며, 분할 정복을 통해 효율적으로 계산합니다.

### 동작 과정
1. **그래프 표현**: 문제에서 주어진 건물 간의 연결을 8x8 행렬로 표현합니다. 행렬의 각 원소는 두 건물 간의 연결 여부를 나타냅니다.
   - 예를 들어, `graph[0][1] = 1`은 0번 건물(본대)와 1번 건물(정보대)이 연결되어 있음을 의미합니다.
   
2. **행렬 거듭제곱**: D분 후 도달할 수 있는 경로의 수는 `graph` 행렬을 D번 곱한 결과에서 `result[0][0]`의 값으로 얻을 수 있습니다. 이는 본대에서 본대로 돌아오는 경로의 수를 나타냅니다.

3. **분할 정복 적용**: 행렬의 거듭제곱을 구할 때, n이 짝수일 경우 `A^n = (A^(n/2))^2`로, 홀수일 경우 `A^n = A * (A^(n-1))`로 분할하여 재귀적으로 계산합니다. 이를 통해 O(log D) 시간 복잡도로 거듭제곱을 수행합니다.

4. **출력**: 최종적으로 계산된 결과를 1,000,000,007로 나눈 나머지를 출력합니다.

### 시간 복잡도
O(log D) - D가 매우 클 때도 효율적으로 행렬의 거듭제곱을 수행할 수 있습니다. 행렬의 곱셈은 O(N^3) 시간이 소요되지만, 이 문제에서는 N이 고정되어 있어 실질적으로 빠른 계산이 가능합니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

MOD = 1_000_000_007

graph = [
    [0,1,1,0,0,0,0,0],
    [1,0,1,1,0,0,0,0],
    [1,1,0,1,1,0,0,0],
    [0,1,1,0,1,1,0,0],
    [0,0,1,1,0,1,0,1],
    [0,0,0,1,1,0,1,0],
    [0,0,0,0,0,1,0,1],
    [0,0,0,0,1,0,1,0],
]

d = int(input().strip())

def multiply(A, B):
    result = [[0] * 8 for i in range(8)]
  
    for i in range(8):
        for j in range(8):
            for k in range(8):
                result[i][j] += A[i][k] * B[k][j]
            result[i][j] %= MOD
      
    return result

def cal(A, n):
    if n == 1:
        return A
    cal2 = cal(A, n//2)
    
    if n % 2 == 0:
        return multiply(cal2, cal2)
    else:
        mul2 = multiply(cal2, cal2)
        return multiply(mul2, A)
    
result = cal(graph, d)
print(result[0][0])
```