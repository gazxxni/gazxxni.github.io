---
layout: post
title: "[백준] 15649번 N과 M (1) (Python)"
date: 2026-01-16
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "15649", 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/15649](https://www.acmicpc.net/problem/15649)

---

## 문제
자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.


	1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열

---

## 입력
첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)

---

## 출력
한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.

수열은 사전 순으로 증가하는 순서로 출력해야 한다.

---

## 성능 요약
메모리: 113968 KB, 시간: 164 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 백트래킹 기법을 활용하여 1부터 N까지의 자연수 중에서 M개의 수를 중복 없이 선택하여 수열을 생성하는 것입니다. 수열의 길이가 M에 도달할 때마다 해당 수열을 출력하며, 중복을 피하기 위해 이미 선택한 수는 다시 선택하지 않도록 관리합니다.

### 동작 과정
1. 입력으로 N과 M을 받습니다. 예를 들어, 입력이 `4 2`라면 1부터 4까지의 숫자 중에서 2개를 선택해야 합니다.
2. 빈 리스트 `arr`를 선언하여 현재 선택된 수를 저장합니다.
3. 재귀 함수 `aa()`를 정의합니다. 이 함수는 현재 선택된 수의 길이가 M에 도달하면 수열을 출력하고, 그렇지 않으면 1부터 N까지의 숫자를 순회하며 다음 수를 선택합니다.
4. 각 숫자 `i`에 대해, 이미 선택된 수가 아닐 경우 `arr`에 추가하고 재귀 호출을 통해 다음 수를 선택합니다. 호출이 끝난 후에는 `arr`에서 마지막으로 추가한 수를 제거하여 다음 조합을 위한 상태를 되돌립니다.
5. 이 과정을 반복하여 모든 가능한 수열을 생성하고 출력합니다.

#### 예시 입력: 
```
4 2
```

#### 단계별 설명:
1. `arr`는 빈 리스트로 시작합니다.
2. 첫 번째 호출 `aa()`에서 `i = 1`을 선택하여 `arr`은 `[1]`이 됩니다.
   - 다음 재귀 호출에서 `i = 2`를 선택하여 `arr`은 `[1, 2]`가 됩니다. 길이가 M(2)에 도달했으므로 `1 2`를 출력합니다.
   - 이후 `i = 3`과 `i = 4`에 대한 재귀 호출을 통해 `[1, 3]`와 `[1, 4]`를 출력합니다.
3. 첫 번째 호출에서 `i = 2`를 선택하여 `arr`은 `[2]`가 됩니다.
   - 다음 재귀 호출에서 `i = 1`을 선택하면 `arr`은 `[2, 1]`이 되고, 출력은 `2 1`입니다. 이후 `i = 3`과 `i = 4`로 `[2, 3]`, `[2, 4]`를 출력합니다.
4. 이 과정을 반복하여 `[3, 1]`, `[3, 2]`, `[3, 4]`, `[4, 1]`, `[4, 2]`, `[4, 3]`도 출력됩니다.

### 시간 복잡도
이 알고리즘은 각 수에 대해 선택 여부를 결정하는 과정을 포함하기 때문에 최악의 경우 O(N!)의 시간 복잡도를 가집니다. 이는 N이 최대 8이므로, 가능한 모든 조합을 탐색하는 데 효율적입니다.

---

## 코드
```python
n, m = map(int, input().split())
arr = []

def aa():
    if len(arr) == m:
        print(*arr)
        return
    
    for i in range(1, n + 1):
        if i not in arr:
            arr.append(i)
            aa()
            arr.pop()
            
aa()
```