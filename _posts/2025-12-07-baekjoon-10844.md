---
layout: post
title: "[백준] 10844번 쉬운 계단 수 (Python)"
date: 2025-12-07
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "10844", 다이나믹 프로그래밍]
---

## 문제 링크
[https://www.acmicpc.net/problem/10844](https://www.acmicpc.net/problem/10844)

---

## 문제
45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.

---

## 입력
첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

---

## 출력
첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

---

## 성능 요약
메모리: 108384 KB, 시간: 84 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 다이나믹 프로그래밍을 사용하여 길이가 N인 계단 수의 개수를 계산하는 문제입니다. 계단 수는 인접한 자리의 차이가 1이므로, 특정 자리의 수가 주어지면 그 앞자리 수는 1 낮거나 1 높아야 합니다. 이를 바탕으로 DP 테이블을 구성하여 각 자리수에 대해 가능한 경우의 수를 누적하여 계산합니다.

### 동작 과정
1. **초기화**: DP 테이블을 초기화합니다. `dp[i][j]`는 길이가 `i`인 계단 수의 마지막 자리수가 `j`일 때의 경우의 수를 나타냅니다. 길이가 1인 계단 수는 1부터 9까지의 수만 가능하므로, `dp[1][2:11]`에 1을 할당합니다.

2. **점화식 적용**: 길이가 2 이상인 경우, 각 자리수에 대해 이전 자리수에서 올 수 있는 경우를 계산합니다.
   - `dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]`로 정의합니다. 즉, 현재 자리수 `j`는 이전 자리수 `j-1` 또는 `j+1`에서 올 수 있습니다.

3. **결과 계산**: 최종적으로 길이가 N인 계단 수의 총 개수는 `sum(dp[n])`으로 구할 수 있으며, 이를 1,000,000,000으로 나눈 나머지를 출력합니다.

예시 입력으로 N=2가 들어오면:
- 초기 DP 테이블은 다음과 같습니다:
  ```
  dp[1][1] = 0
  dp[1][2] = 1
  dp[1][3] = 1
  dp[1][4] = 1
  dp[1][5] = 1
  dp[1][6] = 1
  dp[1][7] = 1
  dp[1][8] = 1
  dp[1][9] = 1
  dp[1][10] = 0
  ```
- 길이가 2인 경우에서는:
  - `dp[2][1]` = `dp[1][2]`(1) = 1
  - `dp[2][2]` = `dp[1][1]`(0) + `dp[1][3]`(1) = 1
  - `dp[2][3]` = `dp[1][2]`(1) + `dp[1][4]`(1) = 2
  - ...이런 식으로 계산을 진행합니다.

4. 최종적으로 `sum(dp[2])`를 계산하여 결과를 출력합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(N)입니다. 각 자리수에 대해 최대 10개의 경우를 계산하므로, 전체적으로 N에 비례하는 시간 복잡도를 가집니다.

---

## 코드
```python
n = int(input())

dp = [[0] * 12 for _ in range(n + 1)]
dp[1][2:11] = [1] * 9

for i in range(2, n + 1):
    for j in range(1, 11):
        dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]
        
ans = sum(dp[n])
print(ans % 1000000000)
```