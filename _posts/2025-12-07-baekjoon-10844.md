---
layout: post
title: "[백준] 10844번 쉬운 계단 수 (Python)"
date: 2025-12-07
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, 10844, 다이나믹 프로그래밍]
---

## 문제 링크
[https://www.acmicpc.net/problem/10844](https://www.acmicpc.net/problem/10844)

---

## 문제
45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.

---

## 입력
첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

---

## 출력
첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

---

## 성능 요약
메모리: 108384 KB, 시간: 84 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 길이가 N인 계단 수를 구하는 문제로, 인접한 자리의 차이가 항상 1인 수를 의미합니다. 다이나믹 프로그래밍을 사용하여 각 자리에서 가능한 계단 수의 개수를 누적하여 계산합니다. `dp[i][j]`를 길이가 `i`인 계단 수의 마지막 숫자가 `j`일 때의 경우의 수로 정의합니다.

### 동작 과정
1. **입력받기**: N을 입력받습니다.
2. **초기화**: `dp` 배열을 생성하고, 길이가 1인 계단 수를 초기화합니다. 1~9까지의 숫자는 각 자리에서 시작할 수 있으므로 `dp[1][2:11]`에 1을 할당합니다.
3. **점화식 작성**: 길이가 i인 계단 수의 마지막 숫자 j에 대해, `dp[i][j]`는 `dp[i-1][j-1]`와 `dp[i-1][j+1]`의 합으로 정의합니다. 이는 j-1 또는 j+1로 이어질 수 있기 때문입니다.
4. **계산 반복**: 2부터 N까지 반복하여 각 자리수에 대한 경우의 수를 계산합니다.
5. **결과 반환**: 최종적으로 길이가 N인 계단 수의 총합을 구하고, 1,000,000,000으로 나눈 나머지를 출력합니다.

**예시**: N = 2일 때
- dp[1] 초기화: [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0] (1~9)
- dp[2] 계산:
  - j = 1: dp[2][1] = dp[1][0] + dp[1][2] = 0 + 1 = 1
  - j = 2: dp[2][2] = dp[1][1] + dp[1][3] = 0 + 1 = 1
  - j = 3: dp[2][3] = dp[1][2] + dp[1][4] = 1 + 1 = 2
  - j = 4: dp[2][4] = dp[1][3] + dp[1][5] = 1 + 1 = 2
  - ...
  - j = 9: dp[2][9] = dp[1][8] + dp[1][10] = 1 + 0 = 1
- 최종 dp[2] = [0, 1, 1, 2, 2, 2, 2, 2, 1, 0] → 총합 = 1 + 1 + 2 + 2 + 2 + 2 + 2 + 1 = 12

### 시간 복잡도
O(N) - N에 대해 반복하면서 각 자리수에 대해 상수 시간에 계산을 수행하기 때문에, 전체 시간 복잡도는 O(N)입니다.

---

## 코드
```python
n = int(input())

dp = [[0] * 12 for _ in range(n + 1)]
dp[1][2:11] = [1] * 9

for i in range(2, n + 1):
    for j in range(1, 11):
        dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]
        
ans = sum(dp[n])
print(ans % 1000000000)
```