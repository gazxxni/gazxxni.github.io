---
layout: post
title: "[백준] 2143번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2143"]
---

## 문제 링크
[https://www.acmicpc.net/problem/2143](https://www.acmicpc.net/problem/2143)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 두 배열 A와 B의 모든 부분합을 계산하여, 이들의 조합이 주어진 정수 t와 일치하는 경우의 수를 세는 것입니다. 두 배열의 부분합을 각각 정렬한 후, 두 포인터를 사용하여 합이 t가 되는 조합의 개수를 효율적으로 찾습니다.

### 동작 과정
1. **입력 처리**: 먼저 t, n, A, m, B를 입력받습니다.
   - 예시 입력: 
     ```
     5
     3
     1 2 3
     2
     2 1
     ```

2. **부분합 계산**:
   - 배열 A의 부분합을 계산합니다:
     - A[0:1] = 1
     - A[0:2] = 3
     - A[0:3] = 6
     - A[1:2] = 2
     - A[1:3] = 5
     - A[2:3] = 3
     - 결과적으로 `arr = [1, 3, 6, 2, 5, 3]`
   - 배열 B의 부분합을 계산합니다:
     - B[0:1] = 2
     - B[1:2] = 1
     - 결과적으로 `brr = [2, 1]`
   
3. **부분합 정렬**:
   - `arr`을 오름차순으로, `brr`을 내림차순으로 정렬합니다:
     - `arr = [1, 2, 3, 3, 5, 6]`
     - `brr = [2, 1]`

4. **두 포인터 사용**:
   - 두 포인터 i와 j를 각각 `arr`과 `brr`의 시작 위치에 두고, 다음을 반복합니다:
     - 현재 합 `current = arr[i] + brr[j]`를 계산합니다.
     - 만약 `current`가 t와 같으면, 해당 부분합의 빈도를 계산하여 결과에 반영합니다.
     - `current`가 t보다 작으면 i를 증가시키고, t보다 크면 j를 증가시킵니다.
   - 이 과정을 통해 두 배열의 부분합 조합을 효율적으로 탐색합니다.

5. **결과 출력**: 최종적으로 결과를 출력합니다. 조합이 없는 경우 -1을 출력합니다.

### 시간 복잡도
- 부분합을 계산하는 과정에서 각각 O(n^2)와 O(m^2)의 시간이 소요됩니다.
- 정렬 과정은 O(n log n)과 O(m log m)입니다.
- 두 포인터를 사용하는 과정은 O(n + m)입니다.
- 따라서 전체 시간 복잡도는 O(n^2 + m^2 + n log n + m log m)입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

t = int(input())
n = int(input())
A = list(map(int, input().split()))
m = int(input())
B = list(map(int, input().split()))

arr = []
brr = []

for i in range(n): 
    sum = 0
    for j in range(i, n): 
        sum += A[j]
        arr.append(sum)

for i in range(m): 
    sum = 0
    for j in range(i, m): 
        sum += B[j]
        brr.append(sum)

arr.sort()
brr.sort(reverse=True)

i, j = 0, 0
result = 0

while i < len(arr) and j < len(brr):
    current = arr[i] + brr[j]

    if current == t:
        aa = arr[i]
        bb = brr[j]
        a_cnt = b_cnt = 0

        while i < len(arr) and arr[i] == aa:
            a_cnt += 1
            i += 1

        while j < len(brr) and brr[j] == bb:
            b_cnt += 1
            j += 1

        result += a_cnt * b_cnt

    elif current < t:
        i += 1
    else:
        j += 1

print(result if result > 0 else -1)



# =============================================================
# Counter 방식

# from collections import Counter

# t = int(input())
# n = int(input())
# A = list(map(int, input().split()))
# m = int(input())
# B = list(map(int, input().split()))

# arr, brr = [], []

# for i in range(n): 
#     sum = 0
#     for j in range(i, n): 
#         sum += A[j]
#         arr.append(sum)

# for i in range(m): 
#     sum = 0
#     for j in range(i, m): 
#         sum += B[j]
#         brr.append(sum)

# # B의 부분합 빈도 저장
# b_counter = Counter(brr)

# # A 부분합과 T - a 를 만족하는 b의 개수 세기
# result = 0
# for a in arr:
#     result += b_counter[t - a]

# print(result)

```