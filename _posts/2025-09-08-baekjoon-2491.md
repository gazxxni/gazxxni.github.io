---
layout: post
title: "[백준] 2491번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2491"]
---

## 문제 링크
[https://www.acmicpc.net/problem/2491](https://www.acmicpc.net/problem/2491)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 수열에서 증가하는 부분 수열과 감소하는 부분 수열의 최대 길이를 구하는 문제입니다. 각 숫자를 비교하여 증가하는 경우와 감소하는 경우의 길이를 각각 기록하고, 마지막에 두 배열에서 가장 큰 값을 찾아 출력하는 방식으로 해결합니다.

### 동작 과정
1. **입력 단계**: 사용자로부터 정수 `n`과 `n`개의 정수로 이루어진 리스트 `arr`를 입력받습니다.
   - 예시 입력: 
     ```
     8
     1 2 2 3 2 1 1 1
     ```
   
2. **변수 초기화**: 두 개의 리스트 `inc`와 `dec`를 각각 길이 `n`으로 초기화하여, 각 인덱스에 1을 저장합니다. 이는 각 원소가 최소한 자기 자신만으로 이루어진 부분 수열을 포함하고 있음을 의미합니다.
   - `inc` = [1, 1, 1, 1, 1, 1, 1, 1]
   - `dec` = [1, 1, 1, 1, 1, 1, 1, 1]

3. **길이 계산**: 두 개의 for 루프를 통해 `arr`의 요소를 비교합니다.
   - 증가 부분 수열 계산:
     - i=1: `arr[1] (2) >= arr[0] (1)` → `inc[1] = inc[0] + 1` → `inc` = [1, 2, 1, 1, 1, 1, 1, 1]
     - i=2: `arr[2] (2) >= arr[1] (2)` → `inc[2] = inc[1] + 1` → `inc` = [1, 2, 3, 1, 1, 1, 1, 1]
     - i=3: `arr[3] (3) >= arr[2] (2)` → `inc[3] = inc[2] + 1` → `inc` = [1, 2, 3, 4, 1, 1, 1, 1]
     - 나머지 원소들에 대해서도 동일하게 진행.
   - 감소 부분 수열 계산:
     - i=4: `arr[4] (2) <= arr[3] (3)` → `dec[4] = dec[3] + 1` → `dec` = [1, 1, 1, 1, 2, 1, 1, 1]
     - i=5: `arr[5] (1) <= arr[4] (2)` → `dec[5] = dec[4] + 1` → `dec` = [1, 1, 1, 1, 2, 3, 1, 1]
     - 나머지 원소들에 대해서도 동일하게 진행.

4. **최대 길이 출력**: `max(max(inc), max(dec))`를 통해 증가 부분 수열과 감소 부분 수열의 최대 길이를 구하고 출력합니다.
   - 결과: `max(inc)` = 4, `max(dec)` = 4 → 출력값 = 4

### 시간 복잡도
이 알고리즘은 입력 리스트를 한 번 순회하며 증가 및 감소 부분 수열의 길이를 계산하므로 시간 복잡도는 O(n)입니다. 여기서 n은 입력으로 주어진 수의 개수입니다.

---

## 코드
```python
n = int(input())
arr = list(map(int, input().split()))

inc = [1] * n
dec = [1] * n 

for i in range(1, n):
    if arr[i] >= arr[i-1]:  
        inc[i] = inc[i-1] + 1
        
    if arr[i] <= arr[i-1]: 
        dec[i] = dec[i-1] + 1

print(max(max(inc), max(dec)))

```