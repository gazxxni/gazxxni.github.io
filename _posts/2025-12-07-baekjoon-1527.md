---
layout: post
title: "[백준] 1527번 금민수의 개수 (Python)"
date: 2025-12-07
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1527", 브루트포스 알고리즘]
---

## 문제 링크
[https://www.acmicpc.net/problem/1527](https://www.acmicpc.net/problem/1527)

---

## 문제
은민이는 4와 7을 좋아하고, 나머지 숫자는 싫어한다. 금민수는 어떤 수가 4와 7로만 이루어진 수를 말한다.

A와 B가 주어졌을 때, A보다 크거나 같고, B보다 작거나 같은 자연수 중에 금민수인 것의 개수를 출력하는 프로그램을 작성하시오.

---

## 입력
첫째 줄에 A와 B가 주어진다. A는 1보다 크거나 같고, 1,000,000,000보다 작거나 같은 자연수이다. B는 A보다 크거나 같고, 1,000,000,000보다 작거나 같은 자연수이다.

---

## 출력
첫째 줄에 A보다 크거나 같고, B보다 작거나 같은 자연수 중에 금민수인 것의 개수를 출력한다.

---

## 성능 요약
메모리: 108384 KB, 시간: 92 ms

---

## 풀이

### 풀이 핵심 로직
금민수는 4와 7로만 이루어진 자연수로 정의됩니다. 주어진 범위 [A, B] 내에서 금민수를 찾기 위해, 4와 7로 구성된 모든 수를 생성하고 이 수들이 A 이상 B 이하인지 확인하여 개수를 센다. 이를 위해 브루트포스 방식을 사용해 가능한 모든 조합을 생성한다.

### 동작 과정
1. **입력**: A와 B를 입력받습니다. 예를 들어, A = 10, B = 100이라고 가정합니다.
2. **금민수 생성**: 
   - 길이가 1부터 9까지의 금민수를 생성합니다. 
   - 각 길이에 대해, 이전 길이의 금민수 앞에 '4' 또는 '7'을 붙여 새로운 금민수를 생성합니다.
   - 예를 들어, 길이 1의 금민수는 '4', '7'이고, 길이 2의 금민수는 '44', '47', '74', '77'입니다.
3. **범위 확인**: 
   - 생성된 금민수를 A와 B의 범위에 맞추어 확인합니다.
   - 금민수가 A 이상이고 B 이하인 경우 카운트를 증가시킵니다.
   - 위 예시에서는 A=10, B=100 사이의 금민수인 '44', '47', '74', '77'을 확인하여 4개의 금민수를 세게 됩니다.
4. **출력**: 최종적으로 카운트를 출력합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(2^n)입니다. 여기서 n은 금민수의 최대 길이(9)입니다. 각 길이에 대해 두 가지 선택(4 또는 7)을 하므로 지수적으로 증가하는 수의 조합을 생성합니다. 하지만 실제로는 4와 7로만 이루어진 수의 수가 제한적이기 때문에, 비교적 빠르게 작동합니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

a, b = map(int, input().split())
arr = [[] for _ in range(10)]
brr = [[] for _ in range(10)]
arr[0].append('4')
brr[0].append('7')

for i in range(1,10):
    for j in arr[i - 1]:
        arr[i].append('4' + j)
        arr[i].append('7' + j)
    for k in brr[i - 1]:
        brr[i].append('4' + k)
        brr[i].append('7' + k)

aa = len(str(a))
bb = len(str(b))
cnt = 0
for i in range(10):
    for j in arr[i]:
        if a <= int(j) <= b:
            cnt += 1
    
    for k in brr[i]:
        if a <= int(k) <= b:
            cnt += 1
            
print(cnt)
```