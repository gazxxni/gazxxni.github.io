---
layout: post
title: "[백준] 1527번 금민수의 개수 (Python)"
date: 2025-12-07
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, 1527, 브루트포스 알고리즘]
---

## 문제 링크
[https://www.acmicpc.net/problem/1527](https://www.acmicpc.net/problem/1527)

---

## 문제
은민이는 4와 7을 좋아하고, 나머지 숫자는 싫어한다. 금민수는 어떤 수가 4와 7로만 이루어진 수를 말한다.

A와 B가 주어졌을 때, A보다 크거나 같고, B보다 작거나 같은 자연수 중에 금민수인 것의 개수를 출력하는 프로그램을 작성하시오.

---

## 입력
첫째 줄에 A와 B가 주어진다. A는 1보다 크거나 같고, 1,000,000,000보다 작거나 같은 자연수이다. B는 A보다 크거나 같고, 1,000,000,000보다 작거나 같은 자연수이다.

---

## 출력
첫째 줄에 A보다 크거나 같고, B보다 작거나 같은 자연수 중에 금민수인 것의 개수를 출력한다.

---

## 성능 요약
메모리: 108384 KB, 시간: 92 ms

---

## 풀이

### 풀이 핵심 로직
금민수는 4와 7로만 이루어진 수이므로, 모든 가능한 조합을 생성하여 A와 B 사이에 있는 금민수를 찾는 방식으로 문제를 해결한다. 이를 위해 브루트포스 알고리즘을 사용하여 4와 7로 이루어진 숫자를 생성하고, 각각의 숫자가 주어진 범위 내에 있는지 확인하여 카운트한다.

### 동작 과정
1. 입력으로 A와 B가 주어진다. 예를 들어, A = 40, B = 100.
2. 금민수는 4와 7로만 이루어진 수이므로, 먼저 1자리부터 시작하여 최대 10자리까지 모든 조합을 생성한다.
   - 1자리: 4, 7
   - 2자리: 44, 47, 74, 77
   - 3자리: 444, 447, 474, 477, 744, 747, 774, 777
   - ...
3. 생성된 금민수들을 A와 B의 범위에 맞게 필터링한다. 예를 들어, 40 이상 100 이하인 금민수를 찾는다.
   - 유효한 금민수: 44, 47, 74, 77
4. 최종적으로 A와 B 사이에 있는 금민수의 개수를 카운트하여 출력한다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(2^n)으로 볼 수 있다. (n은 금민수의 자리수) 최대 10자리까지 생성할 수 있으므로, 실제로는 2^10 = 1024개의 금민수를 생성하게 된다. 주어진 범위 내에서 유효한 금민수를 체크하는 과정은 O(1)로 간주할 수 있으므로 전체적으로는 생성된 금민수의 개수에 비례한다.

---

## 코드
```python
import sys
input = sys.stdin.readline

a, b = map(int, input().split())
arr = [[] for _ in range(10)]
brr = [[] for _ in range(10)]
arr[0].append('4')
brr[0].append('7')

for i in range(1,10):
    for j in arr[i - 1]:
        arr[i].append('4' + j)
        arr[i].append('7' + j)
    for k in brr[i - 1]:
        brr[i].append('4' + k)
        brr[i].append('7' + k)

aa = len(str(a))
bb = len(str(b))
cnt = 0
for i in range(10):
    for j in arr[i]:
        if a <= int(j) <= b:
            cnt += 1
    
    for k in brr[i]:
        if a <= int(k) <= b:
            cnt += 1
            
print(cnt)
```