---
layout: post
title: "[백준] 26215번 눈 치우기 (Python)"
date: 2026-01-15
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "26215", 구현, 그리디 알고리즘, 정렬, 시뮬레이션]
---

## 문제 링크
[https://www.acmicpc.net/problem/26215](https://www.acmicpc.net/problem/26215)

---

## 문제
지난 밤 겨울 숲에는 눈이 많이 내렸다. 당신은 숲의 주민들을 위해 눈이 오지 않는 동안 모든 집 앞의 눈을 치우고자 한다.

당신은 1분에 한 번씩 두 집을 선택해서 두 집 앞의 눈을 각각 1만큼 치우거나, 한 집을 선택해서 그 집 앞의 눈을 1만큼 치울 수 있다.

모든 집 앞의 눈을 전부 치울 때까지 걸리는 최소 시간은 얼마일까?

---

## 입력
첫 줄에 집의 수를 의미하는 정수 N$N$ (1≤N≤100$1 \leq N \leq 100$)이 주어진다.

다음 줄에는 각각의 집 앞에 쌓여 있는 눈의 양을 나타내는 정수 ai$a_{i}$ (1≤ai≤2000$1 \leq a_{i} \leq 2000$)이 주어진다.

---

## 출력
모든 집 앞의 눈을 치우는 데 최소 몇 분이 걸리는지를 출력한다. 24시간(1440분)이 넘게 걸릴 경우 -1을 출력한다.

---

## 성능 요약
메모리: 108384 KB, 시간: 88 ms

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 가장 눈이 많이 쌓인 두 집을 선택하여 동시에 눈을 치우는 방법을 최대한 활용하는 것입니다. 이를 위해 매 반복마다 가장 많은 눈이 쌓인 두 집을 선택하고, 그 집의 눈을 제거하여 시간 최적화를 꾀합니다. 모든 집의 눈을 치운 후 걸린 시간을 계산하고, 1440분을 초과할 경우 -1을 출력합니다.

### 동작 과정
1. **입력 받기**: 첫 번째 줄에서 집의 수 \( N \)을 입력받고, 두 번째 줄에서 각 집 앞의 눈의 양을 리스트에 저장합니다.
2. **정렬 및 눈 치우기**: 반복문을 통해 리스트를 정렬하고, 가장 많은 눈이 쌓인 두 집을 선택합니다.
   - 예를 들어, 집 앞에 쌓인 눈이 `[5, 3, 4]`라고 가정하면, 정렬 후 `[5, 4, 3]`이 됩니다.
   - 가장 큰 두 집의 눈을 동시에 치우기 위해 `arr[0] -= arr[1]`를 실행하고, 이때 걸리는 시간은 `arr[1]`만큼 증가시킵니다.
   - 그 후, 두 번째 집을 제거하여 리스트를 갱신합니다.
3. **종료 조건**: 리스트의 크기가 1이 되면 반복문을 종료합니다. 마지막 남은 집의 눈을 치우기 위해 그 양만큼 시간을 추가합니다.
4. **결과 출력**: 최종적으로 걸린 시간이 1440분을 초과하면 -1을 출력하고, 그렇지 않으면 총 시간을 출력합니다.

예시 입력:
```
3
5 3 4
```
- 초기 상태: `[5, 3, 4]`
- 정렬 후: `[5, 4, 3]`
- 첫 번째 반복: `arr[0]` = 5에서 `arr[1]` = 4를 빼고, 시간 4 증가 → `[1, 3]`
- 두 번째 반복: `[3, 1]`로 정렬 후, `arr[0]` = 3에서 `arr[1]` = 1을 빼고, 시간 1 증가 → `[2]`
- 최종 남은 집 치우기: 시간 2 증가, 총 시간 = 4 + 1 + 2 = 7
- 출력: `7`

### 시간 복잡도
시간 복잡도는 \( O(N^2 \log N) \)입니다. 리스트를 정렬하는 데 \( O(N \log N) \)의 시간이 소요되고, 눈을 치우는 작업이 최대 \( N \)번 이루어지기 때문에 총 복잡도는 이와 같습니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
arr = list(map(int, input().split()))

cnt = 0

while True:
    if len(arr) == 1:
        break
    
    arr.sort(reverse=True)
    arr[0] -= arr[1]
    cnt += arr[1]
    arr.pop(1)
    
cnt += arr[0]
if cnt > 1440:
    print(-1)
else:
    print(cnt)
```