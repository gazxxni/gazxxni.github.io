---
layout: post
title: "[백준] 16946번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "16946"]
---

## 문제 링크
[https://www.acmicpc.net/problem/16946](https://www.acmicpc.net/problem/16946)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 2D 맵에서 0으로 이루어진 영역을 탐색하여 각 영역에 라벨을 붙이고, 이후 1로 이루어진 벽 각각에 대해 인접한 0-영역의 크기를 합산하여 결과를 계산하는 방식입니다. BFS(너비 우선 탐색)를 사용하여 각 0-영역을 구분하고, 그 크기를 저장하여 벽을 부쉈을 때의 결과를 효율적으로 계산합니다.

### 동작 과정
1. **입력 처리 및 초기화**: 
   - 주어진 맵의 크기 `n`과 `m`을 입력받고, 0과 1로 이루어진 맵을 읽어옵니다.
   - 방향 벡터를 정의하여 상하좌우 이동을 가능하게 합니다.

2. **0-영역 라벨링**:
   - `label_components` 함수를 호출하여 맵을 반복하면서 0인 칸을 찾아 BFS를 통해 각 0-영역에 고유한 ID를 부여합니다.
   - BFS를 통해 각 영역의 크기를 측정하고, `comp_id` 리스트에 ID를 저장하며, `comp_size` 리스트에 각 컴포넌트의 크기를 저장합니다.

3. **벽에 대한 결과 계산**:
   - `compute_answer` 함수를 통해 각 1인 칸에 대해 인접한 0-영역의 크기를 합산합니다.
   - 각 벽 칸에서 상하좌우로 탐색하여 서로 다른 컴포넌트의 크기를 합산하고, 결과에 1을 더한 값을 10으로 나눈 나머지를 저장합니다.
   - 빈 칸(0)은 '0'으로, 벽(1)은 계산된 값을 문자열로 변환하여 결과 리스트에 저장합니다.

4. **결과 출력**:
   - 최종 결과 리스트를 출력합니다.

#### 예시 입력
```
4 5
00100
01110
00100
00000
```

#### 동작 과정 예시
- `label_components`를 통해 0-영역을 탐색하면:
  - 첫 번째 0-영역: (0,0), (0,1), (3,0), (3,1), (3,2) → ID 0, 크기 6
- `compute_answer`를 통해 벽에 대한 계산:
  - (0,1) 벽은 ID 0의 크기 6과 인접하므로 결과는 (6 + 1) % 10 = 7 
  - 나머지 벽에 대해서도 같은 방식으로 계산함.
  
최종 결과는:
```
00000
01170
00000
00000
```

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n * m)입니다. 각 칸을 한 번씩 방문하며 BFS를 통해 인접한 영역을 탐색하기 때문에 전체적으로 O(n * m) 시간이 소요됩니다.

---

## 코드
```python
import sys
from collections import deque
input = sys.stdin.readline

n, m = map(int, input().split())
grid = [list(map(int, input().strip())) for _ in range(n)]

directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

def bfs_label(si, sj, cid, grid, comp_id, n, m):
    """
    (si, sj)에서 시작하는 0-영역을 BFS로 라벨링하고 그 크기를 반환한다.
    - grid: 0/1 맵 (list[list[int]])
    - comp_id: 각 칸의 컴포넌트 ID를 담는 2D 리스트 (-1: 미방문/벽)
    - cid: 이번에 부여할 컴포넌트 ID
    - n, m: 행/열 크기
    """
    q = deque()
    q.append((si, sj))
    comp_id[si][sj] = cid
    size = 1

    while q:
        x, y = q.popleft()
        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < n and 0 <= ny < m:
                if grid[nx][ny] == 0 and comp_id[nx][ny] == -1:
                    comp_id[nx][ny] = cid
                    size += 1
                    q.append((nx, ny))
    return size

def label_components(grid, n, m):
    """
    모든 0-영역을 컴포넌트로 라벨링한다.
    반환:
      comp_id[i][j] = -1(미방문/벽) 또는 컴포넌트 ID(0..k-1)
      comp_size[cid] = 해당 컴포넌트의 크기
    """
    comp_id = [[-1] * m for _ in range(n)]
    comp_size = []
    cid = 0

    for i in range(n):
        for j in range(m):
            if grid[i][j] == 0 and comp_id[i][j] == -1:
                size = bfs_label(i, j, cid, grid, comp_id, n, m)
                comp_size.append(size)
                cid += 1
    return comp_id, comp_size

def compute_answer(grid, comp_id, comp_size, n, m):
    """
    결과 맵을 문자열 리스트로 만든다.
    - 빈 칸(0): '0'
    - 벽(1): 인접한 서로 다른 컴포넌트 크기를 합쳐 1을 더하고 % 10
    """
    out_lines = []
    for i in range(n):
        row_chars = []
        for j in range(m):
            if grid[i][j] == 0:
                row_chars.append('0')
            else:
                seen = set()
                s = 1  # 현재 벽 칸을 부쉈을 때 생기는 칸 1개
                for dx, dy in directions:
                    ni, nj = i + dx, j + dy
                    if 0 <= ni < n and 0 <= nj < m:
                        ncid = comp_id[ni][nj]
                        if ncid != -1 and ncid not in seen:
                            seen.add(ncid)
                            s += comp_size[ncid]
                row_chars.append(str(s % 10))
        out_lines.append(''.join(row_chars))
    return out_lines


comp_id, comp_size = label_components(grid, n, m)
answer_lines = compute_answer(grid, comp_id, comp_size, n, m)
print('\n'.join(answer_lines))

```