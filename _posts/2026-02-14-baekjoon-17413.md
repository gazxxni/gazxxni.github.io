---
layout: post
title: "[백준] 17413번 단어 뒤집기 2 (Python)"
date: 2026-02-14
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "17413", 구현, 자료 구조, 문자열, 스택]
---

## 문제 링크
[https://www.acmicpc.net/problem/17413](https://www.acmicpc.net/problem/17413)

## 문제
문자열 S가 주어졌을 때, 이 문자열에서 단어만 뒤집으려고 한다.

먼저, 문자열 S는 아래와과 같은 규칙을 지킨다.


	알파벳 소문자('a'-'z'), 숫자('0'-'9'), 공백(' '), 특수 문자('', '>')로만 이루어져 있다.
	문자열의 시작과 끝은 공백이 아니다.
	''와 '>'가 문자열에 있는 경우 번갈아가면서 등장하며, ''이 먼저 등장한다. 또, 두 문자의 개수는 같다.


태그는 ''로 시작해서 '>'로 끝나는 길이가 3 이상인 부분 문자열이고, ''와 '>' 사이에는 알파벳 소문자와 공백만 있다. 단어는 알파벳 소문자와 숫자로 이루어진 부분 문자열이고, 연속하는 두 단어는 공백 하나로 구분한다. 태그는 단어가 아니며, 태그와 단어 사이에는 공백이 없다.

## 입력
첫째 줄에 문자열 S가 주어진다. S의 길이는 100,000 이하이다.

## 출력
첫째 줄에 문자열 S의 단어를 뒤집어서 출력한다.

## 풀이
### 풀이 핵심 로직
주어진 문자열에서 단어를 뒤집기 위해 각 문자를 순회하면서 태그와 일반 단어를 구분합니다. 태그는 그대로 유지하고, 일반 단어는 스택을 이용해 뒤집은 후 결과 리스트에 추가합니다. 태그와 단어 간의 공백도 적절히 처리합니다.

### 동작 과정
1. 입력 문자열을 한 글자씩 순회합니다.
2. '<' 문자를 만나면 태그의 시작을 나타내므로, 스택에 남아있는 단어를 뒤집어서 결과 리스트에 추가하고, 이후 태그를 그대로 결과 리스트에 추가합니다.
3. '>' 문자를 만나면 태그의 끝을 나타내므로 태그를 결과에 추가하고, 태그 내의 문자는 그대로 유지합니다.
4. 일반 문자를 만나면 스택에 추가하여 뒤집을 준비를 하고, 공백을 만나면 스택에 있는 단어를 뒤집어서 결과에 추가한 후, 공백을 추가합니다.
5. 모든 문자를 처리한 후 스택에 남아있는 단어를 뒤집어 결과에 추가합니다.

예시 입력: 
```
<abc def> ghi <jkl>
```
- 순회 과정:
  - `<`를 만나고, 스택 비워서 결과에 추가: `[] -> <`
  - `abc def`를 만나고, 태그 끝인 `>`를 만나서 결과에 추가: `<abc def>`
  - `ghi`를 스택에 추가: `['g', 'h', 'i']`
  - 공백을 만나면 스택을 비우고 결과에 추가: `<abc def> ghi `
  - `<`를 만나고, 스택 비워서 결과에 추가: `<abc def> ghi `
  - `jkl`을 만나고, 태그 끝인 `>`를 만나서 결과에 추가: `<abc def> ghi <jkl>`

최종 결과: `<abc def> ihg <jkl>`

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n)입니다. 문자열 S의 길이에 비례하여 각 문자를 한 번씩 처리하기 때문입니다.

## 코드
```python
import sys
from collections import deque

s = sys.stdin.readline().rstrip()
q = deque()
ans = []
flag = False

for word in s:
    if word == '<':
        flag = True
        while q:
            ans.append(q.popleft())
        ans.append(word)
    
    elif word == '>':
        flag = False
        ans.append(word)
    
    elif flag:
        ans.append(word)
        
    elif word == ' ':
        while q:
            ans.append(q.popleft())
        ans.append(word)
        
    else:
        q.appendleft(word)

while q:
    ans.append(q.popleft())

print(''.join(ans))
```