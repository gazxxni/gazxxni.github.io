---
layout: post
title: "[백준] 1342번 행운의 문자열 (Python)"
date: 2025-12-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1342", 브루트포스 알고리즘, 집합과 맵, 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/1342](https://www.acmicpc.net/problem/1342)

---

## 문제
민식이와 준영이는 자기 방에서 문자열을 공부하고 있다. 민식이가 말하길 인접해 있는 모든 문자가 같지 않은 문자열을 행운의 문자열이라고 한다고 한다. 준영이는 문자열 S를 분석하기 시작했다. 준영이는 문자열 S에 나오는 문자를 재배치하면 서로 다른 행운의 문자열이 몇 개 나오는지 궁금해졌다. 만약 원래 문자열 S도 행운의 문자열이라면 그것도 개수에 포함한다.

---

## 입력
첫째 줄에 문자열 S가 주어진다. S의 길이는 최대 10이고, 알파벳 소문자로만 이루어져 있다.

---

## 출력
첫째 줄에 위치를 재배치해서 얻은 서로 다른 행운의 문자열의 개수를 출력한다.

---

## 성능 요약
메모리: 113412 KB, 시간: 1512 ms

---

## 풀이

### 풀이 핵심 로직
문자열 S에서 인접한 문자가 같지 않은 "행운의 문자열"을 생성하기 위해, 우리는 백트래킹 기법을 사용하여 문자열을 재배치합니다. 각 문자에 대해 이전에 사용한 문자와 다를 때만 다음 문자를 선택하고, 선택한 문자의 사용량을 조절하여 중복을 방지합니다. 이를 통해 가능한 모든 조합을 탐색하여 행운의 문자열의 개수를 센다.

### 동작 과정
1. 입력 문자열 S를 리스트로 변환하고 각 문자의 개수를 세어 사전 `dic`에 저장합니다.
   - 예를 들어, 입력이 "aab"일 경우 `dic`은 {'a': 2, 'b': 1}이 됩니다.
   
2. `back` 함수는 현재 선택된 문자의 이전 문자(`before`)와 현재까지 사용한 문자 수(`use`)를 인자로 받아 호출됩니다. 초기값은 `before`는 None, `use`는 0입니다.
   
3. `back` 함수가 호출되면, 현재까지 사용한 문자가 문자열의 길이와 같으면 (`use == l`) 행운의 문자열이 하나 생성된 것으로 카운트를 증가시킵니다.
   
4. 사전 `dic`의 각 문자에 대해, 해당 문자의 사용 가능 여부를 확인하고, 이전 문자와 다르면 문자를 선택하여 재귀적으로 다음 문자를 선택합니다.
   - 예를 들어, 처음에는 'a'를 선택하고 다음에는 'b'를 선택할 수 있지만, 두 번째 'a'는 사용할 수 없습니다. 
   
5. 모든 조합을 탐색하여 종료된 후, 최종적으로 카운트된 행운의 문자열 개수를 출력합니다.

### 시간 복잡도
최악의 경우, 각 문자 조합을 모두 탐색해야 하므로 시간 복잡도는 O(n!)입니다. 여기서 n은 입력 문자열의 길이입니다. 입력 문자열의 길이가 최대 10이므로 이 경우에도 충분히 빠르게 수행됩니다.

---

## 코드
```python
s = list(input().rstrip())
l = len(s)
dic = {}

for i in s:
    dic[i] = dic.get(i, 0) + 1

cnt = 0
def back(dic, before, use):
    global cnt
    if use == l:
        cnt += 1
        return
    
    for k, v in dic.items():
        if v > 0 and k != before:
            dic[k] -= 1
            back(dic, k, use + 1)
            dic[k] += 1

back(dic, None, 0)
print(cnt)

```