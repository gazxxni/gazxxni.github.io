---
layout: post
title: "[백준] 1342번 행운의 문자열 (Python)"
date: 2025-12-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1342", 브루트포스 알고리즘, 집합과 맵, 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/1342](https://www.acmicpc.net/problem/1342)

---

## 문제
민식이와 준영이는 자기 방에서 문자열을 공부하고 있다. 민식이가 말하길 인접해 있는 모든 문자가 같지 않은 문자열을 행운의 문자열이라고 한다고 한다. 준영이는 문자열 S를 분석하기 시작했다. 준영이는 문자열 S에 나오는 문자를 재배치하면 서로 다른 행운의 문자열이 몇 개 나오는지 궁금해졌다. 만약 원래 문자열 S도 행운의 문자열이라면 그것도 개수에 포함한다.

---

## 입력
첫째 줄에 문자열 S가 주어진다. S의 길이는 최대 10이고, 알파벳 소문자로만 이루어져 있다.

---

## 출력
첫째 줄에 위치를 재배치해서 얻은 서로 다른 행운의 문자열의 개수를 출력한다.

---

## 성능 요약
메모리: 113412 KB, 시간: 1512 ms

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 재귀적인 백트래킹을 사용하여 주어진 문자열의 모든 가능한 재배치를 생성하면서 인접한 문자가 같은 경우를 피하는 것이다. 각 문자에 대해 사용 가능한 경우를 추적하고, 사용된 문자와 인접하지 않도록 조절하여 행운의 문자열을 생성한다.

### 동작 과정
1. 입력 문자열 `S`를 받아 리스트 `s`로 변환한 후, 각 문자의 개수를 세어 딕셔너리 `dic`에 저장한다.
2. 재귀 함수 `back()`을 정의하여 문자열의 길이 `l`에 도달할 때까지 문자를 선택하고, 인접한 문자가 같지 않도록 조건을 설정한다.
3. `back()` 함수는 현재 사용된 문자 `before`와 현재 사용된 문자 수 `use`를 매개변수로 받아, 가능한 문자를 선택하고 재귀적으로 호출하여 모든 행운의 문자열을 카운트한다.
4. 만약 `use`가 문자열의 길이와 같아지면, 하나의 행운의 문자열이 생성된 것이므로 카운트를 증가시킨다.
5. 마지막으로, 카운트를 출력한다.

예시 입력: `aabc`
- 초기화 후 `dic`은 `{'a': 2, 'b': 1, 'c': 1}`이 된다.
- 재귀 호출이 시작되며, 첫 문자 선택부터 인접한 문자가 같지 않도록 선택하여 모든 경우를 탐색한다.
- 예를 들어, `abca`, `acab`, `aabc`, `baca` 등과 같은 행운의 문자열이 생성된다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n!)로, 문자열의 길이에 따라 모든 가능한 조합을 탐색하기 때문에 최악의 경우 모든 순열을 생성해야 한다. 주어진 제한(최대 10)의 경우, 이 복잡도는 허용 가능한 범위 내에 있다.

---

## 코드
```python
s = list(input().rstrip())
l = len(s)
dic = {}

for i in s:
    dic[i] = dic.get(i, 0) + 1

cnt = 0
def back(dic, before, use):
    global cnt
    if use == l:
        cnt += 1
        return
    
    for k, v in dic.items():
        if v > 0 and k != before:
            dic[k] -= 1
            back(dic, k, use + 1)
            dic[k] += 1

back(dic, None, 0)
print(cnt)

```