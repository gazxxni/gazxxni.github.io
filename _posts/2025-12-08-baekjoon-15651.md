---
layout: post
title: "[백준] 15651번 N과 M (3) (Python)"
date: 2025-12-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "15651", 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/15651](https://www.acmicpc.net/problem/15651)

---

## 문제
자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.


	1부터 N까지 자연수 중에서 M개를 고른 수열
	같은 수를 여러 번 골라도 된다.

---

## 입력
첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 7)

---

## 출력
한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.

수열은 사전 순으로 증가하는 순서로 출력해야 한다.

---

## 성능 요약
메모리: 149500 KB, 시간: 652 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 백트래킹을 이용해 해결할 수 있습니다. 1부터 N까지의 자연수 중에서 M개를 선택하는 모든 조합을 생성하려고 합니다. 같은 수를 여러 번 선택할 수 있으므로, 각 선택에서 반복적으로 수를 추가하고, M개의 수를 선택한 경우에만 결과를 출력합니다.

### 동작 과정
1. **입력 받기**: 두 개의 자연수 N과 M을 입력받습니다.
2. **재귀 함수 정의**: 수열의 현재 상태를 담고 있는 리스트 `arr`를 사용하여, 현재 길이가 M인 수열이 만들어질 때까지 재귀적으로 숫자를 추가합니다.
3. **수열의 길이 확인**: 수열의 길이가 M에 도달하면, 현재 수열을 출력하고 함수를 종료합니다.
4. **수열 생성**: 1부터 N까지의 수를 반복하여 추가하고, 재귀 호출 후 마지막에 추가한 수를 제거하여 다음 수열 생성을 준비합니다.

예시 입력: `3 2`일 때, 
- 첫 번째 호출에서 `arr`은 비어있고, 숫자 1을 추가한 후 다음 호출로 넘어갑니다.
- 만약 `arr`이 `[1]`일 때, 다시 숫자 1, 2, 3을 추가하여 `[1, 1]`, `[1, 2]`, `[1, 3]`를 생성합니다.
- 같은 방식으로 `[2, 1]`, `[2, 2]`, `[2, 3]`, `[3, 1]`, `[3, 2]`, `[3, 3]`도 생성됩니다.

출력 결과는 다음과 같습니다:
```
1 1
1 2
1 3
2 1
2 2
2 3
3 1
3 2
3 3
```

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(N^M)입니다. 왜냐하면 각 재귀 호출에서 N개의 숫자를 M번 선택할 수 있기 때문입니다. 입력 제한이 작기 때문에 이 시간 복잡도는 문제를 해결하는 데 충분히 효율적입니다.

---

## 코드
```python
n, m = map(int, input().split())

arr = []
def aa():
    if len(arr) == m:
        print(*arr)
        return
    
    for i in range(1, n + 1):
        arr.append(i)
        aa()
        arr.pop()
        
aa()
```