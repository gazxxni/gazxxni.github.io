---
layout: post
title: "[백준] 1145번 적어도 대부분의 배수 (Python)"
date: 2026-01-22
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1145", 브루트포스 알고리즘]
---

## 문제 링크
[https://www.acmicpc.net/problem/1145](https://www.acmicpc.net/problem/1145)

---

## 문제
다섯 개의 자연수가 있다. 이 수의 적어도 대부분의 배수는 위의 수 중 적어도 세 개로 나누어 지는 가장 작은 자연수이다.

서로 다른 다섯 개의 자연수가 주어질 때, 적어도 대부분의 배수를 출력하는 프로그램을 작성하시오.

---

## 입력
첫째 줄에 다섯 개의 자연수가 주어진다. 100보다 작거나 같은 자연수이고, 서로 다른 수이다.

---

## 출력
첫째 줄에 적어도 대부분의 배수를 출력한다.

---

## 성능 요약
메모리: 110576 KB, 시간: 112 ms

---

## 풀이

### 풀이 핵심 로직
문제의 핵심은 주어진 다섯 개의 자연수 중 적어도 세 개로 나누어 떨어지는 최소의 자연수를 찾는 것이다. 이를 위해 브루트포스 방식으로 자연수 `ans`를 1부터 시작하여 증가시키면서, 각 자연수로 나누어 떨어지는지를 체크하여 조건을 만족하는지 확인한다.

### 동작 과정
입력이 주어졌다고 가정해 보자: `3 6 12 15 10`

1. `ans`의 초기값을 4로 설정한다.
2. `while True` 루프를 시작하여, 다음의 과정을 반복한다:
   - `cnt`를 0으로 초기화하여, `ans`가 몇 개의 수로 나누어 떨어지는지 카운트한다.
   - 주어진 수들(3, 6, 12, 15, 10)에 대해 `ans % i == 0`을 체크하며, 나누어 떨어지는 경우 `cnt`를 1씩 증가시킨다.
   - 만약 `cnt`가 3 이상이면, 현재의 `ans`를 출력하고 루프를 종료한다.
   - 그렇지 않으면 `ans`를 1 증가시켜 다음 자연수로 넘어간다.

이 과정을 통해 1씩 증가하는 `ans`의 값을 검사하여, 조건을 만족하는 최소값을 찾게 된다. 예를 들어, `ans`가 30일 때, 3, 6, 12, 15, 10 모두 나누어 떨어지므로 출력된다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n * m)으로, 여기서 n은 자연수의 범위(최악의 경우 100까지), m은 주어진 다섯 개의 수를 의미한다. 따라서 최악의 경우 O(500)으로 간주할 수 있다. 

이 문제는 자연수가 제한적이므로 실제 수행 시간은 매우 짧다.

---

## 코드
```python
arr = list(map(int, input().split()))
ans = 4

while True:
    cnt = 0
    
    for i in arr:
        if ans % i == 0:
            cnt += 1
    
    if cnt >= 3:
        print(ans)
        break
    
    ans += 1
```