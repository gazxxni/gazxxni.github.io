---
layout: post
title: "[백준] 2467번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2467"]
---

## 문제 링크
[https://www.acmicpc.net/problem/2467](https://www.acmicpc.net/problem/2467)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 두 포인터 기법을 사용하여 주어진 배열에서 두 수의 합이 0에 가장 가까운 두 수를 찾는 것이다. 배열을 정렬한 후, 왼쪽 포인터와 오른쪽 포인터를 사용하여 두 수를 선택하고 그 합을 계산하여 0과의 거리를 비교하며 포인터를 조정한다.

### 동작 과정
예를 들어, 입력이 다음과 같다고 하자:
```
5
-2 -1 0 1 2
```
1. 배열을 정렬하면 `arr = [-2, -1, 0, 1, 2]`이다.
2. `left`는 0, `right`는 4로 초기화한다. `closest_sum`은 무한대로, `ans`는 (0, 0)으로 초기화한다.
3. 첫 번째 반복:
   - `total = arr[left] + arr[right] = -2 + 2 = 0`
   - `abs(total) < abs(closest_sum)` 조건을 만족하므로 `closest_sum`을 0으로 설정하고 `ans`를 (-2, 2)로 업데이트한다.
   - `total == 0`이므로 바로 반복을 종료한다.
4. 결과적으로 `ans`가 (-2, 2)이고, 이 두 수를 출력한다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n)이다. 배열을 정렬하는 과정이 O(n log n)이지만, 두 포인터를 사용하는 주 반복문은 O(n)으로 진행되므로 전체 복잡도는 O(n log n)으로 볼 수 있다.

---

## 코드
```python
n = int(input())
arr = list(map(int, input().split()))

left = 0
right = n - 1
closest_sum = float('inf')
ans = (0, 0)

while left < right:
    total = arr[left] + arr[right]

    if abs(total) < abs(closest_sum):
        closest_sum = total
        ans = (arr[left], arr[right])

    if total > 0:
        right -= 1

    elif total < 0:
        left += 1

    else:
        break

print(ans[0], ans[1])

```