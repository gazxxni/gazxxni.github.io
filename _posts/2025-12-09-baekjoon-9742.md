---
layout: post
title: "[백준] 9742번 순열 (Python)"
date: 2025-12-09
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "9742", 브루트포스 알고리즘, 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/9742](https://www.acmicpc.net/problem/9742)

---

## 문제
집합의 순열이란 집합의 서로 다른 원소를 모두 사용해 만들 수 있는 순서이다. 예를 들어, {2,3,5}의 순열은 다음과 같다.


	2 3 5
	2 5 3
	3 2 5
	3 5 2
	5 2 3
	5 3 2


각각의 순열은 숫자로 나타낼 수 있다. 위의 순열은 사전순으로 쓰여져 있으며, 등장하는 순서를 이용해 나타낸다. 즉, 3 5 2는 위치 4에 있고, 5 3 2는 마지막 위치인 6에 있다.

{b,e,i,n}으로 만들 수 있는 순열은 다음과 같다.


	b e i n
	b e n i
	b i e n
	b i n e
	b n e i
	b n i e
	e b i n
	e b n i
	e i b n
	e i n b
	e n b i 
	e n i b
	i b e n
	i b n e
	i e b n
	i e n b
	i n b e
	i n e b
	n b e i
	n b i e
	n e b i
	n e i b
	n i b e
	n i e b


서로 다른 숫자와 문자로 이루어진 집합과 위치가 주어졌을 때, 그 집합의 순열 중 주어진 위치의 순열을 구하는 프로그램을 작성하시오.

---

## 입력
입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있다. 첫 번째 문자열은 서로 다른 숫자와 알파벳으로 이루어져 있으며, 길이는 최대 10이다. 또한, 사전순 순서대로 주어진다. 문자열 다음에는 찾아야 하는 위치가 주어지며, 이 값은 3,628,800보다 작거나 같은 자연수이다.

---

## 출력
각각의 테스트 케이스마다, 입력으로 주어진 위치에 해당하는 순열을 공백없이 출력한다. 만약, 해당하는 순열이 없는 경우에는 "No permutation"을 출력한다.

---

## 성능 요약
메모리: 380072 KB, 시간: 2080 ms

---

## 풀이

### 풀이 핵심 로직
주어진 문자열의 모든 순열을 생성하고, 그 중에서 특정 순서에 해당하는 순열을 찾아 출력하는 문제입니다. 이를 위해 브루트포스 알고리즘을 활용하여 모든 순열을 생성한 후 사전순으로 정렬하여 필요한 위치의 순열을 반환하거나, 해당 위치가 존재하지 않을 경우 "No permutation"을 출력합니다.

### 동작 과정
1. **입력 처리**: 입력으로 주어지는 문자열과 위치를 읽어옵니다. 문자열을 리스트로 변환하여 사용합니다.
   
2. **순열 생성**: 백트래킹 기법을 이용하여 문자열의 모든 순열을 생성합니다. 이때, `visited` 리스트를 사용하여 이미 사용된 문자를 추적합니다.

3. **순열 정렬**: 생성된 순열을 사전순으로 정렬합니다.

4. **위치 확인 및 출력**: 주어진 위치가 전체 순열 개수보다 작거나 같은지 확인하고, 해당 위치의 순열을 출력합니다. 만약 위치가 유효하지 않으면 "No permutation"을 출력합니다.

예시 입력으로 `b e i n 12`가 주어진 경우, 다음과 같은 단계로 진행되며:
- `b`, `e`, `i`, `n`의 모든 순열을 생성합니다.
- 생성된 순열을 정렬하여 `12`번째 순열을 찾아 출력합니다.

### 시간 복잡도
시간 복잡도는 O(n!)입니다. 이는 n개의 요소에 대해 모든 순열을 생성해야 하므로, n!의 시간 복잡도를 가집니다. 각 순열은 O(n)의 시간 소요가 있으며, 전체 순열의 개수가 n!이기 때문에 최종적으로 O(n * n!)이 됩니다. 하지만 n의 최대 길이가 10이므로, 이 연산은 실행 가능 범위 안에 있습니다.

---

## 코드
```python
import sys, math
input = sys.stdin.readline

result = [] 
visited = [] 

def backtrack(arr, path):
    if len(path) == len(arr):
        result.append("".join(path))
        return
    
    for i in range(len(arr)):
        if not visited[i]:
            visited[i] = True
            backtrack(arr, path + [arr[i]])
            visited[i] = False

while True:
    try:
        a, b = input().split()
        b = int(b)
        a = list(a)
        n = len(a)
        total = math.factorial(n)

        if b > total:
            print(f"{''.join(a)} {b} = No permutation")
            continue

        result = []
        visited = [False] * n
        backtrack(a, [])

        result.sort()
        if b <= total // 2:
            ans = result[b-1]
        else:
            ans = result[-(total-b+1)]

        print(f"{''.join(a)} {b} = {ans}")
        
    except:
        break

```