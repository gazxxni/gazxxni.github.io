---
layout: post
title: "[백준] 2579번 (Python)"
date: 2024-09-28
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2579"]
---

## 문제 링크
[https://www.acmicpc.net/problem/2579](https://www.acmicpc.net/problem/2579)

---

## 풀이

### 풀이 핵심 로직
이 문제는 동적 프로그래밍을 사용하여 해결합니다. 각 계단에 도달하는 최대 점수를 계산하기 위해, 마지막 계단에 도달하기 위한 두 가지 경로를 고려합니다: (1) 두 계단을 건너뛰고 바로 이전 두 계단에서 점수를 더하는 방법, (2) 바로 이전 계단에서 점수를 더하는 방법. 이를 통해 최적의 점수를 구합니다.

### 동작 과정
1. **입력 받기**: 먼저 계단의 개수 `n`을 입력받고, 각 계단의 점수를 `stairs` 배열에 저장합니다. `stairs[i]`는 i번째 계단의 점수를 의미합니다.
   
   예시 입력:
   ```
   5
   10
   20
   15
   25
   10
   ```
   이 경우, `n`은 5이고, `stairs` 배열은 `[0, 10, 20, 15, 25, 10]`이 됩니다.

2. **DP 배열 초기화**: `dp` 배열을 초기화하여 각 계단에 도달했을 때의 최대 점수를 저장합니다. 초기값으로 dp[1], dp[2], dp[3]을 설정합니다.
   - `dp[1] = stairs[1]` → `dp[1] = 10`
   - `dp[2] = stairs[1] + stairs[2]` → `dp[2] = 10 + 20 = 30`
   - `dp[3] = max(stairs[1] + stairs[3], stairs[2] + stairs[3])` → `dp[3] = max(10 + 15, 20 + 15) = 35`

3. **점화식 계산**: 4번째 계단부터 n번째 계단까지 반복문을 통해 각각의 최대 점수를 계산합니다.
   - `dp[i] = max(dp[i - 3] + stairs[i - 1] + stairs[i], dp[i - 2] + stairs[i])`
   - 4번째 계단, 5번째 계단에 대해 이 점화식을 적용하여 dp 배열을 업데이트합니다.

   예를 들어, `i=4`일 경우:
   - `dp[4] = max(dp[1] + stairs[3] + stairs[4], dp[2] + stairs[4])`
   - `dp[4] = max(10 + 15 + 25, 30 + 25) = max(50, 55) = 55`

4. **결과 출력**: 마지막 계단에 도달했을 때의 최대 점수인 `dp[n]`을 출력합니다.

최종적으로, `print(dp[n])`을 통해 5번째 계단에 도달하는 최대 점수를 출력합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n)입니다. 각 계단에 대해 한 번씩만 계산하므로, 입력된 계단의 개수에 비례하여 시간이 소요됩니다.

---

## 코드
```python
import sys

n=int(input())

# 계단의 숫자를 초기화. 1층은 1번째 인덱스에 저장.
stairs = [0] * 301
for i in range(1, n + 1):
    stairs[i] = int(input())

# dp 배열을 초기화.
dp = [0] * 301
dp[1] = stairs[1]
dp[2] = stairs[1] + stairs[2]
dp[3] = max(stairs[1] + stairs[3], stairs[2] + stairs[3])

# 점화식을 계산.
for i in range(4, n + 1):
    dp[i] = max(dp[i - 3] + stairs[i - 1] + stairs[i], dp[i - 2] + stairs[i])

print(dp[n])


```