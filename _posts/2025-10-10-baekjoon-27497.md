---
layout: post
title: "[백준] 27497번 알파벳 블록 (Python)"
date: 2025-10-10
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "27497", 자료 구조, 문자열, 스택, 덱]
---

## 문제 링크
[https://www.acmicpc.net/problem/27497](https://www.acmicpc.net/problem/27497)

---

## 문제
스타는 알파벳 블록을 일렬로 조립하여 문자열을 만드는 게임을 만들었다. 각 블록에는 문자 하나가 적혀 있으며 게임에는 각각 다음 기능을 수행하는 세 개의 버튼이 있다.


	문자열 맨 뒤에 블록 추가
	문자열 맨 앞에 블록 추가
	문자열을 구성하는 블록 중 가장 나중에 추가된 블록 제거


게임은 처음에 빈 문자열로 시작하며 빈 문자열일 때 문자열을 구성하는 블록 중 가장 나중에 추가된 블록을 제거하는 버튼을 누를 경우 아무런 동작도 하지 않는다. 버튼을 누른 횟수와 누른 버튼이 순서대로 주어질 때 완성된 문자열을 구하여라.

---

## 입력
첫째 줄에 버튼을 누른 횟수 N$N$이 주어진다. (1≤N≤1000000)$(1 \leq N \leq 1\,000\,000)$ 

둘째 줄부터 N$N$개의 줄에는 버튼을 누른 순서대로 누른 버튼에 대한 정보를 주며 아래와 같은 형식으로 주어진다.


	1 c : 문자열 맨 뒤에 c가 적힌 블록 추가
	2 c : 문자열 맨 앞에 c가 적힌 블록 추가
	3 : 문자열을 구성하는 블록 중 가장 나중에 추가된 블록 제거


c는 알파벳 대문자 또는 소문자로 주어진다.

---

## 출력
완성된 문자열을 출력한다. 완성된 문자열이 빈 문자열인 경우 0을 출력한다.

---

## 성능 요약
메모리: 234232 KB, 시간: 520 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 문자열을 구성하는 블록을 추가하거나 제거하는 작업을 수행하는 게임이다. 각 버튼에 따라 스택과 덱을 활용하여 문자열을 관리하며, 마지막으로 문자열을 출력한다. 스택을 사용하여 추가된 블록의 기록을 유지하고, 덱을 사용하여 블록을 효율적으로 추가 및 제거한다.

### 동작 과정
1. **입력 받기**: N(버튼 누른 횟수)을 입력받고, N번 만큼 버튼 정보를 입력 받는다.
2. **버튼 처리**: 
   - `1 c`: 문자열의 맨 뒤에 블록 c를 추가한다. 이때, 덱에 c를 추가하고, 블록 추가 기록을 남긴다.
   - `2 c`: 문자열의 맨 앞에 블록 c를 추가한다. 덱의 앞에 c를 추가하고, 블록 추가 기록을 남긴다.
   - `3`: 마지막으로 추가된 블록을 제거한다. 블록 추가 기록을 통해 가장 최근에 추가된 블록의 위치를 확인하고, 해당 블록을 덱에서 제거한다.
3. **결과 출력**: 모든 버튼 처리 후, 덱이 비어있으면 0을 출력하고, 그렇지 않으면 덱의 내용을 문자열로 만들어 출력한다.

예시 입력:
```
5
1 A
2 B
1 C
3
3
```
- 1 A: C가 추가됨 → `C`
- 2 B: B가 추가됨 → `B C`
- 1 C: C가 추가됨 → `C B C`
- 3: 가장 나중에 추가된 C 제거 → `B C`
- 3: 가장 나중에 추가된 B 제거 → `C`

최종적으로 `C`가 남음. 출력: `C`

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(N)이다. 각 버튼에 대해 상수 시간 내에 작업을 수행할 수 있으므로, 총 N개의 버튼을 처리하는 데 O(N)의 시간이 소요된다.

---

## 코드
```python
import sys
from collections import deque
input = sys.stdin.readline

n = int(input())

q = deque()
log = []

for _ in range(n):
    a = input().split()
    n = int(a[0])
    
    if n == 1:
        c = a[1]
        q.append(c)
        log.append(1)
        
    elif n == 2:
        c = a[1]
        q.appendleft(c)
        log.append(2)
        
    else:
        if log:
            k = log.pop()
            
            if k == 1:
                q.pop()
            else:
                q.popleft()
    
    
if not q:
    print(0)
else:
    print(*q, sep='')
```