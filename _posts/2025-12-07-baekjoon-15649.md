---
layout: post
title: "[백준] 15649번 N과 M (1) (Python)"
date: 2025-12-07
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "15649", 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/15649](https://www.acmicpc.net/problem/15649)

---

## 문제
자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.


	1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열

---

## 입력
첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)

---

## 출력
한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.

수열은 사전 순으로 증가하는 순서로 출력해야 한다.

---

## 성능 요약
메모리: 113968 KB, 시간: 164 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 백트래킹을 이용하여 1부터 N까지의 자연수 중에서 중복 없이 M개의 수를 선택하여 수열을 만드는 문제입니다. 핵심 아이디어는 재귀를 통해 수열을 구성하고, 수열의 길이가 M에 도달했을 때 이를 출력하는 것입니다. 또한, 선택한 수를 배열에 추가하고, 재귀 호출 후에는 다시 원래 상태로 되돌리는 백트래킹 기법을 사용합니다.

### 동작 과정
1. 입력: `N`과 `M`을 입력받습니다. 예를 들어, `N = 4`, `M = 2`라고 가정합니다.
2. `arr`이라는 빈 리스트를 초기화합니다. 이 리스트는 현재 선택된 수열을 저장합니다.
3. 재귀 함수 `aa()`를 호출하여 수열을 구성합니다.
   - `arr`의 길이가 `M`인 경우, 현재 수열을 출력합니다.
   - `1`부터 `N`까지의 수를 순회하며, 현재 수가 `arr`에 없을 경우(중복 체크), 해당 수를 `arr`에 추가합니다.
   - 재귀적으로 `aa()`를 호출하여 다음 수를 선택합니다.
   - 수를 선택한 후에는 `arr`에서 해당 수를 제거하여 다른 조합을 시도할 수 있도록 합니다.
4. `N = 4`와 `M = 2`인 경우, 출력되는 수열은 다음과 같습니다:
   - 1 2
   - 1 3
   - 1 4
   - 2 1
   - 2 3
   - 2 4
   - 3 1
   - 3 2
   - 3 4
   - 4 1
   - 4 2
   - 4 3

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(N^M)입니다. 이유는 각 단계에서 N개의 선택지를 가지고, 이를 M번 반복하여 수열을 구성하는 방식이기 때문입니다. M이 증가할수록 가능한 조합의 수가 기하급수적으로 증가합니다.

---

## 코드
```python
n, m = map(int, input().split())
arr = []

def aa():
    if len(arr) == m:
        print(*arr)
        return
    
    for i in range(1, n + 1):
        if i not in arr:
            arr.append(i)
            aa()
            arr.pop()
            
aa()
```