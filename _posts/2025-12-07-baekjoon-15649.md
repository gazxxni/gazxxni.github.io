---
layout: post
title: "[백준] 15649번 N과 M (1) (Python)"
date: 2025-12-07
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "15649", 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/15649](https://www.acmicpc.net/problem/15649)

---

## 문제
자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.


	1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열

---

## 입력
첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)

---

## 출력
한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.

수열은 사전 순으로 증가하는 순서로 출력해야 한다.

---

## 성능 요약
메모리: 113968 KB, 시간: 164 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 1부터 N까지의 자연수 중에서 중복 없이 M개를 고르는 모든 조합을 생성하는 문제로, 백트래킹 기법을 사용하여 해결합니다. 재귀 함수를 통해 현재 선택한 수열의 길이가 M이 될 때까지 수를 선택하고, 선택한 수를 수열에 추가하거나 제거하며 모든 가능한 조합을 탐색합니다.

### 동작 과정
예시 입력으로 `N = 4`, `M = 2`를 고려해보겠습니다.

1. 초기 상태에서 `arr`은 빈 배열입니다.
2. 재귀 함수 `aa()`를 호출하여 수열을 생성합니다.
3. 첫 번째 반복에서 `i = 1`을 선택하여 `arr`에 추가합니다. (`arr = [1]`)
4. 다시 `aa()`를 호출하여 다음 수를 선택합니다.
   - 두 번째 반복에서 `i = 1`은 이미 선택되었으므로 건너뛰고, `i = 2`를 선택하여 `arr`에 추가합니다. (`arr = [1, 2]`)
   - 현재 `arr`의 길이가 M(2)이므로, `1 2`를 출력하고 마지막 수를 제거합니다.
5. 이전 단계로 돌아가 `arr`에서 `2`를 제거한 후, 다음 수인 `i = 3`을 선택합니다. (`arr = [1, 3]`)
   - M에 도달하지 않았으므로, `i = 1`, `2`는 건너뛰고 `3`을 선택하여 `arr`에 추가합니다. (`arr = [1, 3]`)
   - M에 도달해서 `1 3`을 출력합니다.
6. 이 과정을 반복하여 가능한 모든 조합 `1 4`, `2 3`, `2 4`, `3 4`를 출력하게 됩니다.

최종적으로 출력된 결과는 다음과 같습니다:
```
1 2
1 3
1 4
2 3
2 4
3 4
```

### 시간 복잡도
시간 복잡도는 O(N!)입니다. 각 재귀 호출에서 N 개의 수 중에서 M 개를 선택하는 조합을 생성하기 때문에 최악의 경우 모든 조합을 탐색해야 하며, 이는 팩토리얼 시간 복잡도를 가집니다. 그러나 N과 M의 최대 값이 8로 제한되므로 실제 실행 시간은 충분히 빠릅니다.

---

## 코드
```python
n, m = map(int, input().split())
arr = []

def aa():
    if len(arr) == m:
        print(*arr)
        return
    
    for i in range(1, n + 1):
        if i not in arr:
            arr.append(i)
            aa()
            arr.pop()
            
aa()
```