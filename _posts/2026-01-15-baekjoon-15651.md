---
layout: post
title: "[백준] 15651번 N과 M (3) (Python)"
date: 2026-01-15
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "15651", 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/15651](https://www.acmicpc.net/problem/15651)

---

## 문제
자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.


	1부터 N까지 자연수 중에서 M개를 고른 수열
	같은 수를 여러 번 골라도 된다.

---

## 입력
첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 7)

---

## 출력
한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.

수열은 사전 순으로 증가하는 순서로 출력해야 한다.

---

## 성능 요약
메모리: 149500 KB, 시간: 652 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 자연수 N과 M이 주어졌을 때, 1부터 N까지의 자연수 중에서 M개의 수를 선택하여 수열을 만드는 문제입니다. 이때, 같은 수를 여러 번 선택할 수 있으며, 수열은 사전 순으로 출력해야 합니다. 여기서는 백트래킹 기법을 사용하여 가능한 모든 수열을 탐색하고, 조건에 맞는 수열을 출력합니다.

### 동작 과정
1. 입력으로 N과 M을 받아옵니다. 예를 들어, N=3, M=2인 경우를 생각해 보겠습니다.
2. 빈 리스트 `arr`를 초기화합니다. 이 리스트는 현재 수열을 저장하는 데 사용됩니다.
3. 재귀 함수 `aa()`를 정의합니다. 이 함수는 현재 수열의 길이가 M과 같을 때, 수열을 출력하고 종료합니다.
4. 그렇지 않은 경우, 1부터 N까지의 숫자를 반복하여:
   - 현재 숫자를 `arr`에 추가합니다.
   - `aa()`를 재귀 호출하여 다음 숫자를 추가합니다.
   - 마지막으로, 추가한 숫자를 다시 제거하여 다음 숫자를 추가할 수 있도록 합니다.
5. 이 과정을 반복하여 모든 가능한 조합을 탐색합니다. 예시 입력이 N=3, M=2일 때, 출력은 다음과 같습니다:
   ```
   1 1
   1 2
   1 3
   2 1
   2 2
   2 3
   3 1
   3 2
   3 3
   ```

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(N^M)입니다. 이는 M개의 수를 선택하기 위해 N개의 숫자에서 선택할 수 있는 경우의 수를 모두 탐색하기 때문입니다. M의 최대값이 7이고 N의 최대값이 7이므로, 최악의 경우에는 7^7 = 823543개의 경우의 수를 탐색하게 됩니다.

---

## 코드
```python
n, m = map(int, input().split())

arr = []
def aa():
    if len(arr) == m:
        print(*arr)
        return
    
    for i in range(1, n + 1):
        arr.append(i)
        aa()
        arr.pop()
        
aa()
```