---
layout: post
title: "[백준] 9375번 (Python)"
date: 2024-09-28
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "9375"]
---

## 문제 링크
[https://www.acmicpc.net/problem/9375](https://www.acmicpc.net/problem/9375)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 각 의상의 종류별로 착용할 수 있는 조합의 수를 계산하는 것입니다. 각 의상 종류에서 선택할 수 있는 의상 수는 그 종류의 의상 개수 + 1 (안 입는 경우)을 고려하여 계산하며, 전체 조합 수에서 1을 빼는 것은 아무 의상도 착용하지 않는 경우를 제외하기 위함입니다.

### 동작 과정
예를 들어, 입력이 다음과 같다고 가정합니다.
```
2
3
hat headgear
sunglasses eyewear
turban headgear
2
jacket outerwear
shirt top
```
1. 첫 번째 테스트 케이스:
   - `n = 3`으로 3개의 의상이 입력됩니다.
   - **의상 분류**:
     - headgear: 2 (hat, turban)
     - eyewear: 1 (sunglasses)
   - 조합 수 계산:
     - headgear에서 선택할 수 있는 경우: 2 + 1 = 3 (hat, turban, 안 입음)
     - eyewear에서 선택할 수 있는 경우: 1 + 1 = 2 (sunglasses, 안 입음)
     - 전체 조합 수: 3 * 2 = 6
   - 아무것도 입지 않는 경우를 제외하여 최종 결과: 6 - 1 = 5

2. 두 번째 테스트 케이스:
   - `n = 2`로 2개의 의상이 입력됩니다.
   - **의상 분류**:
     - outerwear: 1 (jacket)
     - top: 1 (shirt)
   - 조합 수 계산:
     - outerwear에서 선택할 수 있는 경우: 1 + 1 = 2 (jacket, 안 입음)
     - top에서 선택할 수 있는 경우: 1 + 1 = 2 (shirt, 안 입음)
     - 전체 조합 수: 2 * 2 = 4
   - 아무것도 입지 않는 경우를 제외하여 최종 결과: 4 - 1 = 3

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n)입니다. 여기서 n은 각 테스트 케이스에서 입력되는 의상 수입니다. 각 의상을 한 번씩 읽고, 딕셔너리에 저장하고, 최종 조합 수를 계산하는 데 O(n)의 시간이 걸리기 때문입니다.

---

## 코드
```python
import sys

t=int(input())

for _ in range(t):
    wears={}
    n=int(input())

    for _ in range(n):
        # 의상 이름과 타입을 입력받음
        name, type=sys.stdin.readline().strip().split()

        # 타입이 딕셔너리에 없으면 추가하고 1로 초기화
        if not type in wears:
            wears[type]=1
        else:
            # 타입이 이미 존재하면 개수를 증가시킴
            wears[type]+=1

    cnt=1

    for i in wears:
        # 각 타입의 의상 개수 + 1(안 입는 경우) 만큼 조합 수를 증가시킴
        cnt*=(wears[i]+1)

    print(cnt-1)

    
```