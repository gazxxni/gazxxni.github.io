---
layout: post
title: "[백준] 10844번 쉬운 계단 수 (Python)"
date: 2026-01-15
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "10844", 다이나믹 프로그래밍]
---

## 문제 링크
[https://www.acmicpc.net/problem/10844](https://www.acmicpc.net/problem/10844)

---

## 문제
45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.

---

## 입력
첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

---

## 출력
첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

---

## 성능 요약
메모리: 108384 KB, 시간: 84 ms

---

## 풀이

### 풀이 핵심 로직
계단 수는 인접한 자리의 차이가 1인 수로 정의됩니다. 따라서, 길이 N의 계단 수를 만들기 위해서는 길이 N-1의 계단 수에서 마지막 자리 숫자에 1을 더하거나 빼는 방식으로 생성할 수 있습니다. 이를 다이나믹 프로그래밍을 사용하여 길이 N의 계단 수의 개수를 계산합니다.

### 동작 과정
1. **초기화**: N이 1일 때, 가능한 계단 수는 1~9까지의 숫자이므로 dp[1][2:11]에 1을 할당하여 초기화합니다.
2. **점화식 구성**: 길이 i의 계단 수 dp[i][j]는 길이 i-1의 계단 수에서 j-1과 j+1에서 올 수 있습니다. 따라서,
   - dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]로 정의합니다.
3. **계산 예시**: N이 2일 경우, 
   - dp[2][1] = dp[1][0] + dp[1][2] = 0 + 1 = 1
   - dp[2][2] = dp[1][1] + dp[1][3] = 0 + 1 = 1
   - 이 과정을 N까지 반복합니다.
4. **결과 도출**: 마지막으로 dp[n]의 모든 값을 합산하여 1,000,000,000으로 나눈 나머지를 출력합니다.

예를 들어, N이 3일 경우,
- dp[3][1]은 dp[2][0] + dp[2][2] = 0 + 1 = 1
- dp[3][2]는 dp[2][1] + dp[2][3] = 1 + 1 = 2
- dp[3][3]는 dp[2][2] + dp[2][4] = 1 + 1 = 2
- ...
최종적으로 dp[3]의 모든 값을 합산하여 결과를 얻습니다.

### 시간 복잡도
O(N) - N에 대해 두 개의 중첩 루프가 있지만, 두 번째 루프는 상수 범위(1~10)로 제한되므로 결국 선형 시간 복잡도를 갖습니다.

---

## 코드
```python
n = int(input())

dp = [[0] * 12 for _ in range(n + 1)]
dp[1][2:11] = [1] * 9

for i in range(2, n + 1):
    for j in range(1, 11):
        dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]
        
ans = sum(dp[n])
print(ans % 1000000000)
```