---
layout: post
title: "[백준] 1967번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1967"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1967](https://www.acmicpc.net/problem/1967)

---

## 풀이

### 풀이 핵심 로직
이 문제는 트리 구조에서 가장 긴 경로(트리의 지름)를 찾는 문제이다. 이를 위해 두 번의 깊이 우선 탐색(DFS)을 사용한다. 첫 번째 DFS는 임의의 노드에서 가장 먼 노드를 찾고, 두 번째 DFS는 그 노드에서 다시 가장 먼 노드를 찾아서 그 거리를 반환함으로써 트리의 지름을 계산한다.

### 동작 과정
1. **입력 처리**: 
   - 첫 줄에서 노드의 개수 `n`을 입력받는다.
   - 그 다음 줄부터는 `n-1`개의 간선 정보를 입력받아 그래프를 인접 리스트 형태로 구성한다.

2. **첫 번째 DFS**:
   - 시작 노드로 1번 노드를 선택하여 DFS를 수행한다.
   - DFS를 통해 1번 노드에서 가장 먼 노드를 찾는다. 이 과정에서 현재 노드와의 거리(`dist`)를 계속 업데이트하며, 가장 먼 노드를 `max_node`에 저장한다.

3. **두 번째 DFS**:
   - 첫 번째 DFS에서 찾은 `max_node`를 시작 노드로 설정하고, 다시 DFS를 수행하여 이 노드에서 가장 먼 노드까지의 거리를 계산한다.
   - 이 두 번째 DFS의 결과가 트리의 지름이 된다.

4. **결과 출력**: 
   - 최종적으로 구한 지름(`answer`)을 출력한다.

### 예시 입력으로 단계별 설명
- 예시 입력:
    ```
    5
    1 2 3
    1 3 2
    2 4 5
    2 5 4
    ```
- 입력 처리 후 그래프 구조:
    ```
    graph = [
      [],
      [(2, 3), (3, 2)],
      [(1, 3), (4, 5), (5, 4)],
      [(1, 2)],
      [(2, 5)],
      [(2, 4)]
    ]
    ```

1. **첫 번째 DFS (1번 노드에서 시작)**:
   - 1 → 2 (거리 3) → 4 (거리 8) → 5 (거리 7) → 3 (거리 5)
   - `max_node`는 4 (거리 8로 업데이트됨)

2. **두 번째 DFS (4번 노드에서 시작)**:
   - 4 → 2 (거리 5) → 1 (거리 8) → 3 (거리 10) → 5 (거리 9)
   - `max_node`는 3 (거리 10으로 업데이트됨)

3. **결과**: 
   - 두 번째 DFS의 결과로 지름이 10임을 확인하고 출력.

### 시간 복잡도
O(n) - 각 DFS는 노드를 한 번씩 방문하므로, 전체 시간 복잡도는 노드의 수인 n에 비례한다.

---

## 코드
```python
n = int(input())
graph = [[] for _ in range(n+1)]

for i in range(n-1):
    a, b, c = map(int, input().split())
    graph[a].append((b, c))
    graph[b].append((a, c))

def dfs(start):
    stack = [(start, 0)]
    visited = [False] * (n+1)
    visited[start] = True
    max_node, max_dist = start, 0

    while stack:
        node, dist = stack.pop()
        if dist > max_dist:
            max_node, max_dist = node, dist

        for next_node, next_dist in graph[node]:
            if not visited[next_node]:
                visited[next_node] = True
                stack.append((next_node, dist + next_dist))

    return max_node, max_dist

node1, _ = dfs(1)  # 1번 노드와 가장 멀리 떨어진 노드 찾기
_, answer = dfs(node1)  # 위에서 찾은 노드와 가장 멀리 떨어진 노드 찾기
print(answer)
```