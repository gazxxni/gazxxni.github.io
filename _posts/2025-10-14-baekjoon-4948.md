---
layout: post
title: "[백준] 4948번 (Python)"
date: 2025-10-14
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "4948"]
---

## 문제 링크
[https://www.acmicpc.net/problem/4948](https://www.acmicpc.net/problem/4948)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 정수 \( n \)에 대해 \( n \)보다 크고 \( 2n \) 이하의 소수를 세는 문제입니다. 에라토스테네스의 체 알고리즘을 사용하여 최대 \( 2n \)까지의 소수를 미리 계산하고, 주어진 \( n \)에 대한 소수의 개수를 빠르게 카운트하여 출력합니다.

### 동작 과정
1. **입력 처리**: 사용자가 정수를 입력합니다. 입력된 정수가 0이면 프로그램을 종료합니다.
2. **소수 판별**: 에라토스테네스의 체를 사용하여 0부터 300,000까지의 소수를 미리 계산합니다. `prime_numbers` 함수에서 소수 배열을 생성합니다.
   - `arr` 배열은 각 인덱스가 소수인지 여부를 나타내며, 처음에는 모두 소수로 가정합니다.
   - 2부터 \( \sqrt{n} \)까지의 수에 대해, 해당 수가 소수일 경우 그 배수들을 소수가 아니라고 표시합니다.
3. **소수 카운트**: 주어진 \( n \)에 대해 \( n + 1 \)부터 \( 2n \)까지의 숫자가 소수인지 확인하고, 소수인 경우 카운트를 증가시킵니다.
4. **결과 출력**: 카운트된 소수의 개수를 출력합니다.

예시 입력:
```
1
10
0
```
- 첫 번째 입력 1에 대해, 소수는 2, 3, 5, 7 (4개).
- 두 번째 입력 10에 대해, 소수는 11, 13, 17, 19, 23, 29, 31 (7개).
- 0이 입력되면 프로그램 종료.

### 시간 복잡도
- 에라토스테네스의 체 알고리즘의 시간 복잡도는 \( O(n \log \log n) \)입니다.
- 각 \( n \) 입력에 대해 \( O(n) \)의 시간 복잡도로 소수를 세므로, 전체 시간 복잡도는 \( O(n \log \log n) \) + \( O(n) \)으로 볼 수 있습니다. 
- 따라서 이 알고리즘의 최종 시간 복잡도는 \( O(n \log \log n) \)입니다.

---

## 코드
```python
def prime_numbers(n):
    arr = [True] * (n + 1) 
    arr[0] = arr[1] = False

    for i in range(2, int(n ** 0.5) + 1):
        if arr[i]:
            for j in range(i * i, n + 1, i):
                arr[j] = False
    
    return arr

a = prime_numbers(300000)

while True:
    n = int(input())
    
    if n == 0:
        exit()
        
    cnt = 0
    for i in range(n + 1, 2 * n + 1):
        if a[i] == True:
            cnt += 1
    
    print(cnt)
```