---
layout: post
title: "[백준] 26215번 눈 치우기 (Python)"
date: 2025-12-07
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, 26215, 구현, 그리디 알고리즘, 정렬, 시뮬레이션]
---

## 문제 링크
[https://www.acmicpc.net/problem/26215](https://www.acmicpc.net/problem/26215)

---

## 문제
지난 밤 겨울 숲에는 눈이 많이 내렸다. 당신은 숲의 주민들을 위해 눈이 오지 않는 동안 모든 집 앞의 눈을 치우고자 한다.

당신은 1분에 한 번씩 두 집을 선택해서 두 집 앞의 눈을 각각 1만큼 치우거나, 한 집을 선택해서 그 집 앞의 눈을 1만큼 치울 수 있다.

모든 집 앞의 눈을 전부 치울 때까지 걸리는 최소 시간은 얼마일까?

---

## 입력
첫 줄에 집의 수를 의미하는 정수 N$N$ (1≤N≤100$1 \leq N \leq 100$)이 주어진다.

다음 줄에는 각각의 집 앞에 쌓여 있는 눈의 양을 나타내는 정수 ai$a_{i}$ (1≤ai≤2000$1 \leq a_{i} \leq 2000$)이 주어진다.

---

## 출력
모든 집 앞의 눈을 치우는 데 최소 몇 분이 걸리는지를 출력한다. 24시간(1440분)이 넘게 걸릴 경우 -1을 출력한다.

---

## 성능 요약
메모리: 108384 KB, 시간: 88 ms

---

## 풀이

### 풀이 핵심 로직
눈을 치우는 데 필요한 시간을 최소화하기 위해, 가장 많은 눈이 쌓인 두 집을 선택하여 동시에 눈을 치우는 전략을 사용한다. 이 과정을 반복하여 모든 집 앞의 눈을 치우는 데 걸리는 시간을 계산한다. 만약 시간이 24시간(1440분)을 초과하면 -1을 출력한다.

### 동작 과정
1. **입력 예시**: 
   ```
   5
   5 3 7 9 2
   ```
   - 집의 수: 5
   - 각 집 앞의 눈의 양: [5, 3, 7, 9, 2]

2. **초기 상태**: 
   - 눈의 양: [5, 3, 7, 9, 2]
   - 최대 두 집을 선택하여 눈을 치우는 과정을 시작.

3. **1분 경과**:
   - 눈의 양 정렬: [9, 7, 5, 3, 2]
   - 9와 7 집을 선택하여 각각 1만큼 치운다.
   - 변경 후 눈의 양: [8, 6, 5, 3, 2]
   - 총 시간: 1분

4. **2분 경과**:
   - 눈의 양 정렬: [8, 6, 5, 3, 2]
   - 8과 6 집을 선택하여 각각 1만큼 치운다.
   - 변경 후 눈의 양: [7, 5, 5, 3, 2]
   - 총 시간: 2분

5. **반복**:
   - 이와 같은 방식으로 계속해서 두 집을 선택하고 눈을 치우는 과정을 반복한다.

6. **종료 조건**:
   - 모든 집의 눈 쌓인 양이 0이 될 때까지 반복하며, 그때까지 소요된 분을 세어 최종 결과를 계산한다.

7. **최종 결과**:
   - 만약 걸린 시간이 1440분을 초과하면 -1을 출력, 그렇지 않으면 소요된 시간을 출력한다.

### 시간 복잡도
- 정렬을 반복하므로 매 반복마다 O(N log N)의 시간이 소요된다. 최악의 경우 모든 연산을 하게 되면 O(N^2 log N)의 시간 복잡도를 가진다. 그러나 N의 최대값이 100이므로 실질적으로는 충분히 빠르게 수행된다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
arr = list(map(int, input().split()))

cnt = 0

while True:
    if len(arr) == 1:
        break
    
    arr.sort(reverse=True)
    arr[0] -= arr[1]
    cnt += arr[1]
    arr.pop(1)
    
cnt += arr[0]
if cnt > 1440:
    print(-1)
else:
    print(cnt)
```