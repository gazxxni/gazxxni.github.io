---
layout: post
title: "[백준] 1865번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1865"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1865](https://www.acmicpc.net/problem/1865)

---

## 풀이

### 풀이 핵심 로직
이 문제는 벨만-포드 알고리즘을 활용하여 음의 사이클을 탐지하는 것입니다. 주어진 그래프는 양방향 도로와 한 방향의 배달 시간이 주어지며, 배달 시간이 음수인 경우를 고려하여 음의 사이클이 존재하는지를 판단합니다. 만약 음의 사이클이 존재한다면, 무한히 배달이 가능한 상황이 되므로 "YES"를 출력하고, 그렇지 않다면 "NO"를 출력합니다.

### 동작 과정
1. **입력 처리**: 먼저 테스트 케이스 수를 입력받고, 각 테스트 케이스에 대해 도시 수(n), 도로 수(m), 배달 정보 수(w)를 받아옵니다.
2. **간선 리스트 생성**: 도로 정보를 이용해 간선을 양방향으로 추가합니다. 즉, (s, e, t)와 (e, s, t)를 모두 추가합니다. 이후 배달 정보에 대해서는 (s, e, -t) 형태로 간선을 추가하여 배달 비용을 음수로 설정합니다.
3. **벨만-포드 알고리즘 실행**: 초기 거리 배열 `dist`를 0으로 설정하고, n번의 반복을 통해 모든 간선을 검사합니다. 만약 어떤 간선(u, v, w)에 대해 `dist[v] > dist[u] + w`가 성립하면, `dist[v]`를 업데이트합니다. n-1번째 반복에서 추가적인 업데이트가 이루어지면 음의 사이클이 존재한다고 판단합니다.
4. **결과 출력**: 각 테스트 케이스에 대해 음의 사이클이 존재하는지 여부에 따라 "YES" 또는 "NO"를 출력합니다.

예시 입력:
```
1
3 3 2
1 2 4
2 3 2
1 3 3
1 2 -5
```
- 첫 번째 줄은 테스트 케이스 수, 두 번째 줄은 도시 수 3, 도로 수 3, 배달 정보 수 2를 나타냅니다.
- 도로 정보 (1, 2, 4), (2, 3, 2), (1, 3, 3)으로 간선이 추가되고, 배달 정보 (1, 2, -5)가 추가됩니다.
- 벨만-포드 알고리즘을 실행하여 음의 사이클을 찾고, 결과를 출력합니다.

### 시간 복잡도
벨만-포드 알고리즘의 시간 복잡도는 O(V * E)입니다. 여기서 V는 정점의 수(n), E는 간선의 수(m + w)입니다. 따라서 이 문제의 시간 복잡도는 O(n * (m + w))입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

def bellman_ford(n, edges):
    dist = [0] * (n + 1) 

    for i in range(n):
        for u, v, w in edges:
            if dist[v] > dist[u] + w:
                dist[v] = dist[u] + w
                if i == n - 1: 
                    return True
    return False

tc = int(input())
for _ in range(tc):
    n, m, w = map(int, input().split())
    edges = []

    for _ in range(m):
        s, e, t = map(int, input().split())
        edges.append((s, e, t))
        edges.append((e, s, t))

    for _ in range(w):
        s, e, t = map(int, input().split())
        edges.append((s, e, -t))

    ans = bellman_ford(n, edges)
    print("YES" if ans else "NO")

```