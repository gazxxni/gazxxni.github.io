---
layout: post
title: "[백준] 12851번 (Python)"
date: 2025-02-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "12851"]
---

## 문제 링크
[https://www.acmicpc.net/problem/12851](https://www.acmicpc.net/problem/12851)

---

## 풀이

### 풀이 핵심 로직
이 문제는 BFS(너비 우선 탐색)를 사용하여 주어진 위치에서 목표 위치까지의 최단 경로를 찾고, 그 경로에 도달할 수 있는 방법의 수를 카운트하는 방식으로 해결됩니다. BFS는 모든 노드를 동일한 레벨에서 방문하므로 최단 경로를 보장하며, 각 노드에 도달하는 방법의 수를 카운트하기 위해 추가적인 변수를 사용합니다.

### 동작 과정
예를 들어, `n=5`와 `k=17`인 경우를 살펴보겠습니다.

1. 시작점 `n=5`에서 BFS를 시작합니다. `arr` 배열은 각 위치에 도달하는 최소 시간을 저장하고, 초기값은 -1로 설정됩니다.
2. `5`에서 탐색을 시작하며, `5`의 이웃인 `4`, `6`, `10`을 큐에 추가합니다. 이때 `arr[5] = 0`으로 설정합니다.
3. 다음으로 `4`를 방문하면 `3`, `5`, `8`을 큐에 추가하고, `arr[4]`를 `1`로 설정합니다.
4. 이 과정을 반복하여 `k=17`에 도달할 때까지 진행합니다.
5. `17`에 도달할 때마다 `cnt`를 증가시키며, `arr[17]`에 도달하는 최소 시간을 기록합니다.
6. BFS가 종료되면 `arr[17]`와 `cnt`를 출력합니다.

이러한 방식으로 목표 위치까지 최단 경로를 탐색하고, 그 경로에 도달하는 방법의 수를 계산합니다.

### 시간 복잡도
BFS의 시간 복잡도는 O(V + E)입니다. 여기서 V는 노드의 수, E는 간선의 수입니다. 이 문제에서는 V가 100,001로 제한되어 있으므로, 전체 시간 복잡도는 O(n), 즉 O(100,001)으로 볼 수 있습니다. 따라서 시간 복잡도는 O(1)로 간주할 수 있습니다.

---

## 코드
```python
import sys
from collections import deque

n, k = map(int, input().split())
arr = [-1] * 100001

def bfs(n, k):
    q = deque([n])
    arr[n] = 0
    cnt = 0

    while q:
        x = q.popleft()

        if x == k:
            cnt += 1  # 만날때마다 cnt 증가

        for i in (x-1, x+1, x*2):
            if 0 <= i < 100001:
                if arr[i] == -1 or arr[i] >= arr[x] + 1:
                    q.append(i)
                    arr[i] = arr[x] + 1

    return arr[k], cnt

a, b = bfs(n, k)
print(a)
print(b)

```