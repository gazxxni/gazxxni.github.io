---
layout: post
title: "[백준] 15654번 (Python)"
date: 2025-02-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "15654"]
---

## 문제 링크
[https://www.acmicpc.net/problem/15654](https://www.acmicpc.net/problem/15654)

---

## 풀이

### 풀이 핵심 로직
이 문제는 중복을 허용하지 않는 조합을 구하는 문제로, DFS(깊이 우선 탐색) 기법을 사용하여 원소를 선택합니다. 선택한 원소의 개수가 m에 도달하면 현재의 선택 결과를 출력하고, 이를 위해 배열을 정렬하여 중복 선택을 방지합니다.

### 동작 과정
1. **입력 처리**: `n`과 `m`의 값을 입력받고, `arr` 배열을 입력받은 후 정렬합니다.
   - 예시 입력: 
     ```
     4 2
     9 7 9 1
     ```
   - 이 경우, `arr`은 `[1, 7, 9, 9]`가 됩니다.

2. **DFS 호출**: `dfs(0)`을 통해 탐색을 시작합니다. 여기서 `0`은 현재 선택한 원소의 개수를 나타냅니다.

3. **조합 생성**:
   - 첫 번째 호출에서 `a`는 `0`입니다. 배열의 각 원소를 순회하며 선택합니다.
   - `1`을 선택하고 `dfs(1)` 호출:
     - 두 번째 호출에서 `a`는 `1`입니다. 다시 배열 순회:
       - `7` 선택 후 `dfs(2)` 호출:
         - `a`가 `2`에 도달하므로 `1 7` 출력.
       - `9` 선택 후 `dfs(2)` 호출:
         - `a`가 `2`에 도달하므로 `1 9` 출력.
     - `9`는 이미 선택된 숫자이므로 건너뜁니다.
   - 다음으로 `7`을 선택하고 `dfs(1)` 호출:
     - `9` 선택 후 `dfs(2)` 호출:
       - `a`가 `2`에 도달하므로 `7 9` 출력.
   - 마지막으로 `9`를 선택하고 `dfs(1)` 호출:
     - 이 경우는 중복된 선택이므로 건너뜁니다.

4. **결과 출력**: 모든 가능한 조합을 출력합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 \(O(m \cdot n^m)\)입니다. 
- 조합을 생성하기 위해 m개의 원소를 선택하는 과정을 반복하며, 각 선택마다 n개의 원소를 탐색하기 때문입니다. 
- 여기서 n은 주어진 숫자의 개수, m은 선택할 숫자의 개수입니다.

---

## 코드
```python
import sys

n, m = map(int, input().split())
arr = list(map(int, input().split()))
ans = []
arr.sort()

def dfs(a):

    if a == m:  # 선택한 원소의 개수가 m개면 종료료
        print(' '.join(map(str, ans)))
        return

    for i in range(n):
        if arr[i] in ans:  # 중복 방지: 이미 선택된 숫자는 건너뛰기
            continue

        ans.append(arr[i])
        dfs(a + 1)
        ans.pop()

dfs(0)

```