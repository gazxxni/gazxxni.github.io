---
layout: post
title: "[백준] 1920번 (Python)"
date: 2024-06-24
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1920"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1920](https://www.acmicpc.net/problem/1920)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 두 리스트에서 두 번째 리스트의 각 원소가 첫 번째 리스트에 존재하는지를 확인하는 문제입니다. 이를 위해 첫 번째 리스트를 정렬한 후, 이진 탐색을 사용하여 각 원소의 존재 여부를 효율적으로 판단합니다.

### 동작 과정
1. 입력을 통해 정수 `n`과 리스트 `a`를 읽어옵니다. 리스트 `a`는 정렬됩니다.
2. 정수 `m`과 리스트 `b`를 읽어옵니다. 리스트 `b`의 각 원소에 대해 다음 과정을 수행합니다.
3. 리스트 `b`의 원소 `i`에 대해 이진 탐색을 시작합니다.
   - 초기값으로 `x`는 0, `y`는 `n-1`로 설정합니다.
   - `x`가 `y`보다 작거나 같은 동안 반복합니다.
     - 중간 인덱스 `mid`를 계산하고, `a[mid]`와 `i`를 비교합니다.
     - 만약 `a[mid]`가 `i`와 같다면 `isExist`를 `True`로 설정하고 `1`을 출력한 뒤 반복을 종료합니다.
     - 만약 `a[mid]`가 `i`보다 작으면, 탐색 범위를 오른쪽으로 이동 (`x = mid + 1`).
     - 반대로 `a[mid]`가 `i`보다 크면, 탐색 범위를 왼쪽으로 이동 (`y = mid - 1`).
4. 만약 `isExist`가 여전히 `False`라면 `0`을 출력합니다.

예시 입력:
```
5
4 1 5 2 3
5
1 3 7 9 5
```
- 리스트 `a`는 `[1, 2, 3, 4, 5]`로 정렬됩니다.
- 리스트 `b`의 원소 각각에 대해 이진 탐색이 수행됩니다:
  - `1`은 존재하므로 `1` 출력.
  - `3`도 존재하므로 `1` 출력.
  - `7`은 존재하지 않으므로 `0` 출력.
  - `9`도 존재하지 않으므로 `0` 출력.
  - `5`는 존재하므로 `1` 출력.

출력 결과:
```
1
1
0
0
1
```

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n log n)입니다. 여기서 `n`은 리스트 `a`의 길이입니다. 리스트를 정렬하는 데 O(n log n)이 걸리고, 각 원소에 대해 이진 탐색을 O(log n)으로 수행하므로 전체적으로 O(m log n)입니다. 따라서, 이 프로그램의 최종 시간 복잡도는 O(n log n + m log n)입니다.

---

## 코드
```python
import sys

n=int(input())
a=list(map(int, input().split()))
m=int(input())
b=list(map(int,input().split()))
a.sort()

for i in b:
    x,y=0,n-1
    isExist=False

    while x<=y:
        mid=(x+y)//2
        if i==a[mid]:
            isExist=True
            print(1)
            break
        elif i>a[mid]:
            x=mid+1
        else:
            y=mid-1
    if not isExist:
        print(0)

```