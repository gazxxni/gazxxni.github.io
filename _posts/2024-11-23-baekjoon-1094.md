---
layout: post
title: "[백준] 1094번 (Python)"
date: 2024-11-23
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1094"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1094](https://www.acmicpc.net/problem/1094)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 수 `x`를 64, 32, 16, 8, 4, 2, 1의 조합으로 나타내는 최소 개수를 구하는 것입니다. 이를 위해 배열 `arr`에 가능한 모든 조합의 크기를 내림차순으로 저장하고, 가장 큰 수부터 차례로 빼면서 카운트를 증가시킵니다. 최종적으로 카운트된 값이 최소 필요한 막대기의 개수가 됩니다.

### 동작 과정
예를 들어, 입력값이 `58`일 경우를 살펴보겠습니다.

1. `x`는 58이고, `arr`의 첫 번째 요소인 64는 58보다 크므로 무시합니다.
2. `arr`의 두 번째 요소인 32는 58보다 작거나 같으므로, `cnt`를 1 증가시켜 1로 설정하고, `x`에서 32를 빼서 `x`는 26이 됩니다.
3. `arr`의 세 번째 요소인 16은 26보다 작거나 같으므로, `cnt`를 2로 증가시키고, `x`는 10이 됩니다.
4. `arr`의 네 번째 요소인 8은 10보다 작거나 같으므로, `cnt`를 3으로 증가시키고, `x`는 2가 됩니다.
5. `arr`의 다섯 번째 요소인 4는 2보다 크므로 무시합니다.
6. `arr`의 여섯 번째 요소인 2는 2와 같으므로, `cnt`를 4로 증가시키고, `x`는 0이 됩니다.
7. `x`가 0이 되었으므로 반복문을 종료합니다.

최종적으로 `cnt`는 4가 되어, 58을 표현하기 위해 필요한 막대기의 개수는 4개입니다.

### 시간 복잡도
이 알고리즘은 배열 `arr`의 길이가 고정되어 있으므로, 시간 복잡도는 O(1)입니다.

---

## 코드
```python
import sys

x=int(input())

arr = [64, 32, 16, 8, 4, 2, 1]
cnt = 0

for i in range(len(arr)):
    if x >= arr[i]:
        cnt += 1
        x -= arr[i]

    if x == 0:
        break

print(cnt)

```