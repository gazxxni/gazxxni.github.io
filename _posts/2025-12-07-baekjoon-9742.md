---
layout: post
title: "[백준] 9742번 순열 (Python)"
date: 2025-12-07
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "9742", 브루트포스 알고리즘, 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/9742](https://www.acmicpc.net/problem/9742)

---

## 문제
집합의 순열이란 집합의 서로 다른 원소를 모두 사용해 만들 수 있는 순서이다. 예를 들어, {2,3,5}의 순열은 다음과 같다.


	2 3 5
	2 5 3
	3 2 5
	3 5 2
	5 2 3
	5 3 2


각각의 순열은 숫자로 나타낼 수 있다. 위의 순열은 사전순으로 쓰여져 있으며, 등장하는 순서를 이용해 나타낸다. 즉, 3 5 2는 위치 4에 있고, 5 3 2는 마지막 위치인 6에 있다.

{b,e,i,n}으로 만들 수 있는 순열은 다음과 같다.


	b e i n
	b e n i
	b i e n
	b i n e
	b n e i
	b n i e
	e b i n
	e b n i
	e i b n
	e i n b
	e n b i 
	e n i b
	i b e n
	i b n e
	i e b n
	i e n b
	i n b e
	i n e b
	n b e i
	n b i e
	n e b i
	n e i b
	n i b e
	n i e b


서로 다른 숫자와 문자로 이루어진 집합과 위치가 주어졌을 때, 그 집합의 순열 중 주어진 위치의 순열을 구하는 프로그램을 작성하시오.

---

## 입력
입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있다. 첫 번째 문자열은 서로 다른 숫자와 알파벳으로 이루어져 있으며, 길이는 최대 10이다. 또한, 사전순 순서대로 주어진다. 문자열 다음에는 찾아야 하는 위치가 주어지며, 이 값은 3,628,800보다 작거나 같은 자연수이다.

---

## 출력
각각의 테스트 케이스마다, 입력으로 주어진 위치에 해당하는 순열을 공백없이 출력한다. 만약, 해당하는 순열이 없는 경우에는 "No permutation"을 출력한다.

---

## 성능 요약
메모리: 380072 KB, 시간: 2080 ms

---

## 풀이

### 풀이 핵심 로직
문제는 주어진 문자열로 만들 수 있는 모든 순열 중 특정 위치에 해당하는 순열을 찾는 것입니다. 이를 위해 먼저 문자열의 길이에 따라 모든 순열의 개수를 계산한 후, 주어진 위치가 해당 개수를 초과하는지 확인합니다. 유효한 경우, 백트래킹 기법을 사용하여 순열을 생성하고, 사전순으로 정렬하여 위치에 맞는 순열을 출력합니다.

### 동작 과정
1. 입력 문자열 `a`와 위치 `b`를 받습니다. 예를 들어, 입력이 `b e i n 10`이라면, `a = "bein"`이고 `b = 10`입니다.
2. 문자열의 길이 `n`을 구하고, `n!` (팩토리얼)을 계산하여 가능한 순열의 총 개수를 구합니다. 이 경우 `4! = 24`입니다.
3. 위치 `b`가 총 순열 개수보다 큰 경우, "No permutation"을 출력합니다.
4. 백트래킹을 통해 모든 순열을 생성합니다. `visited` 리스트를 사용하여 중복을 방지하고, 현재까지 생성한 순열을 `result` 리스트에 저장합니다.
5. 모든 순열을 사전순으로 정렬한 뒤, 인덱스를 조정하여 위치 `b`에 해당하는 순열을 찾습니다. 만약 `b`가 총 순열의 절반보다 크다면, 역순으로 접근합니다.
6. 최종적으로 `a`와 `b`, 그리고 찾은 순열을 출력합니다.

예시:
- 입력: `b e i n 10`
- 총 순열: `24`
- 10번째 순열: `e i n b`

출력: `bein 10 = einb`

### 시간 복잡도
위 코드는 모든 순열을 생성하기 때문에, 시간 복잡도는 O(n!)입니다. 여기서 n은 문자열의 길이입니다. 따라서, 최악의 경우(문자열 길이 10)에는 약 3,628,800개의 순열을 생성해야 합니다.

---

## 코드
```python
import sys, math
input = sys.stdin.readline

result = [] 
visited = [] 

def backtrack(arr, path):
    if len(path) == len(arr):
        result.append("".join(path))
        return
    
    for i in range(len(arr)):
        if not visited[i]:
            visited[i] = True
            backtrack(arr, path + [arr[i]])
            visited[i] = False

while True:
    try:
        a, b = input().split()
        b = int(b)
        a = list(a)
        n = len(a)
        total = math.factorial(n)

        if b > total:
            print(f"{''.join(a)} {b} = No permutation")
            continue

        result = []
        visited = [False] * n
        backtrack(a, [])

        result.sort()
        if b <= total // 2:
            ans = result[b-1]
        else:
            ans = result[-(total-b+1)]

        print(f"{''.join(a)} {b} = {ans}")
        
    except:
        break

```