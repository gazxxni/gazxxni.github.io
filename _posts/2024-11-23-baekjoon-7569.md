---
layout: post
title: "[백준] 7569번 (Python)"
date: 2024-11-23
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "7569"]
---

## 문제 링크
[https://www.acmicpc.net/problem/7569](https://www.acmicpc.net/problem/7569)

---

## 풀이

### 풀이 핵심 로직
이 문제는 3차원 격자에서 익은 토마토가 익지 않은 토마토에 영향을 미치는 과정을 BFS(너비 우선 탐색)를 통해 시뮬레이션합니다. 모든 익은 토마토의 위치에서 시작하여 인접한 익지 않은 토마토를 찾아 익히는 과정을 반복하며, 최종적으로 모든 토마토가 익는 데 걸리는 최소 날짜를 계산합니다.

### 동작 과정
1. **입력**:
   - 입력은 `m`, `n`, `h`의 세 가지 차원 크기를 받고, 각 층마다 `n`행과 `m`열의 토마토 상태(익음: 1, 익지 않음: 0, 썩음: -1)를 입력받습니다.

2. **초기 설정**:
   - 익은 토마토의 위치를 큐에 추가합니다. 예를 들어, 입력이 다음과 같다고 가정합니다:
     ```
     3 3 2
     0 0 1
     0 0 0
     0 0 0
     0 0 0
     0 0 1
     0 0 0
     ```
   - 이 경우, 층 0의 (0, 2)와 층 1의 (0, 2) 위치에서 익은 토마토가 발견되어 큐에 추가됩니다.

3. **BFS 탐색**:
   - 큐에서 익은 토마토의 위치를 꺼내고, 6개의 방향(상하좌우, 위아래)으로 인접한 위치를 탐색합니다.
   - 만약 인접한 토마토가 익지 않았다면, 현재 토마토의 날짜 + 1로 익은 날짜를 설정하고, 그 위치를 큐에 추가합니다.

4. **결과 확인**:
   - 모든 큐가 소진된 후, 격자를 다시 탐색하여 익지 않은 토마토가 있는지 확인합니다. 만약 익지 않은 토마토가 존재한다면 -1을 출력합니다.
   - 모든 토마토가 익었다면, 최종적으로 최대 날짜를 구하고, 시작 상태를 제외하기 위해 1을 빼서 출력합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(m * n * h)입니다. 각 토마토에 대해 BFS를 수행하므로, 3차원 배열의 모든 요소를 한 번씩 탐색하게 됩니다.

---

## 코드
```python
from collections import deque

m, n, h = map(int, input().split())
matrix = []

for _ in range(h):
    layer = [list(map(int, input().split())) for _ in range(n)]
    matrix.append(layer)

q = deque()
# 토마토 익히기 위해 사용할 방향 배열 (상하좌우, 위아래)
directions = [(-1, 0, 0), (1, 0, 0), (0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1)]

# 초기 익은 토마토의 위치를 큐에 추가합니다.
for z in range(h):   # 층
    for i in range(n):  # 행
        for j in range(m):  # 열
            if matrix[z][i][j] == 1:  # 익은 토마토인 경우
                q.append((i, j, z))  # 큐에 (행, 열, 층) 추가

while q:
    x, y, z = q.popleft() 
    
    # 현재 토마토의 주변 6개 방향 탐색
    for dx, dy, dz in directions:
        nx, ny, nz = x + dx, y + dy, z + dz  
        
        # 새로운 좌표가 배열의 범위 내에 있는지 체크
        if 0 <= nx < n and 0 <= ny < m and 0 <= nz < h:
            # 익지 않은 토마토인 경우
            if matrix[nz][nx][ny] == 0:  
                # 현재 토마토의 날짜 + 1로 익은 날짜를 설정
                matrix[nz][nx][ny] = matrix[z][x][y] + 1  
                q.append((nx, ny, nz))

# 결과 확인: 모든 토마토가 익었는지 확인
max_days = 0  # 최대 날짜를 저장할 변수
for z in range(h):  # 층
    for i in range(n):  # 행
        for j in range(m):  # 열
            if matrix[z][i][j] == 0:  # 익지 않은 토마토가 남아있는 경우
                print(-1)  # 모든 토마토가 익지 못했음을 출력
                exit(0)  
            max_days = max(max_days, matrix[z][i][j])  # 최대 날짜 갱신

# 최종 결과 출력: 시작 상태를 제외하므로 1을 빼줍니다.
print(max_days - 1)  

```