---
layout: post
title: "[백준] 9742번 순열 (Python)"
date: 2025-12-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "9742", 브루트포스 알고리즘, 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/9742](https://www.acmicpc.net/problem/9742)

---

## 문제
집합의 순열이란 집합의 서로 다른 원소를 모두 사용해 만들 수 있는 순서이다. 예를 들어, {2,3,5}의 순열은 다음과 같다.


	2 3 5
	2 5 3
	3 2 5
	3 5 2
	5 2 3
	5 3 2


각각의 순열은 숫자로 나타낼 수 있다. 위의 순열은 사전순으로 쓰여져 있으며, 등장하는 순서를 이용해 나타낸다. 즉, 3 5 2는 위치 4에 있고, 5 3 2는 마지막 위치인 6에 있다.

{b,e,i,n}으로 만들 수 있는 순열은 다음과 같다.


	b e i n
	b e n i
	b i e n
	b i n e
	b n e i
	b n i e
	e b i n
	e b n i
	e i b n
	e i n b
	e n b i 
	e n i b
	i b e n
	i b n e
	i e b n
	i e n b
	i n b e
	i n e b
	n b e i
	n b i e
	n e b i
	n e i b
	n i b e
	n i e b


서로 다른 숫자와 문자로 이루어진 집합과 위치가 주어졌을 때, 그 집합의 순열 중 주어진 위치의 순열을 구하는 프로그램을 작성하시오.

---

## 입력
입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있다. 첫 번째 문자열은 서로 다른 숫자와 알파벳으로 이루어져 있으며, 길이는 최대 10이다. 또한, 사전순 순서대로 주어진다. 문자열 다음에는 찾아야 하는 위치가 주어지며, 이 값은 3,628,800보다 작거나 같은 자연수이다.

---

## 출력
각각의 테스트 케이스마다, 입력으로 주어진 위치에 해당하는 순열을 공백없이 출력한다. 만약, 해당하는 순열이 없는 경우에는 "No permutation"을 출력한다.

---

## 성능 요약
메모리: 380072 KB, 시간: 2080 ms

---

## 풀이

### 풀이 핵심 로직
주어진 문자열의 순열을 구하기 위해 백트래킹을 사용하여 모든 가능한 순열을 생성합니다. 생성된 순열은 사전순으로 정렬한 후, 요청된 위치에 해당하는 순열을 찾아 출력합니다. 만약 요청된 위치가 가능한 순열의 수를 초과하면 "No permutation"을 출력합니다.

### 동작 과정
1. 입력으로 `{b,e,i,n}`와 `15`를 받았다고 가정합니다.
2. 주어진 문자열의 길이는 4이므로, 총 가능한 순열의 수는 `4! = 24`입니다.
3. 순열을 생성하여 `result` 리스트에 추가합니다: 
   - 예를 들어, `b e i n`, `b e n i`, `b i e n`, ..., `n i e b`와 같이 24개의 순열이 생성됩니다.
4. 결과 리스트를 사전순으로 정렬합니다. 이 경우 이미 사전순으로 생성되므로 정렬 과정은 생략 가능합니다.
5. 요청된 위치 `15`에 해당하는 순열은 `i n b e`입니다.
6. 최종적으로 `b e i n 15 = inbe`로 출력합니다.

### 시간 복잡도
시간 복잡도는 O(n!)입니다. 이는 모든 순열을 생성하는 과정에서 발생하는 복잡도로, 주어진 n의 최대 값이 10이므로 실제로는 10! = 3,628,800 번의 계산이 이루어질 수 있습니다. 하지만, 입력의 범위와 백트래킹을 통해 효율적으로 동작할 수 있습니다.

---

## 코드
```python
import sys, math
input = sys.stdin.readline

result = [] 
visited = [] 

def backtrack(arr, path):
    if len(path) == len(arr):
        result.append("".join(path))
        return
    
    for i in range(len(arr)):
        if not visited[i]:
            visited[i] = True
            backtrack(arr, path + [arr[i]])
            visited[i] = False

while True:
    try:
        a, b = input().split()
        b = int(b)
        a = list(a)
        n = len(a)
        total = math.factorial(n)

        if b > total:
            print(f"{''.join(a)} {b} = No permutation")
            continue

        result = []
        visited = [False] * n
        backtrack(a, [])

        result.sort()
        if b <= total // 2:
            ans = result[b-1]
        else:
            ans = result[-(total-b+1)]

        print(f"{''.join(a)} {b} = {ans}")
        
    except:
        break

```