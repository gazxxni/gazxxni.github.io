---
layout: post
title: "[백준] 9742번 순열 (Python)"
date: 2025-12-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "9742", 브루트포스 알고리즘, 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/9742](https://www.acmicpc.net/problem/9742)

---

## 문제
집합의 순열이란 집합의 서로 다른 원소를 모두 사용해 만들 수 있는 순서이다. 예를 들어, {2,3,5}의 순열은 다음과 같다.


	2 3 5
	2 5 3
	3 2 5
	3 5 2
	5 2 3
	5 3 2


각각의 순열은 숫자로 나타낼 수 있다. 위의 순열은 사전순으로 쓰여져 있으며, 등장하는 순서를 이용해 나타낸다. 즉, 3 5 2는 위치 4에 있고, 5 3 2는 마지막 위치인 6에 있다.

{b,e,i,n}으로 만들 수 있는 순열은 다음과 같다.


	b e i n
	b e n i
	b i e n
	b i n e
	b n e i
	b n i e
	e b i n
	e b n i
	e i b n
	e i n b
	e n b i 
	e n i b
	i b e n
	i b n e
	i e b n
	i e n b
	i n b e
	i n e b
	n b e i
	n b i e
	n e b i
	n e i b
	n i b e
	n i e b


서로 다른 숫자와 문자로 이루어진 집합과 위치가 주어졌을 때, 그 집합의 순열 중 주어진 위치의 순열을 구하는 프로그램을 작성하시오.

---

## 입력
입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있다. 첫 번째 문자열은 서로 다른 숫자와 알파벳으로 이루어져 있으며, 길이는 최대 10이다. 또한, 사전순 순서대로 주어진다. 문자열 다음에는 찾아야 하는 위치가 주어지며, 이 값은 3,628,800보다 작거나 같은 자연수이다.

---

## 출력
각각의 테스트 케이스마다, 입력으로 주어진 위치에 해당하는 순열을 공백없이 출력한다. 만약, 해당하는 순열이 없는 경우에는 "No permutation"을 출력한다.

---

## 성능 요약
메모리: 380072 KB, 시간: 2080 ms

---

## 풀이

### 풀이 핵심 로직
주어진 문자열의 모든 순열을 생성하여 사전 순으로 정렬한 후, 특정 위치에 해당하는 순열을 찾는 문제입니다. 직접 모든 순열을 생성하기보다는, 수학적 계산을 통해 순열의 개수를 파악하고, 위치를 기반으로 각 문자 선택 과정을 반복하여 원하는 순열을 효율적으로 구하는 방법을 사용합니다.

### 동작 과정
1. **입력 처리:** 입력으로 주어진 문자열 `a`와 위치 `b`를 읽어옵니다.
2. **팩토리얼 계산:** 문자열의 길이를 기준으로 총 순열의 개수를 계산합니다 (`n!`).
3. **위치 유효성 검사:** 요청된 위치 `b`가 총 순열의 개수보다 크면 "No permutation"을 출력합니다.
4. **순열 생성:** 각 문자를 포함하는 순열을 생성하기 위해 반복적으로 문자를 선택합니다. 현재 선택한 문자의 위치에 따라 남은 문자로 가능한 순열의 개수를 계산하여, 선택할 문자를 결정합니다.
5. **결과 출력:** 최종적으로 생성된 순열을 출력합니다.

예시 입력:
```
beain 10
```
- `n = 4`이므로 총 순열 수는 `4! = 24`입니다.
- 요청된 위치 `10`은 유효하므로 순열을 생성합니다.
- 사전 순으로 나열된 순열에서 10번째 순열은 `i e n b`입니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 `O(n^2)`입니다. 이는 각 문자 선택 과정에서 남은 문자들의 순열 개수를 계산하는 데 걸리는 시간 때문입니다. 하지만 일반적으로 `n`이 10 이하로 제한되어 있으므로 실제로는 매우 빠르게 동작합니다.

---

## 코드
```python
import sys, math
input = sys.stdin.readline

result = [] 
visited = [] 

def backtrack(arr, path):
    if len(path) == len(arr):
        result.append("".join(path))
        return
    
    for i in range(len(arr)):
        if not visited[i]:
            visited[i] = True
            backtrack(arr, path + [arr[i]])
            visited[i] = False

while True:
    try:
        a, b = input().split()
        b = int(b)
        a = list(a)
        n = len(a)
        total = math.factorial(n)

        if b > total:
            print(f"{''.join(a)} {b} = No permutation")
            continue

        result = []
        visited = [False] * n
        backtrack(a, [])

        result.sort()
        if b <= total // 2:
            ans = result[b-1]
        else:
            ans = result[-(total-b+1)]

        print(f"{''.join(a)} {b} = {ans}")
        
    except:
        break

```