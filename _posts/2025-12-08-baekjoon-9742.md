---
layout: post
title: "[백준] 9742번 순열 (Python)"
date: 2025-12-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "9742", 브루트포스 알고리즘, 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/9742](https://www.acmicpc.net/problem/9742)

---

## 문제
집합의 순열이란 집합의 서로 다른 원소를 모두 사용해 만들 수 있는 순서이다. 예를 들어, {2,3,5}의 순열은 다음과 같다.


	2 3 5
	2 5 3
	3 2 5
	3 5 2
	5 2 3
	5 3 2


각각의 순열은 숫자로 나타낼 수 있다. 위의 순열은 사전순으로 쓰여져 있으며, 등장하는 순서를 이용해 나타낸다. 즉, 3 5 2는 위치 4에 있고, 5 3 2는 마지막 위치인 6에 있다.

{b,e,i,n}으로 만들 수 있는 순열은 다음과 같다.


	b e i n
	b e n i
	b i e n
	b i n e
	b n e i
	b n i e
	e b i n
	e b n i
	e i b n
	e i n b
	e n b i 
	e n i b
	i b e n
	i b n e
	i e b n
	i e n b
	i n b e
	i n e b
	n b e i
	n b i e
	n e b i
	n e i b
	n i b e
	n i e b


서로 다른 숫자와 문자로 이루어진 집합과 위치가 주어졌을 때, 그 집합의 순열 중 주어진 위치의 순열을 구하는 프로그램을 작성하시오.

---

## 입력
입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있다. 첫 번째 문자열은 서로 다른 숫자와 알파벳으로 이루어져 있으며, 길이는 최대 10이다. 또한, 사전순 순서대로 주어진다. 문자열 다음에는 찾아야 하는 위치가 주어지며, 이 값은 3,628,800보다 작거나 같은 자연수이다.

---

## 출력
각각의 테스트 케이스마다, 입력으로 주어진 위치에 해당하는 순열을 공백없이 출력한다. 만약, 해당하는 순열이 없는 경우에는 "No permutation"을 출력한다.

---

## 성능 요약
메모리: 380072 KB, 시간: 2080 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 문자 집합의 순열을 생성하고, 특정 위치에 해당하는 순열을 찾는 문제입니다. 백트래킹을 통해 모든 순열을 생성하고, 사전 순으로 정렬한 후, 요청된 위치의 순열을 출력합니다. 만약 위치가 가능한 순열의 개수를 초과하면 "No permutation"을 출력합니다.

### 동작 과정
1. 입력으로 주어진 문자열과 위치를 받습니다. 예를 들어, 입력이 `beain 12`라면, 문자열은 `beain`이고 위치는 `12`입니다.
2. 문자열을 리스트로 변환하여 각 문자들을 개별적으로 처리합니다. 여기서는 `['b', 'e', 'a', 'i', 'n']`이 됩니다.
3. 총 순열의 개수는 `n!`로 계산되며, `n`은 문자열의 길이입니다. 이 경우, `n = 5`이므로 총 순열의 개수는 `5! = 120`입니다.
4. 주어진 위치가 총 순열의 수보다 크다면 "No permutation"을 출력합니다.
5. 백트래킹을 사용하여 모든 순열을 생성합니다. 이 과정에서 `visited` 리스트를 사용하여 이미 사용한 문자를 추적합니다.
6. 생성된 모든 순열을 사전 순으로 정렬합니다.
7. 요청된 위치에 해당하는 순열을 찾습니다. 예를 들어, `12`번째 순열을 찾는다면, 정렬된 순열 리스트에서 `11`번째 인덱스를 출력합니다 (인덱스는 0부터 시작하므로).
8. 결과를 출력합니다. 만약 위치가 유효하다면 해당 순열을 출력하고, 그렇지 않으면 "No permutation"을 출력합니다.

예시:
- 입력: `beain 12`
- 총 순열: `['abein', 'abein', 'abien', ...]` (120개의 순열)
- 정렬 후 12번째 순열은 `beain`이므로 출력: `beain 12 = beian`

### 시간 복잡도
- 순열을 생성하는 과정에서 `O(n!)`의 시간이 소요됩니다. 여기서 `n`은 문자열의 길이입니다. 입력 길이가 10이므로 최대 10! = 3,628,800까지 계산할 수 있습니다. 따라서 최종 시간 복잡도는 `O(n!)`입니다.

---

## 코드
```python
import sys, math
input = sys.stdin.readline

result = [] 
visited = [] 

def backtrack(arr, path):
    if len(path) == len(arr):
        result.append("".join(path))
        return
    
    for i in range(len(arr)):
        if not visited[i]:
            visited[i] = True
            backtrack(arr, path + [arr[i]])
            visited[i] = False

while True:
    try:
        a, b = input().split()
        b = int(b)
        a = list(a)
        n = len(a)
        total = math.factorial(n)

        if b > total:
            print(f"{''.join(a)} {b} = No permutation")
            continue

        result = []
        visited = [False] * n
        backtrack(a, [])

        result.sort()
        if b <= total // 2:
            ans = result[b-1]
        else:
            ans = result[-(total-b+1)]

        print(f"{''.join(a)} {b} = {ans}")
        
    except:
        break

```