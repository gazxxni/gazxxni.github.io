---
layout: post
title: "[백준] 9663번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "9663"]
---

## 문제 링크
[https://www.acmicpc.net/problem/9663](https://www.acmicpc.net/problem/9663)

---

## 풀이

### 풀이 핵심 로직
이 문제는 N-Queens 문제로, N개의 퀸을 N x N 체스판에 서로 공격할 수 없게 배치하는 경우의 수를 구하는 것입니다. 핵심 아이디어는 깊이 우선 탐색(DFS)을 사용하여 각 행(row)마다 가능한 열(column)에 퀸을 놓고, 그 배치가 유효한지를 검사하여 모든 경우의 수를 탐색하는 것입니다.

### 동작 과정
1. **입력**: 예를 들어, 입력으로 `4`가 주어지면 4x4 체스판에 퀸을 배치하는 경우를 찾습니다.
2. **초기화**: `visited` 리스트는 각 행에 배치된 퀸의 열 위치를 저장합니다. `cnt`는 가능한 배치의 수를 세는 변수입니다.
3. **DFS 호출**: `dfs(0)`을 호출하여 첫 번째 행부터 시작합니다.
4. **열 배치**: 각 행(row)마다 열(column)을 0부터 n-1까지 반복하며 퀸을 배치합니다.
5. **유효성 검사**: `check(now_row)` 함수를 통해 현재 배치가 유효한지 확인합니다. 같은 열에 있는지 및 대각선 공격 가능성을 검사합니다.
6. **재귀 호출**: 유효하다면 다음 행으로 넘어가 `dfs(row + 1)`을 호출합니다.
7. **종료 조건**: 모든 행에 대한 배치를 완료하면 `cnt`를 1 증가시킵니다.
8. **결과 출력**: 모든 경우의 수를 탐색한 후 `cnt`를 출력합니다.

단계별 예시 (n=4):
- 처음 `dfs(0)`에서 첫 번째 행에 0열에 퀸을 놓습니다.
- `check(0)`에서 유효한 배치임을 확인 후 `dfs(1)` 호출.
- 두 번째 행에 1열에 퀸을 놓고 `check(1)`을 통해 유효성을 검사.
- 이러한 과정을 반복하며 모든 유효한 경우를 탐색하고, 최종적으로 2가지 경우 (0,1),(1,3)과 (0,2),(2,0),(3,1)로 2가지를 찾습니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(N!)입니다. 각 행(row)마다 N개의 열(column)을 시도하고, 최악의 경우 모든 가능한 배치를 탐색해야 하기 때문입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline
 
n = int(input())
	
visited = [-1] * n
cnt = 0
 
def check(now_row):
    for row in range(now_row):
        if visited[now_row] == visited[row] or now_row - row == abs(visited[now_row] - visited[row]):
            return False
    return True
 
def dfs(row):
    global cnt
    
    if row == n: 
        cnt += 1
 
    else:
        for col in range(n):
            visited[row] = col
            if check(row): 
                dfs(row + 1) 
                
dfs(0)
print(cnt)
```