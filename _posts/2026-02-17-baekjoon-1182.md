---
layout: post
title: "[백준] 1182번 부분수열의 합 (Python)"
date: 2026-02-17
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1182", 브루트포스 알고리즘, 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/1182](https://www.acmicpc.net/problem/1182)

## 문제
N개의 정수로 이루어진 수열이 있을 때, 크기가 양수인 부분수열 중에서 그 수열의 원소를 다 더한 값이 S가 되는 경우의 수를 구하는 프로그램을 작성하시오.

## 입력
첫째 줄에 정수의 개수를 나타내는 N과 정수 S가 주어진다. (1 ≤ N ≤ 20, |S| ≤ 1,000,000) 둘째 줄에 N개의 정수가 빈 칸을 사이에 두고 주어진다. 주어지는 정수의 절댓값은 100,000을 넘지 않는다.

## 출력
첫째 줄에 합이 S가 되는 부분수열의 개수를 출력한다.

## 풀이
### 풀이 핵심 로직
이 문제의 핵심 아이디어는 부분수열을 생성하고 그 합이 주어진 S와 일치하는 경우를 세는 것이다. 모든 가능한 부분수열을 생성하기 위해 브루트포스 알고리즘을 사용하여, 조합(combinations)을 통해 1부터 N까지의 원소 개수를 가지는 부분수열을 확인한다.

### 동작 과정
1. **입력 처리**:
   - 첫 줄에서 정수 N과 S를 입력받는다.
   - 두 번째 줄에서 N개의 정수를 리스트 형태로 입력받는다.

2. **부분수열 생성**:
   - `itertools.combinations`를 사용하여 1부터 N까지의 길이를 가지는 모든 조합(부분수열)을 생성한다.

3. **합 계산 및 카운팅**:
   - 각 조합의 합을 계산하고, 그 합이 S와 같을 경우 카운트를 증가시킨다.

4. **결과 출력**:
   - 최종적으로 카운트된 값을 출력한다.

예시 입력:
```
5 0
-7 -3 -2 5 8
```
- 첫 번째 줄에서 N=5, S=0 이고, 두 번째 줄에서 수열은 [-7, -3, -2, 5, 8]이다.
- 가능한 부분수열을 생성하고 그 합을 계산하여 0이 되는 경우의 수를 센다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 부분수열의 개수에 비례한다. 부분수열의 개수는 \(2^N - 1\) (N개의 원소 중 비어있지 않은 조합의 수)이다. 따라서, 최악의 경우 시간 복잡도는 \(O(2^N \cdot N)\) 이다. 여기서 \(N\)은 부분수열의 합을 계산하는 데 필요한 시간이다. 주어진 조건에서 N은 최대 20이므로, 이 알고리즘은 실질적으로 실행 가능한 범위에 있다.

## 코드
```python
from itertools import combinations

n, s = map(int, input().split())
arr = list(map(int, input().split()))

cnt = 0 
combi = [list(combinations(arr, i)) for i in range(1, n + 1)]

for row in combi:
    for c in row:
        if sum(c) == s:
            cnt += 1

print(cnt)
```