---
layout: post
title: "[백준] 1766번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1766"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1766](https://www.acmicpc.net/problem/1766)

---

## 풀이

### 풀이 핵심 로직
이 문제는 **위상 정렬**을 이용하여 주어진 방향 그래프의 노드를 정렬하는 문제입니다. 위상 정렬은 DAG(Directed Acyclic Graph)의 노드를 정렬하는 알고리즘으로, 특정 노드가 다른 노드보다 먼저 오는 순서를 보장합니다. 이 코드는 우선순위 큐(최소 힙)를 사용하여 인접한 노드 중에서 가장 작은 값을 우선적으로 처리합니다.

### 동작 과정
1. **입력 처리**: 
   - `n`과 `m`을 입력받아 각각 노드 수와 간선 수를 설정합니다.
   - `arr` 리스트를 생성하여 각 노드에 대한 인접 리스트를 초기화하고, `indegree` 리스트를 초기화하여 각 노드의 진입 차수를 기록합니다.

2. **간선 정보 추가**:
   - 각 간선 `(a, b)`에 대해 `a`에서 `b`로의 간선을 추가하고, `b`의 진입 차수를 증가시킵니다.

3. **위상 정렬 함수 실행**:
   - 진입 차수가 0인 모든 노드를 최소 힙에 추가합니다.
   - 힙에서 노드를 하나씩 꺼내어 `ans` 리스트에 추가하고, 그 노드와 연결된 노드들의 진입 차수를 감소시킵니다.
   - 만약 어떤 노드의 진입 차수가 0이 되면, 그 노드를 힙에 추가합니다.

4. **결과 출력**:
   - 최종적으로 `ans` 리스트에 저장된 노드들을 1-based 인덱스로 출력합니다.

**예시 입력**:
```
6 6
6 5
5 4
4 3
3 2
2 1
```
- 이 입력은 6개의 노드와 6개의 간선으로 구성된 그래프를 나타냅니다. 위의 입력을 기반으로 그래프의 간선이 추가되고, 위상 정렬이 수행됩니다. 가능한 정렬 결과는 `6 5 4 3 2 1` 또는 `6 5 4 3 1 2`와 같이 나올 수 있습니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 **O(N + M)**입니다. 여기서 `N`은 노드의 수, `M`은 간선의 수입니다. 각 노드와 간선을 한 번씩 방문하기 때문에 이와 같은 복잡도가 발생합니다.

---

## 코드
```python
import sys
input = sys.stdin.readline
import heapq

n, m = map(int, input().split())

arr = [[] for _ in range(n)]
indegree = [0] * n
ans = []

for _ in range(m):
    a, b = map(int, input().split())
    arr[a-1].append(b-1)  
    indegree[b-1] += 1

def topological_sort():    
    hq = []

    for i in range(n):
        if indegree[i] == 0:
            heapq.heappush(hq, i)
            
    while hq:
        cur = heapq.heappop(hq)
        ans.append(cur)
        
        for j in arr[cur]:
            indegree[j] -= 1
            
            if indegree[j] == 0:
               heapq.heappush(hq, j)
                
            
    return ans

topological_sort()
for i in ans:
    print(i+1, end=' ')

```