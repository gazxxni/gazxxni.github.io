---
layout: post
title: "[백준] 1916번 (Python)"
date: 2025-02-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1916"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1916](https://www.acmicpc.net/problem/1916)

---

## 풀이

### 풀이 핵심 로직
이 문제는 Dijkstra 알고리즘을 이용하여 주어진 도시들 간의 최단 경로 비용을 계산하는 문제입니다. 그래프의 각 정점은 도시를, 각 간선은 도시 간의 비용을 나타내며, 최소 비용을 찾기 위해 우선순위 큐를 활용하여 가장 낮은 비용의 경로를 계속해서 탐색합니다.

### 동작 과정
1. **입력 예시**: 
   ```
   5
   6
   1 2 2
   1 3 3
   2 3 1
   2 4 4
   3 4 1
   4 5 1
   1 5
   ```

2. **초기화**:
   - 도시의 수 `n`은 5, 간선의 수 `m`은 6이다.
   - 그래프는 인접 리스트 형태로 표현되며, `costs` 리스트는 무한대로 초기화된다.
   - 입력에 따라 그래프는 다음과 같이 구성된다:
     ```
     1 -> (2, 2), (3, 3)
     2 -> (3, 1), (4, 4)
     3 -> (4, 1)
     4 -> (5, 1)
     ```

3. **Dijkstra 알고리즘 실행**:
   - 시작 도시 `1`에서 Dijkstra 알고리즘을 실행한다.
   - 우선순위 큐에 `(0, 1)`을 추가하여 시작한다. 현재 비용은 `0`이고 현재 노드는 `1`이다.
   - `1`에서 연결된 도시 `2`와 `3`로의 경로 비용을 업데이트한다. `costs` 리스트는 `[INF, 0, 2, 3, INF, INF]`가 된다.
   - 다음으로 `2`를 처리하여 `3`과 `4`로의 비용을 업데이트한다. 최종적으로 `costs` 리스트는 `[INF, 0, 2, 3, 4, 5]`가 된다.
   - 마지막으로, 도시 `5`에 도달하는 최소 비용은 `5`이다.

4. **출력**: 최단 거리 결과인 `costs[b]` 즉, `costs[5]` 값을 출력한다.

### 시간 복잡도
Dijkstra 알고리즘의 시간 복잡도는 O((V + E) log V)입니다. 여기서 V는 정점의 수, E는 간선의 수입니다. 이 문제에서는 우선순위 큐를 사용하여 최소 비용 경로를 효율적으로 찾고 있습니다.

---

## 코드
```python
import sys
import heapq

INF = int(1e9)   # 무한대를 나타내는 값

n = int(input()) 
m = int(input()) 
graph = [[] for _ in range(n + 1)] 
costs = [INF] * (n + 1)  # 최소 비용 테이블 초기화

for _ in range(m):
    u, v, w = map(int, input().split())  # u: 시작 도시, v: 도착 도시, w: 비용
    graph[u].append((v, w))  # u -> v, 비용 w

a, b = map(int, input().split())

def search(start):
    q = []
    heapq.heappush(q, (0, start))  # 시작 노드 (비용 0, 시작점)
    costs[start] = 0  # 시작 노드의 최소 비용 0

    while q:
        current_cost, now = heapq.heappop(q)  # 현재 최소 비용이 가장 작은 노드를 꺼냄

        if costs[now] < current_cost:   # 이미 처리된 적이 있는 노드는 무시
            continue

        for next_node, weight in graph[now]:  # 현재 노드와 연결된 인접 노드 확인
            cost = current_cost + weight

            # 현재 노드를 통해 다른 노드로 가는 비용이 더 적다면 갱신
            if cost < costs[next_node]:
                costs[next_node] = cost
                heapq.heappush(q, (cost, next_node))  # 갱신된 비용을 큐에 추가

search(a)
print(costs[b]) 

```