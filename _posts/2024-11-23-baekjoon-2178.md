---
layout: post
title: "[백준] 2178번 (Python)"
date: 2024-11-23
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2178"]
---

## 문제 링크
[https://www.acmicpc.net/problem/2178](https://www.acmicpc.net/problem/2178)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 미로에서 시작점(0,0)에서 도착점(n-1,m-1)까지 최단 경로를 찾는 문제입니다. BFS(너비 우선 탐색)를 사용하여 각 위치에서 가능한 이동 경로를 탐색하며, 방문한 경로의 거리를 기록하여 최단 경로의 길이를 구합니다.

### 동작 과정
1. 입력으로 미로의 크기 n(행)과 m(열)을 받고, 각 행의 정보를 리스트로 변환하여 `graph`에 저장합니다.
2. BFS를 수행하기 위해 초기 위치 (0,0)을 큐에 추가하고, 해당 위치에서 시작합니다.
3. 큐가 빌 때까지 반복하며, 현재 위치에서 상하좌우로 이동할 수 있는지 확인합니다.
   - 이동 가능한 위치가 미로의 범위 안에 있고, 값이 1(통로)인 경우 큐에 추가하고, 이동 거리(`graph`의 값)를 업데이트합니다.
4. BFS가 종료되면 도착점의 값(최단 경로 거리)을 반환합니다.

예시 입력:
```
4 6
101111
101010
101011
111111
```
- 초기 상태: 큐에 (0,0) 추가, `graph`는 [[1, 0, 1, 1, 1, 1], ...]
- BFS 진행:
  - (0,0)에서 (1,0)으로 이동 (거리 2)
  - (1,0)에서 (2,0)으로 이동 (거리 3)
  - (2,0)에서 (3,0)으로 이동 (거리 4)
  - (3,0)에서 (3,1)으로 이동 (거리 5)
  - 계속해서 (3,2), (3,3), (3,4), (3,5)까지 이동하여 최종적으로 도착점 (3,5)에서 거리 11에 도달.

### 시간 복잡도
BFS의 경우 최악의 경우 모든 노드를 방문해야 하므로 O(N * M)입니다. 여기서 N은 미로의 행 수, M은 열 수입니다.

---

## 코드
```python
from collections import deque

n, m = map(int, input().split())
graph = [] 

for _ in range(n):  # rstrip()로 '\n' 제거 후, 한 줄을 리스트로 변환하여 추가
    graph.append(list(map(int, input().rstrip())))  

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1] 


def bfs(x, y):
    
    queue = deque()  
    queue.append((x, y))  

    while queue:
        x, y = queue.popleft() 

        for i in range(4):
            nx = x + dx[i]  
            ny = y + dy[i] 

            # 이동한 좌표가 미로 범위 안에 있고, 아직 방문하지 않은 길(1)인 경우
            if 0 <= nx < n and 0 <= ny < m and graph[nx][ny] == 1:
                queue.append((nx, ny))  # 이동할 좌표를 큐에 추가
                graph[nx][ny] = graph[x][y] + 1  # 이전 좌표까지의 이동 거리 +1
    
    # 도착 지점의 값(최단 경로 거리)을 반환
    return graph[n-1][m-1]

print(bfs(0,0))

```