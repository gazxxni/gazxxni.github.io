---
layout: post
title: "[백준] 10870번 피보나치 수 5 (Python)"
date: 2025-12-07
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, 10870, 수학, 구현]
---

## 문제 링크
[https://www.acmicpc.net/problem/10870](https://www.acmicpc.net/problem/10870)

---

## 문제
피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.

이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다.

n=17일때 까지 피보나치 수를 써보면 다음과 같다.

0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597

n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.

---

## 입력
첫째 줄에 n이 주어진다. n은 20보다 작거나 같은 자연수 또는 0이다.

---

## 출력
첫째 줄에 n번째 피보나치 수를 출력한다.

---

## 성능 요약
메모리: 108384 KB, 시간: 104 ms

---

## 풀이

### 풀이 핵심 로직
피보나치 수는 재귀적으로 정의되며, n번째 피보나치 수는 바로 앞의 두 수의 합으로 계산할 수 있습니다. 이 문제에서는 동적 프로그래밍(Dynamic Programming) 기법을 사용하여 이전에 계산한 값을 저장하고 활용함으로써 효율적으로 n번째 피보나치 수를 구합니다.

### 동작 과정
1. 입력으로 n을 받습니다. 예를 들어, n = 5라고 가정합시다.
2. dp 배열을 생성하여 피보나치 수를 저장합니다. `dp[0]`는 0, `dp[1]`은 1로 초기화합니다.
3. n이 2 이상일 경우, 반복문을 통해 `dp[i] = dp[i-1] + dp[i-2]`를 수행하여 2부터 n까지의 피보나치 수를 계산합니다.
   - `i=2`: dp[2] = dp[1] + dp[0] = 1 + 0 = 1
   - `i=3`: dp[3] = dp[2] + dp[1] = 1 + 1 = 2
   - `i=4`: dp[4] = dp[3] + dp[2] = 2 + 1 = 3
   - `i=5`: dp[5] = dp[4] + dp[3] = 3 + 2 = 5
4. 최종적으로 dp[5]를 출력하여 5번째 피보나치 수인 5를 얻습니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n)입니다. n에 비례하여 반복문이 실행되기 때문입니다. 이 외에도 공간 복잡도도 O(n)으로, dp 배열이 n 크기를 갖기 때문입니다.

---

## 코드
```python
n = int(input())

if n > 2:
    dp = [0] * (n + 1)
    dp[1] = 1
    dp[2] = 1
    dp[2] = 2

    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
        
    print(dp[n - 1])
        
elif n == 2 or n == 1:
    print(1)

else:
    print(0)
```