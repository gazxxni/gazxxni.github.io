---
layout: post
title: "[백준] 1342번 행운의 문자열 (Python)"
date: 2025-12-07
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, 1342, 브루트포스 알고리즘, 집합과 맵, 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/1342](https://www.acmicpc.net/problem/1342)

---

## 문제
민식이와 준영이는 자기 방에서 문자열을 공부하고 있다. 민식이가 말하길 인접해 있는 모든 문자가 같지 않은 문자열을 행운의 문자열이라고 한다고 한다. 준영이는 문자열 S를 분석하기 시작했다. 준영이는 문자열 S에 나오는 문자를 재배치하면 서로 다른 행운의 문자열이 몇 개 나오는지 궁금해졌다. 만약 원래 문자열 S도 행운의 문자열이라면 그것도 개수에 포함한다.

---

## 입력
첫째 줄에 문자열 S가 주어진다. S의 길이는 최대 10이고, 알파벳 소문자로만 이루어져 있다.

---

## 출력
첫째 줄에 위치를 재배치해서 얻은 서로 다른 행운의 문자열의 개수를 출력한다.

---

## 성능 요약
메모리: 113412 KB, 시간: 1512 ms

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 백트래킹을 이용하여 주어진 문자열의 모든 가능한 조합을 생성하되, 인접한 문자가 같지 않도록 제약을 두는 것입니다. 이를 위해 각 문자의 개수를 카운트하여 가능한 조합을 만들고, 조건을 만족할 때마다 카운트를 증가시킵니다.

### 동작 과정
1. **입력 문자열**: 예를 들어, 입력 문자열 S가 "aab"라고 가정합니다.
2. **문자 빈도 계산**: 각 문자의 빈도를 딕셔너리에 저장합니다. 이 경우 `{'a': 2, 'b': 1}`이 됩니다.
3. **백트래킹 함수 호출**: `back(dic, None, 0)`로 초기화하여 백트래킹을 시작합니다. 여기서 `dic`는 문자 빈도, `before`는 이전에 사용한 문자(처음에는 None), `use`는 현재까지 사용한 문자 수입니다.
4. **조건 확인 및 재귀 호출**:
   - `use`가 문자열의 길이와 같으면 카운트를 증가시킵니다.
   - 각 문자를 순회하면서, 사용 가능한 문자가 있고 이전 문자와 다르면 해당 문자를 사용하고 재귀 호출합니다.
5. **결과 출력**: 모든 조합이 탐색이 끝나면 카운트를 출력합니다.

예를 들어, "aab"의 경우:
- 가능한 행운의 문자열은 "aab", "aba", "baa"이며, 이 중 "baa"는 인접 문자가 같아 조건을 만족하지 않으므로 "aab", "aba"만 유효합니다. 

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(N!)입니다. 여기서 N은 문자열의 길이입니다. 문자열 길이가 최대 10이므로, 가능한 조합의 수가 10!로 계산되지만, 인접 문자가 같은 경우를 제외하기 때문에 실제 계산량은 줄어듭니다.

---

## 코드
```python
s = list(input().rstrip())
l = len(s)
dic = {}

for i in s:
    dic[i] = dic.get(i, 0) + 1

cnt = 0
def back(dic, before, use):
    global cnt
    if use == l:
        cnt += 1
        return
    
    for k, v in dic.items():
        if v > 0 and k != before:
            dic[k] -= 1
            back(dic, k, use + 1)
            dic[k] += 1

back(dic, None, 0)
print(cnt)

```