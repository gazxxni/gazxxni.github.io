---
layout: post
title: "[백준] 1342번 행운의 문자열 (Python)"
date: 2025-12-07
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1342", 브루트포스 알고리즘, 집합과 맵, 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/1342](https://www.acmicpc.net/problem/1342)

---

## 문제
민식이와 준영이는 자기 방에서 문자열을 공부하고 있다. 민식이가 말하길 인접해 있는 모든 문자가 같지 않은 문자열을 행운의 문자열이라고 한다고 한다. 준영이는 문자열 S를 분석하기 시작했다. 준영이는 문자열 S에 나오는 문자를 재배치하면 서로 다른 행운의 문자열이 몇 개 나오는지 궁금해졌다. 만약 원래 문자열 S도 행운의 문자열이라면 그것도 개수에 포함한다.

---

## 입력
첫째 줄에 문자열 S가 주어진다. S의 길이는 최대 10이고, 알파벳 소문자로만 이루어져 있다.

---

## 출력
첫째 줄에 위치를 재배치해서 얻은 서로 다른 행운의 문자열의 개수를 출력한다.

---

## 성능 요약
메모리: 113412 KB, 시간: 1512 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 문자열에서 인접한 문자가 같지 않도록 재배치할 수 있는 모든 경우의 수를 세는 것입니다. 백트래킹을 사용하여 각 문자를 선택할 때 이전에 선택한 문자와 다른 문자를 선택하도록 하여 조건을 만족하는 문자열을 생성합니다. 또한, 중복된 문자로 인해 발생할 수 있는 중복 문자열을 방지하기 위해 각 문자의 개수를 관리하는 딕셔너리를 사용합니다.

### 동작 과정
1. **입력**: 문자열 S를 입력받습니다. 예를 들어, "aabb"라는 문자열이 주어진다고 가정합니다.
2. **문자 빈도 계산**: 각 문자의 빈도를 계산하여 딕셔너리에 저장합니다. 여기서는 {'a': 2, 'b': 2}처럼 됩니다.
3. **백트래킹 함수 호출**: 초기 호출 시 이전 문자(`before`)는 None으로 설정하고 사용한 문자 수(`use`)는 0으로 설정합니다.
4. **문자 선택**: 백트래킹 함수 안에서 각 문자를 순회하며, 현재 문자의 개수가 0보다 크고 이전 문자와 다를 경우 해당 문자를 선택합니다.
5. **재귀 호출**: 선택한 문자의 개수를 줄이고, 다음 단계로 재귀 호출합니다. 모든 문자를 사용했을 경우 카운트를 증가시킵니다.
6. **원상 복구**: 재귀가 종료된 후 선택한 문자의 개수를 다시 증가시켜 다음 경우의 수를 탐색합니다.
7. **결과 출력**: 모든 가능한 행운의 문자열을 생성한 후 그 개수를 출력합니다.

예를 들어, "aabb"의 경우:
- 첫 번째 문자로 'a'를 선택한 후, 이어서 'b'를 선택하면 "abab", "aabb" 등이 생성됩니다.
- 두 번째 문자로 'b'를 선택하면 "baba", "baab" 등이 생성됩니다.
- 이 과정을 반복하여 모든 조합을 탐색합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(N!)입니다. 여기서 N은 문자열의 길이입니다. 이는 모든 가능한 순열을 생성해야 하기 때문이며, 문자열 길이가 최대 10인 경우에는 충분히 계산할 수 있는 범위입니다.

---

## 코드
```python
s = list(input().rstrip())
l = len(s)
dic = {}

for i in s:
    dic[i] = dic.get(i, 0) + 1

cnt = 0
def back(dic, before, use):
    global cnt
    if use == l:
        cnt += 1
        return
    
    for k, v in dic.items():
        if v > 0 and k != before:
            dic[k] -= 1
            back(dic, k, use + 1)
            dic[k] += 1

back(dic, None, 0)
print(cnt)

```