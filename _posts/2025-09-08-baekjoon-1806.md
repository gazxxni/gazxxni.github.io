---
layout: post
title: "[백준] 1806번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1806"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1806](https://www.acmicpc.net/problem/1806)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 "투 포인터" 기법을 사용하여 배열의 부분합을 효율적으로 계산하는 것입니다. 한 포인터(`ed`)는 배열을 순회하며 현재까지의 합(`total`)을 구하고, 다른 포인터(`st`)는 현재 합이 목표값(`s`) 이상이 될 때까지 증가시켜 최단 부분 배열의 길이를 갱신합니다.

### 동작 과정
1. 입력으로 `n`(배열의 길이)과 `s`(목표 합)를 받고, 배열 `arr`를 초기화합니다.
2. 두 개의 포인터(`st`와 `ed`)를 사용하여 `ed`를 0부터 `n-1`까지 순회합니다.
   - `ed`가 가리키는 위치의 값을 `total`에 더합니다.
   - `total`이 `s` 이상이 될 때까지 `st`를 증가시켜가며 부분합에서 `arr[st]`를 빼고, 이때의 부분 배열 길이를 갱신합니다.
3. `ans`에 최단 길이를 저장하고, 최종적으로 `ans`가 갱신되지 않았다면 0을 출력하고, 그렇지 않으면 `ans`를 출력합니다.

#### 예시 입력
```
10 15
1 2 3 4 5 6 7 8 9 10
```
- n=10, s=15, arr=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
- `ed`가 0부터 9까지 증가하면서 `total`을 계산
- `total`이 15가 되는 순간을 찾아 `st`를 증가시키며 부분 배열의 길이를 체크
- 최종적으로 `ans`에 최단 길이가 저장되어 출력됨.

### 시간 복잡도
O(n)  
(각 포인터(`st`와 `ed`)는 배열을 한 번씩만 순회하므로, 전체 시간 복잡도는 배열의 길이에 비례합니다.)

---

## 코드
```python
import sys
input = sys.stdin.readline

n, s = map(int, input().split())
arr = list(map(int, input().split()))

st = 0
total = 0
ans = 1e9

for ed in range(n):
    total += arr[ed]

    while total >= s:
        ans = min(ans, ed - st + 1)
        total -= arr[st]
        st += 1

print(ans if ans != 1e9 else 0)

```