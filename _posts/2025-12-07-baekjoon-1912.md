---
layout: post
title: "[백준] 1912번 연속합 (Python)"
date: 2025-12-07
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, 1912, 다이나믹 프로그래밍, 최대 부분 배열 문제]
---

## 문제 링크
[https://www.acmicpc.net/problem/1912](https://www.acmicpc.net/problem/1912)

---

## 문제
n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.

예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.

---

## 입력
첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다. 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.

---

## 출력
첫째 줄에 답을 출력한다.

---

## 성능 요약
메모리: 121976 KB, 시간: 104 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 동적 프로그래밍을 이용하여 해결할 수 있습니다. 주어진 수열에서 연속된 부분 배열의 최대 합을 찾기 위해, 현재 원소를 포함하는 최대 합을 이전 원소의 최대 합과 비교하여 갱신합니다. 이를 통해 부분 배열의 합을 누적적으로 계산하여 최종적으로 최대 합을 도출합니다.

### 동작 과정
입력으로 수열이 주어질 때, 이를 단계별로 계산해보면 다음과 같습니다.

1. **입력 예시**: `n = 10`, `arr = [10, -4, 3, 1, 5, 6, -35, 12, 21, -1]`
2. **초기화**:
   - `dp[0] = arr[0] = 10`, `ans = 10`
3. **1번째 원소 (-4)**:
   - `dp[1] = max(arr[1], dp[0] + arr[1]) = max(-4, 10 - 4) = 6`
   - `ans = max(ans, dp[1]) = max(10, 6) = 10`
4. **2번째 원소 (3)**:
   - `dp[2] = max(arr[2], dp[1] + arr[2]) = max(3, 6 + 3) = 9`
   - `ans = max(ans, dp[2]) = max(10, 9) = 10`
5. **3번째 원소 (1)**:
   - `dp[3] = max(arr[3], dp[2] + arr[3]) = max(1, 9 + 1) = 10`
   - `ans = max(ans, dp[3]) = max(10, 10) = 10`
6. **4번째 원소 (5)**:
   - `dp[4] = max(arr[4], dp[3] + arr[4]) = max(5, 10 + 5) = 15`
   - `ans = max(ans, dp[4]) = max(10, 15) = 15`
7. **5번째 원소 (6)**:
   - `dp[5] = max(arr[5], dp[4] + arr[5]) = max(6, 15 + 6) = 21`
   - `ans = max(ans, dp[5]) = max(15, 21) = 21`
8. **6번째 원소 (-35)**:
   - `dp[6] = max(arr[6], dp[5] + arr[6]) = max(-35, 21 - 35) = -14`
   - `ans = max(ans, dp[6]) = max(21, -14) = 21`
9. **7번째 원소 (12)**:
   - `dp[7] = max(arr[7], dp[6] + arr[7]) = max(12, -14 + 12) = 12`
   - `ans = max(ans, dp[7]) = max(21, 12) = 21`
10. **8번째 원소 (21)**:
    - `dp[8] = max(arr[8], dp[7] + arr[8]) = max(21, 12 + 21) = 33`
    - `ans = max(ans, dp[8]) = max(21, 33) = 33`
11. **9번째 원소 (-1)**:
    - `dp[9] = max(arr[9], dp[8] + arr[9]) = max(-1, 33 - 1) = 32`
    - `ans = max(ans, dp[9]) = max(33, 32) = 33`

최종적으로 `ans`는 33이 되어, 연속합의 최대값은 33입니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n)입니다. n개의 원소에 대해 한 번씩만 계산하기 때문에, 입력 크기에 비례하여 선형적으로 증가합니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
arr = list(map(int, input().split()))

dp = [0] * (n + 1)
dp[0] = arr[0]
ans = arr[0]

for i in range(1, n):
    dp[i] = max(arr[i], dp[i - 1] + arr[i])
    ans = max(ans, dp[i])


print(ans)
```