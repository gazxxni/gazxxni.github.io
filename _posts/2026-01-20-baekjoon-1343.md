---
layout: post
title: "[백준] 1343번 폴리오미노 (Python)"
date: 2026-01-20
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1343", 구현, 그리디 알고리즘, 문자열]
---

## 문제 링크
[https://www.acmicpc.net/problem/1343](https://www.acmicpc.net/problem/1343)

---

## 문제
민식이는 다음과 같은 폴리오미노 2개를 무한개만큼 가지고 있다. AAAA와 BB

이제 '.'와 'X'로 이루어진 보드판이 주어졌을 때, 민식이는 겹침없이 'X'를 모두 폴리오미노로 덮으려고 한다. 이때, '.'는 폴리오미노로 덮으면 안 된다.

폴리오미노로 모두 덮은 보드판을 출력하는 프로그램을 작성하시오.

---

## 입력
첫째 줄에 보드판이 주어진다. 보드판의 크기는 최대 50이다.

---

## 출력
첫째 줄에 사전순으로 가장 앞서는 답을 출력한다. 만약 덮을 수 없으면 -1을 출력한다.

---

## 성능 요약
메모리: 108384 KB, 시간: 88 ms

---

## 풀이

### 풀이 핵심 로직
문제는 주어진 문자열에서 'X'를 가능한 한 폴리오미노로 덮는 것입니다. 'X'는 'AAAA'와 'BB'로 덮을 수 있으며, 우리는 사전순으로 가장 앞서는 결과를 원하기 때문에 'AAAA'를 우선적으로 사용하는 것이 중요합니다. 만약 'X'가 홀수 개 존재한다면 덮을 수 없으므로 -1을 출력해야 합니다.

### 동작 과정
1. 입력 문자열을 읽는다. 예를 들어, `board = "XX..XX.X..X"`라고 가정하자.
2. 문자열을 처음부터 끝까지 탐색하면서 아래의 조건을 검사한다:
   - 4개의 연속된 'X'가 있으면 이를 'AAAA'로 대체한다.
   - 2개의 연속된 'X'가 있으면 이를 'BB'로 대체한다.
   - 만약 단독으로 'X'가 남아있으면 폴리오미노로 덮을 수 없으므로 -1을 반환한다.
   - '.' 문자는 유지한다.
3. 탐색이 끝나면 새로운 문자열을 출력한다. 예를 들어, 결과는 `"BB..BB.X..X"`가 된다.

입력 예시:
```
XX..XX.X..X
```
출력 예시:
```
BB..BB.X..X
```

### 시간 복잡도
이 알고리즘은 문자열을 한 번만 순회하므로 시간 복잡도는 O(n)입니다. 여기서 n은 문자열의 길이(최대 50)입니다.

---

## 코드
```python
board = input()

idx = 0
newboard = ''

while idx<len(board):
    if board[idx:idx+4]=='XXXX':
        newboard += 'AAAA'
        idx += 4
    elif board[idx:idx+2]=='XX':
        newboard +='BB'
        idx += 2
    elif board[idx]=='X':
        newboard = -1
        break
    else :
        newboard += board[idx]
        idx += 1

print(newboard)
```