---
layout: post
title: "[백준] 10815번 (Python)"
date: 2025-10-06
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "10815"]
---

## 문제 링크
[https://www.acmicpc.net/problem/10815](https://www.acmicpc.net/problem/10815)

---

## 풀이

### 풀이 핵심 로직
이 문제는 두 개의 리스트에서 특정 값의 존재 여부를 확인하는 문제입니다. 주어진 첫 번째 리스트(`arr`)의 요소들을 해시 맵인 딕셔너리(`dic`)에 저장하여 빠른 조회를 가능하게 하고, 두 번째 리스트(`brr`)의 각 요소가 딕셔너리에 존재하는지 확인하여 결과를 리스트(`ans`)에 저장합니다.

### 동작 과정
1. 첫 번째 줄에서 정수 `n`을 입력받고, 두 번째 줄에서 `n`개의 정수를 포함하는 리스트 `arr`을 입력받습니다.
   - 예시 입력: 
     ```
     5
     4 1 5 2 3
     ```
2. 세 번째 줄에서 정수 `m`을 입력받고, 네 번째 줄에서 `m`개의 정수를 포함하는 리스트 `brr`을 입력받습니다.
   - 예시 입력: 
     ```
     5
     1 3 7 9 5
     ```
3. `arr`의 각 요소를 딕셔너리 `dic`의 키로 추가합니다. 이때 각 키의 값은 0으로 초기화합니다.
   - 결과: `dic` = {4: 0, 1: 0, 5: 0, 2: 0, 3: 0}
4. `brr`의 각 요소에 대해, 그 값이 딕셔너리 `dic`에 존재하는지 확인합니다. 존재하면 1을, 존재하지 않으면 0을 `ans` 리스트에 추가합니다.
   - `brr`에 대한 확인:
     - 1 → 존재 → ans에 1 추가
     - 3 → 존재 → ans에 1 추가
     - 7 → 불존재 → ans에 0 추가
     - 9 → 불존재 → ans에 0 추가
     - 5 → 존재 → ans에 1 추가
   - 최종 `ans` = [1, 1, 0, 0, 1]
5. 마지막으로 `ans` 리스트를 출력합니다.
   - 출력: `1 1 0 0 1`

### 시간 복잡도
- 리스트 `arr`를 딕셔너리에 저장하는 과정이 O(n)이고, 리스트 `brr`의 각 요소를 조회하는 과정이 O(m)입니다. 따라서 전체 시간 복잡도는 O(n + m)입니다.

---

## 코드
```python
n = int(input())
arr = list(map(int, input().split()))
m = int(input())
brr = list(map(int, input().split()))

dic = {}
for i in range(len(arr)):
    dic[arr[i]] = 0

ans = []
for i in range(m):
    if brr[i] not in dic:
        ans.append(0)
    else:
        ans.append(1)
        
print(*ans)
```