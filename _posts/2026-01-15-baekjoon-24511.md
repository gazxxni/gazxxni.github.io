---
layout: post
title: "[백준] 24511번 queuestack (Python)"
date: 2026-01-15
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "24511", 자료 구조, 스택, 덱, 큐]
---

## 문제 링크
[https://www.acmicpc.net/problem/24511](https://www.acmicpc.net/problem/24511)

---

## 문제
한가롭게 방학에 놀고 있던 도현이는 갑자기 재밌는 자료구조를 생각해냈다. 그 자료구조의 이름은 queuestack이다.

queuestack의 구조는 다음과 같다. 1$1$번, 2$2$번, ... , N$N$번의 자료구조(queue 혹은 stack)가 나열되어있으며, 각각의 자료구조에는 한 개의 원소가 들어있다.

queuestack의 작동은 다음과 같다.


	 x0$x_0$을 입력받는다.
	 x0$x_0$을 1$1$번 자료구조에 삽입한 뒤 1$1$번 자료구조에서 원소를 pop한다. 그때 pop된 원소를 x1$x_1$이라 한다.
	 x1$x_1$을 2$2$번 자료구조에 삽입한 뒤 2$2$번 자료구조에서 원소를 pop한다. 그때 pop된 원소를 x2$x_2$이라 한다.
	...
	 xN−1$x_{N-1}$을 N$N$번 자료구조에 삽입한 뒤 N$N$번 자료구조에서 원소를 pop한다. 그때 pop된 원소를 xN$x_N$이라 한다.
	 xN$x_N$을 리턴한다.


도현이는 길이 M$M$의 수열 C$C$를 가져와서 수열의 원소를 앞에서부터 차례대로 queuestack에 삽입할 것이다. 이전에 삽입한 결과는 남아 있다. (예제 1$1$ 참고)

queuestack에 넣을 원소들이 주어졌을 때, 해당 원소를 넣은 리턴값을 출력하는 프로그램을 작성해보자.

---

## 입력
첫째 줄에 queuestack을 구성하는 자료구조의 개수 N$N$이 주어진다. (1≤N≤100000$1 \leq N \leq 100\,000$)

둘째 줄에 길이 N$N$의 수열 A$A$가 주어진다. i$i$번 자료구조가 큐라면 Ai=0$A_i = 0$, 스택이라면 Ai=1$A_i = 1$이다.

셋째 줄에 길이 N$N$의 수열 B$B$가 주어진다. Bi$B_i$는 i$i$번 자료구조에 들어 있는 원소이다. (1≤Bi≤1000000000$1 \leq B_i \leq 1\,000\,000\,000$)

넷째 줄에 삽입할 수열의 길이 M$M$이 주어진다. (1≤M≤100000$1 \leq M \leq 100\,000$)

다섯째 줄에 queuestack에 삽입할 원소를 담고 있는 길이 M$M$의 수열 C$C$가 주어진다. (1≤Ci≤1000000000$1 \leq C_i \leq 1\,000\,000\,000$)

입력으로 주어지는 모든 수는 정수이다.

---

## 출력
수열 C$C$의 원소를 차례대로 queuestack에 삽입했을 때의 리턴값을 공백으로 구분하여 출력한다.

---

## 성능 요약
메모리: 141740 KB, 시간: 188 ms

---

## 풀이

### 풀이 핵심 로직
문제는 여러 개의 자료구조(큐 또는 스택)를 사용하여 주어진 수열을 처리하는 것입니다. 각 자료구조에 대해 큐인 경우 마지막에 삽입된 원소를, 스택인 경우 첫 번째 삽입된 원소를 꺼내는 방식으로 작동합니다. 주어진 입력 수열을 차례로 queuestack에 삽입한 후, 각 단계에서 pop된 결과를 출력합니다.

### 동작 과정
1. **입력 예시**:
   ```
   3
   0 1 0
   1 2 3
   5
   4 5 6 7 8
   ```
   - N=3, 자료구조 타입은 [큐(0), 스택(1), 큐(0)], 초기 원소는 [1, 2, 3], 삽입할 원소는 [4, 5, 6, 7, 8]입니다.

2. **초기 상태**:
   - 큐와 스택을 조합한 queuestack 생성: 각 자료구조 초기 상태는 다음과 같습니다.
     - 1번 (큐): [1]
     - 2번 (스택): [2]
     - 3번 (큐): [3]

3. **처리 과정**:
   - C[0] = 4를 queuestack에 삽입:
     - 1번 자료구조(큐)에 4를 삽입 후 pop -> pop된 원소: 1
     - 2번 자료구조(스택)에 1을 삽입 후 pop -> pop된 원소: 1
     - 3번 자료구조(큐)에 1을 삽입 후 pop -> pop된 원소: 3
     - 결과: 3
   - C[1] = 5를 queuestack에 삽입:
     - 1번 자료구조(큐)에 5를 삽입 후 pop -> pop된 원소: 1
     - 2번 자료구조(스택)에 1을 삽입 후 pop -> pop된 원소: 1
     - 3번 자료구조(큐)에 1을 삽입 후 pop -> pop된 원소: 1
     - 결과: 1
   - C[2] = 6를 queuestack에 삽입:
     - 1번 자료구조(큐)에 6을 삽입 후 pop -> pop된 원소: 5
     - 2번 자료구조(스택)에 5를 삽입 후 pop -> pop된 원소: 2
     - 3번 자료구조(큐)에 2를 삽입 후 pop -> pop된 원소: 2
     - 결과: 2
   - C[3] = 7를 queuestack에 삽입:
     - 1번 자료구조(큐)에 7을 삽입 후 pop -> pop된 원소: 6
     - 2번 자료구조(스택)에 6을 삽입 후 pop -> pop된 원소: 6
     - 3번 자료구조(큐)에 6을 삽입 후 pop -> pop된 원소: 3
     - 결과: 3
   - C[4] = 8를 queuestack에 삽입:
     - 1번 자료구조(큐)에 8을 삽입 후 pop -> pop된 원소: 6
     - 2번 자료구조(스택)에 6을 삽입 후 pop -> pop된 원소: 6
     - 3번 자료구조(큐)에 6을 삽입 후 pop -> pop된 원소: 6
     - 결과: 6

4. **최종 출력**: 
   ```
   3 1 2 3 6
   ```

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(M + N)입니다. M은 삽입할 원소의 개수, N은 queuestack을 구성하는 자료구조의 개수입니다. 각 원소에 대해 큐와 스택의 push/pop 연산이 상수 시간에 이루어지므로 이와 같은 복잡도를 가집니다.

---

## 코드
```python
import sys
from collections import deque
input = sys.stdin.readline

q = deque()
n = int(input())
arr = list(map(int, input().split()))
brr = list(map(int, input().split()))
m = int(input())
crr = list(map(int, input().split()))

for i in range(n):
    if arr[i] == 0:
        q.append(brr[i])
        
ans = []
for i in range(m):
    q.appendleft(crr[i])
    ans.append(q.pop())
    
print(*ans)
```