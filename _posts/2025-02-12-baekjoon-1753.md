---
layout: post
title: "[백준] 1753번 (Python)"
date: 2025-02-12
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1753"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1753](https://www.acmicpc.net/problem/1753)

---

## 풀이

### 풀이 핵심 로직
이 문제는 다익스트라 알고리즘을 사용하여 단일 출발지 최단 경로를 찾는 문제입니다. 주어진 그래프에서 시작 정점에서 다른 모든 정점까지의 최단 거리를 계산하며, 우선순위 큐(힙)를 이용하여 가장 짧은 경로를 효율적으로 탐색합니다.

### 동작 과정
1. **입력받기**: 정점의 수 V와 간선의 수 E를 입력받고, 시작 정점 s를 입력받습니다.
2. **그래프 초기화**: 그래프를 인접 리스트 형식으로 초기화하고, 모든 정점까지의 거리를 무한대(INF)로 초기화합니다.
3. **간선 정보 입력**: E개의 간선 정보를 입력받아 그래프에 추가합니다. 각 간선은 (목적지, 가중치)의 형태로 저장됩니다.
4. **다익스트라 알고리즘 실행**: 시작 정점 s에서부터 다익스트라 알고리즘을 실행합니다. 
   - 큐에 시작 정점과 거리를 0으로 설정하여 넣고, 큐가 비어있지 않은 동안 반복합니다.
   - 큐에서 가장 거리 값이 작은 노드를 꺼내고, 해당 노드와 연결된 인접 노드를 확인합니다.
   - 인접 노드로 가는 새로운 거리가 기존 거리보다 작으면 거리 값을 갱신하고, 해당 노드를 큐에 추가합니다.
5. **결과 출력**: 최단 거리가 INF인 경우 "INF"를 출력하고, 그렇지 않은 경우 최단 거리를 출력합니다.

예시 입력:
```
5 6
1
1 2 2
1 3 3
2 3 1
2 4 1
3 4 5
4 5 1
```
- 위 입력에서는 5개의 정점과 6개의 간선이 주어지고, 시작 정점은 1입니다. 
- 다익스트라 알고리즘을 통해 1에서 다른 정점까지의 최단 거리를 계산한 후, 각 정점의 최단 거리를 출력하게 됩니다.

### 시간 복잡도
다익스트라 알고리즘의 시간 복잡도는 O((V + E) log V)입니다. 여기서 V는 정점의 수, E는 간선의 수입니다. 힙을 사용하여 우선순위 큐를 구현했기 때문에 큐의 삽입 및 삭제 연산에서 로그 시간이 소요됩니다.

---

## 코드
```python
import sys
import heapq

input = sys.stdin.readline
INF = int(1e9)
def dijkstra(start):
    q= []
    heapq.heappush(q,(0,start))
    distance[start] = 0

    while q:
        dist, now = heapq.heappop(q)

        if distance[now] < dist:
            continue

        #현재 노드와 연결된 인접 노드 확인
        for i in graph[now]:
            cost =dist+ i[1]
            if cost < distance[i[0]] :
                distance[i[0]] = cost
                heapq.heappush(q,(cost,i[0]))


V, E = map(int,input().split())
s = int(input()) 

graph = [[] for _ in range(V+1)]
distance = [INF] * (V+1) 

for _ in range(E):
    u,v,w = map(int,input().split())
    graph[u].append((v,w))

dijkstra(s)

for i in range(1,V+1):
    if distance[i] == INF:
        print("INF")
    else:
        print(distance[i])
```