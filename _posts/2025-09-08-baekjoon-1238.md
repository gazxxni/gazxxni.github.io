---
layout: post
title: "[백준] 1238번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1238"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1238](https://www.acmicpc.net/problem/1238)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 특정 노드(x)에서 모든 다른 노드까지의 최단 경로를 계산한 후, 다시 모든 노드에서 x로 가는 최단 경로를 계산하여 각 노드에서 x를 거쳐 오는 최대 시간을 찾는 것입니다. 이를 통해 x를 경유하는 모든 경로의 최대 시간을 구할 수 있습니다.

### 동작 과정
1. **입력 읽기**: 각 노드와 간선 정보를 읽어들여, 두 개의 인접 리스트(정방향 `arr`과 역방향 `brr`)를 생성합니다.
2. **다익스트라 알고리즘**: 
   - 첫 번째로 `dijk(x, arr, n)`를 호출하여 x에서 각 노드로 가는 최단 거리를 계산합니다. 이를 `fromX`에 저장합니다.
   - 두 번째로 `dijk(x, brr, n)`을 호출하여 각 노드에서 x로 가는 최단 거리를 계산합니다. 이를 `toX`에 저장합니다.
3. **최대 시간 계산**: 모든 노드(i)에 대해 `fromX[i] + toX[i]`를 계산하여 최대 값을 `max_t`에 저장합니다. 이는 각 노드에서 x를 경유하는 최소 시간을 구하는 과정입니다.
4. **결과 출력**: 최종적으로 최대 시간을 출력합니다.

예시 입력:
```
4 8 2
1 2 4
1 3 2
2 3 5
2 4 10
3 4 3
4 1 7
4 3 4
3 2 1
```
- n=4(노드 수), m=8(간선 수), x=2(목적지 노드)
- 그래프를 구성한 후 다익스트라를 통해 각 노드에서 x로 가는 거리와 x에서 각 노드로 가는 거리를 계산.
- 최종적으로 `max_t`를 계산하여 출력.

### 시간 복잡도
다익스트라 알고리즘을 사용하기 때문에, 전체 시간 복잡도는 O((n + m) log n)입니다. 여기서 n은 노드 수, m은 간선 수입니다. 두 번의 다익스트라 호출이 있으므로 이 복잡도가 두 배가 되지만, 각 호출은 독립적이므로 여전히 O((n + m) log n)으로 요약됩니다.

---

## 코드
```python
import sys
import heapq
input = sys.stdin.readline
INF = int(1e9)

n, m, x = map(int, input().split())
arr = [[] for _ in range(n + 1)]
brr = [[] for _ in range(n + 1)]

for _ in range(m):
    a, b, t = map(int, input().split())
    arr[a].append((b, t))
    brr[b].append((a, t))

def dijk(st, arr, n):
    q = []
    heapq.heappush(q, (0, st))
    dist = [INF] * (n + 1)
    dist[st] = 0

    while q:
        d, now = heapq.heappop(q)

        if dist[now] < d:
            continue

        for i in arr[now]:
            cost = d + i[1]
            if cost < dist[i[0]]:
                dist[i[0]] = cost
                heapq.heappush(q, (cost, i[0]))

    return dist 

# 역방향 그래프를 구성해 총 2번의 다익스트라를 수행    
fromX = dijk(x, arr, n)  # x에서 각 노드로 가는 최단거리
toX = dijk(x, brr, n)  # 각 노드에서 x로 가는 최단거리

max_t = 0
for i in range(1, n + 1):
    max_t = max(max_t, fromX[i] + toX[i])

print(max_t)
```