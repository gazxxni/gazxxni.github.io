---
layout: post
title: "[백준] 12908번 텔레포트 3 (Python)"
date: 2025-12-09
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "12908", 그래프 이론, 브루트포스 알고리즘, 최단 경로, 플로이드–워셜]
---

## 문제 링크
[https://www.acmicpc.net/problem/12908](https://www.acmicpc.net/problem/12908)

---

## 문제
수빈이는 크기가 무한대인 격자판 위에 살고 있다. 격자판의 각 점은 두 정수의 쌍 (x, y)로 나타낼 수 있다.

제일 처음에 수빈이의 위치는 (xs, ys)이고, 집이 위치한 (xe, ye)로 이동하려고 한다.

수빈이는 두 가지 방법으로 이동할 수 있다. 첫 번째 방법은 점프를 하는 것이다. 예를 들어 (x, y)에 있는 경우에 (x+1, y), (x-1, y), (x, y+1), (x, y-1)로 이동할 수 있다. 점프는 1초가 걸린다.

두 번째 방법은 텔레포트를 사용하는 것이다. 텔레포트를 할 수 있는 방법은 총 세 가지가 있으며, 미리 정해져 있다. 텔레포트는 네 좌표 (x1, y1), (x2, y2)로 나타낼 수 있으며, (x1, y1)에서 (x2, y2)로 또는 (x2, y2)에서 (x1, y1)로 이동할 수 있다는 것이다. 텔레포트는 10초가 걸린다.

수빈이의 위치와 집의 위치가 주어졌을 때, 집에 가는 가장 빠른 시간을 구하는 프로그램을 작성하시오.

---

## 입력
첫째 줄에 xs와 ys가, 둘째 줄에 xe, ye가 주어진다. (0 ≤ xs, ys, xe, ye ≤ 1,000,000,000)

셋째 줄부터 세 개의 줄에는 텔레포트의 정보 x1, y1, x2, y2가 주어진다. (0 ≤ x1, y1, x2, y2 ≤ 1,000,000,000)

입력으로 주어지는 모든 좌표 8개는 서로 다르다.

---

## 출력
수빈이가 집에 가는 가장 빠른 시간을 출력한다.

---

## 성능 요약
메모리: 111284 KB, 시간: 120 ms

---

## 풀이

### 풀이 핵심 로직
수빈이는 점프와 텔레포트를 활용하여 집까지 가는 가장 빠른 시간을 찾기 위해 다익스트라 알고리즘을 사용합니다. 점프는 인접한 네 방향으로 1초 소요되며, 텔레포트는 미리 정해진 두 지점 간에 10초 소요됩니다. 이를 통해 모든 가능 경로를 탐색하여 최소 시간을 계산합니다.

### 동작 과정
1. **입력 받기**: 수빈이의 시작 위치 `(xs, ys)`와 집의 위치 `(xe, ye)`를 입력받고, 세 개의 텔레포트 정보를 입력받습니다.
2. **초기값 설정**: 시작점에서 집까지의 기본 거리(`min_cost`)를 점프만으로 계산합니다. 이 값은 수빈이가 점프만으로 이동했을 경우의 거리입니다.
3. **다익스트라 알고리즘 초기화**: 텔레포트 지점을 포함한 모든 지점에 대해 최단 거리를 무한대로 초기화하고, 시작점의 거리는 0으로 설정합니다. 우선순위 큐에 시작점을 추가합니다.
4. **우선순위 큐 처리**:
    - 큐에서 현재 위치를 꺼내고, 해당 위치에서 집까지의 직선 거리(`cost_via_current`)를 계산하여 최소 거리(`min_cost`)를 갱신합니다.
    - 현재 위치에서 텔레포트를 사용할 수 있는 경우, 텔레포트 비용을 추가하여 다음 위치를 큐에 추가합니다.
    - 현재 위치에서 모든 텔레포트 지점까지의 점프 비용을 계산하여 큐에 추가합니다.
5. **출력**: 모든 가능한 경로를 탐색한 후, 최종적으로 계산된 `min_cost`를 출력합니다.

#### 예시 입력
```
0 0
3 3
1 1 2 2
1 2 2 1
0 1 1 0
```

#### 예시 설명
- 시작 위치는 `(0, 0)`, 집은 `(3, 3)`입니다.
- 첫 번째 텔레포트는 `(1, 1)`과 `(2, 2)` 간의 이동입니다.
- 수빈이는 점프를 통해 `(1, 1)`에 도착한 후 텔레포트를 사용하여 `(2, 2)`로 이동할 수 있습니다. 이후 점프를 통해 `(3, 3)`으로 이동하면 됩니다.
- 최단 경로를 찾아보면, 점프와 텔레포트를 조합하여 6초에 도달할 수 있음이 확인됩니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O((N + E) log N)입니다. 여기서 N은 텔레포트 지점의 수 (최대 5개), E는 각 지점 간의 가능한 경로 수입니다. 최악의 경우, 각 지점에서 점프와 텔레포트를 고려해야 하므로 효율적으로 최단 경로를 찾아낼 수 있습니다.

---

## 코드
```python
import sys, heapq
from collections import defaultdict
'''
BFS로 풀면 모든 지점을 다 돌아야해서 시간초과
-> 다익스트라로 텔레포트 사용 구간만 검사, 텔레포트 안 쓰면 그냥 긴 거리가 답
'''
input = sys.stdin.readline

xs, ys = map(int, input().split())
xe, ye = map(int, input().split())

start_node = (xs, ys)
end_node = (xe, ye)

tp_dic = defaultdict(list)
tp_node = set()

for _ in range(3):
    x1, y1, x2, y2 = map(int, input().split())
    node1 = (x1, y1)
    node2 = (x2, y2)
    
    tp_node.add(node1)
    tp_node.add(node2)

    tp_dic[node1].append((node2, 10))
    tp_dic[node2].append((node1, 10))

key_nodes = list(tp_node)
key_nodes.append(start_node)

distances = {node: float('inf') for node in key_nodes}
distances[start_node] = 0

pq = [(0, start_node)]

# 시작점에서 도착점까지 가는 비용 (이게 기본 답)
min_cost = abs(xs - xe) + abs(ys - ye)

while pq:
    current_cost, current_node = heapq.heappop(pq)

    if current_cost > distances[current_node]:
        continue

    # 현재 위치에서 도착점까지 비용
    # (현재까지 비용 + 지금 위치에서 도착점까지 걷는 비용)
    cost_via_current = current_cost + abs(current_node[0] - end_node[0]) + abs(current_node[1] - end_node[1])
    min_cost = min(min_cost, cost_via_current)
    
    # 텔레포트 
    if current_node in tp_dic:
        for next_node, tele_cost in tp_dic[current_node]:
            new_cost = current_cost + tele_cost
            if new_cost < distances[next_node]:
                distances[next_node] = new_cost
                heapq.heappush(pq, (new_cost, next_node))

    # 현재 위치에서 모든 텔레포트 지점까지 비용 계산
    for next_tp_node in tp_node:
        if current_node == next_tp_node:
            continue
            
        walk_cost = abs(current_node[0] - next_tp_node[0]) + abs(current_node[1] - next_tp_node[1])
        new_cost = current_cost + walk_cost
        
        if new_cost < distances[next_tp_node]:
            distances[next_tp_node] = new_cost
            heapq.heappush(pq, (new_cost, next_tp_node))

print(min_cost)
```