---
layout: post
title: "[백준] 13171번 A (Python)"
date: 2025-12-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "13171", 수학, 분할 정복을 이용한 거듭제곱]
---

## 문제 링크
[https://www.acmicpc.net/problem/13171](https://www.acmicpc.net/problem/13171)

---

## 문제
음이 아닌 두 정수 A, X 가 있을 때 AX을 구하는 방법을 생각해보자. 물론 이 수는 매우 클 수 있기에, 1,000,000,007 (= 109 + 7)로 나눈 나머지를 구할 것이다. a mod x를 a를 x로 나눴을 때의 나머지라고 표현하면,

(a × b) mod x = {(a mod x) × (b mod x)} mod x

가 성립하기 때문에, 어떤 두 정수를 1,000,000,007로 나눈 나머지만 알고 있어도 그 두 정수의 곱을 1,000,000,007로 나눈 나머지를 쉽게 계산할 수 있다.

본 문제로 돌아가서, 그렇다면 이제 A를 X 번 곱하면 AX을 쉽게 구할 수 있을 것 같아 보인다. 그러나 안타깝게도 X가 상당히 커서 64비트 정수의 범위에 있다면 A를 하나하나씩 곱하는 방식으로는 상상할 수 없을 정도로 긴 시간이 흘러야 답을 찾을 수 있을 것이다. 그래서 다음과 같이 곱셈의 횟수를 줄이는 방법을 사용한다.


	먼저 A1, A2, A4, A8, ...을 순서대로 계산한다. 각 수는 이전에 있는 수를 제곱함으로써 계산할 수 있고, 지수가 X 를 딱 넘지 않을 시점까지만 계산하면 충분할 것이다. X가 64비트 정수의 범위에 있으므로 계산하는 수는 64개보다 작을 것이다.
	이제 X 를 이진수로 나타내 보자. 예를 들어 X를 11로 두면, X = 11 = 1 + 2 + 8이다. 그런데 지수법칙에 의해, A11 = A1+2+8 = A1 × A2 × A8이 성립한다. 이를 통해 1번 단계에서 미리 계산해 놓았던 수 몇 개만 곱해서 AX 을 계산할 수 있음을 알 수 있다.


즉, 차례로 A를 곱해 나간다면 시간이 X에 비례하게 걸리겠지만, 위의 방법을 이용하면 시간이 log(X)에 비례하게 걸리게 된다. AX를 구하는 프로그램을 작성하라.

---

## 입력
첫 번째 줄에는 정수 A(1 ≤ A ≤ 1018)이 주어진다.

두 번째 줄에는 정수 X(1 ≤ X ≤ 1018)가 주어진다.

---

## 출력
AX을 출력한다. 이 수는 매우 커질 수 있으므로 1,000,000,007로 나눈 나머지를 출력해야 한다.

---

## 성능 요약
메모리: 108384 KB, 시간: 96 ms

---

## 풀이

### 풀이 핵심 로직
주어진 문제는 큰 수 A를 X번 곱한 결과를 1,000,000,007로 나눈 나머지를 구하는 것입니다. 직접적으로 곱셈을 수행하면 시간 복잡도가 O(X)로 비효율적이므로, 분할 정복을 이용한 거듭제곱 방법을 사용하여 O(log X) 시간에 결과를 구합니다. 이를 위해 이진수 표현을 활용하여 필요한 곱셈만 수행합니다.

### 동작 과정
예를 들어, A = 3, X = 11일 경우를 살펴보겠습니다.

1. **초기화**: 
   - `result`를 1로 초기화합니다.
   - A를 1,000,000,007로 나눈 나머지를 구합니다.

2. **이진수 표현**:
   - X = 11은 이진수로 1011입니다. 이는 1 + 2 + 8을 의미하며, A^11 = A^1 * A^2 * A^8이 됩니다.

3. **곱셈 및 제곱**:
   - 반복문을 통해 X가 0이 될 때까지 다음을 수행합니다:
     - X가 홀수일 경우(`if x % 2 == 1`), 현재의 A를 `result`에 곱합니다.
     - A를 제곱합니다(`a = (a * a) % MOD`).
     - X를 2로 나누어 비트 시프트합니다(`x //= 2`).

4. **최종 결과**:
   - 반복이 끝나면, `result`에는 A^X를 1,000,000,007로 나눈 나머지가 저장되어 있습니다.

예시 입력:
```
3
11
```
출력:
```
177147
```

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(log X)입니다. 이는 X의 이진 표현을 통해 곱셈을 줄이기 때문입니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

a = int(input())
x = int(input())
MOD = 1_000_000_007

result = 1
a %= MOD

while x > 0:
    if x % 2 == 1: 
       result = (result * a) % MOD
    a = (a * a) % MOD
    x //= 2
    
print(result % MOD)
```