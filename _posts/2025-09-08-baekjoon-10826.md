---
layout: post
title: "[백준] 10826번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "10826"]
---

## 문제 링크
[https://www.acmicpc.net/problem/10826](https://www.acmicpc.net/problem/10826)

---

## 풀이

### 풀이 핵심 로직
이 문제는 피보나치 수열과 유사한 형태로, n번째 수를 계산하기 위해 이전 두 수의 합을 사용합니다. n이 1일 때부터 4까지는 각각의 경우를 명시적으로 처리하고, 그 이상의 n에 대해서는 동적 프로그래밍을 이용하여 dp 배열을 채워나갑니다.

### 동작 과정
예를 들어 n = 6인 경우를 살펴보면:

1. `dp` 배열을 초기화합니다: `dp = [0] * (n + 1)` → `dp = [0, 1, 1, 2, 3, 0, 0]`
2. 5부터 n까지 반복문을 사용하여 dp 배열을 채웁니다:
   - `dp[5] = dp[4] + dp[3]` → `dp[5] = 3 + 2 = 5`
   - `dp[6] = dp[5] + dp[4]` → `dp[6] = 5 + 3 = 8`
3. 최종적으로 `print(dp[6])`를 통해 8을 출력합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n)입니다. n에 따라 dp 배열을 한 번 순회하며 값을 계산하기 때문입니다.

---

## 코드
```python
n = int(input())

if n <= 4:
    dp = [0] * 5
    dp[1] = 1
    dp[2] = 1
    dp[3] = 2
    dp[4] = 3
    print(dp[n])
    
else:
    dp = [0] * (n + 1)
    dp[1] = 1
    dp[2] = 1
    dp[3] = 2
    dp[4] = 3
    for i in range(5, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]
    
    print(dp[n])
```