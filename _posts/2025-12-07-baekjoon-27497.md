---
layout: post
title: "[백준] 27497번 알파벳 블록 (Python)"
date: 2025-12-07
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "27497", 자료 구조, 문자열, 스택, 덱]
---

## 문제 링크
[https://www.acmicpc.net/problem/27497](https://www.acmicpc.net/problem/27497)

---

## 문제
스타는 알파벳 블록을 일렬로 조립하여 문자열을 만드는 게임을 만들었다. 각 블록에는 문자 하나가 적혀 있으며 게임에는 각각 다음 기능을 수행하는 세 개의 버튼이 있다.


	문자열 맨 뒤에 블록 추가
	문자열 맨 앞에 블록 추가
	문자열을 구성하는 블록 중 가장 나중에 추가된 블록 제거


게임은 처음에 빈 문자열로 시작하며 빈 문자열일 때 문자열을 구성하는 블록 중 가장 나중에 추가된 블록을 제거하는 버튼을 누를 경우 아무런 동작도 하지 않는다. 버튼을 누른 횟수와 누른 버튼이 순서대로 주어질 때 완성된 문자열을 구하여라.

---

## 입력
첫째 줄에 버튼을 누른 횟수 N$N$이 주어진다. (1≤N≤1000000)$(1 \leq N \leq 1\,000\,000)$ 

둘째 줄부터 N$N$개의 줄에는 버튼을 누른 순서대로 누른 버튼에 대한 정보를 주며 아래와 같은 형식으로 주어진다.


	1 c : 문자열 맨 뒤에 c가 적힌 블록 추가
	2 c : 문자열 맨 앞에 c가 적힌 블록 추가
	3 : 문자열을 구성하는 블록 중 가장 나중에 추가된 블록 제거


c는 알파벳 대문자 또는 소문자로 주어진다.

---

## 출력
완성된 문자열을 출력한다. 완성된 문자열이 빈 문자열인 경우 0을 출력한다.

---

## 성능 요약
메모리: 234232 KB, 시간: 520 ms

---

## 풀이

### 풀이 핵심 로직
문자열을 구성하는 블록을 효율적으로 추가하고 제거하기 위해 `deque` 자료구조를 사용합니다. `deque`는 양쪽 끝에서의 삽입과 삭제가 O(1) 시간 복잡도로 가능하므로, 문자열의 맨 앞과 맨 뒤에 블록을 추가하고, 마지막으로 추가된 블록을 제거하는 연산을 효율적으로 수행할 수 있습니다.

### 동작 과정
1. **입력 예시**: N = 5
   ```
   1 A
   1 B
   2 C
   3
   3
   ```
   
2. **단계별 설명**:
   - **1 A**: 문자열 맨 뒤에 'A' 추가 → `deque` 상태: `['A']`
   - **1 B**: 문자열 맨 뒤에 'B' 추가 → `deque` 상태: `['A', 'B']`
   - **2 C**: 문자열 맨 앞에 'C' 추가 → `deque` 상태: `['C', 'A', 'B']`
   - **3**: 가장 나중에 추가된 블록 제거 ('B' 제거) → `deque` 상태: `['C', 'A']`
   - **3**: 가장 나중에 추가된 블록 제거 ('A' 제거) → `deque` 상태: `['C']`
   
3. 최종적으로 `deque`에 남은 블록을 문자열로 변환하여 출력하면 'C'가 됩니다.

### 시간 복잡도
전체 알고리즘의 시간 복잡도는 O(N)입니다. 각 버튼을 누르는 작업은 상수 시간에 수행되므로, 입력의 크기 N에 비례하여 처리됩니다.

---

## 코드
```python
import sys
from collections import deque
input = sys.stdin.readline

n = int(input())

q = deque()
log = []

for _ in range(n):
    a = input().split()
    n = int(a[0])
    
    if n == 1:
        c = a[1]
        q.append(c)
        log.append(1)
        
    elif n == 2:
        c = a[1]
        q.appendleft(c)
        log.append(2)
        
    else:
        if log:
            k = log.pop()
            
            if k == 1:
                q.pop()
            else:
                q.popleft()
    
    
if not q:
    print(0)
else:
    print(*q, sep='')
```