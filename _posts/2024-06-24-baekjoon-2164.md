---
layout: post
title: "[백준] 2164번 (Python)"
date: 2024-06-24
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2164"]
---

## 문제 링크
[https://www.acmicpc.net/problem/2164](https://www.acmicpc.net/problem/2164)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 주어진 카드의 수 `n`에 대해 특정 패턴을 이용해 마지막 남는 카드의 번호를 계산하는 것입니다. 카드를 두 개씩 버리는 과정을 반복하면서, 마지막 남는 카드의 번호는 `n`과 가장 가까운 2의 거듭제곱을 이용해 쉽게 구할 수 있습니다.

### 동작 과정
1. 처음에 `n`이 1 또는 2일 경우, 각각의 경우에 대해 바로 그 값을 출력합니다.
2. 변수 `idx`를 2로 초기화하고, 무한 루프를 시작합니다.
3. 매 루프마다 `idx`를 2배로 증가시킵니다.
4. `idx`가 `n` 이상이 되면, 마지막 남은 카드의 번호를 `(n - (idx // 2)) * 2`로 계산하여 출력하고 루프를 종료합니다.

**예시 입력:**
- 입력: `7`
- 진행 과정:
  - `idx`는 처음에 2로 시작하여 2, 4, 8로 증가합니다.
  - `idx`가 8이 되었을 때, `n`인 7과 비교하여 `idx`가 `n`을 초과하므로 `(7 - (8 // 2)) * 2`를 계산합니다.
  - `(7 - 4) * 2 = 3 * 2 = 6`을 출력하고 프로그램 종료.

### 시간 복잡도
이 알고리즘은 `n`에 대해 로그 시간 복잡도를 가집니다. 즉, O(log n)입니다. 이는 `idx`가 2의 거듭제곱으로 증가하기 때문에, `n`의 크기에 비례하여 상대적으로 적은 수의 반복으로 결과를 도출할 수 있기 때문입니다.

---

## 코드
```python
import sys

n=int(input())
idx=2

while True:
    if (n == 1 or n == 2):
        print(n)
        break
    idx *= 2
    if (idx >= n):
        print((n - (idx // 2)) * 2)
        break

```