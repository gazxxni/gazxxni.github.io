---
layout: post
title: "[백준] 11725번 (Python)"
date: 2025-02-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "11725"]
---

## 문제 링크
[https://www.acmicpc.net/problem/11725](https://www.acmicpc.net/problem/11725)

---

## 풀이

### 풀이 핵심 로직
주어진 문제는 트리의 각 노드에 대한 부모 노드를 찾는 것입니다. 이 코드는 BFS(너비 우선 탐색)를 사용하여 노드를 탐색하면서 각 노드의 부모를 기록합니다. BFS는 큐를 이용해 구현하며, 시작 노드(루트 노드)에서부터 인접한 노드를 탐색해 나갑니다.

### 동작 과정
1. **입력 처리**: 
   - 트리의 노드 수 `n`을 입력받고, `visited` 리스트와 `ans` 리스트를 초기화합니다. `arr` 리스트는 그래프의 인접 리스트 형태로 노드 간의 연결 관계를 저장합니다.
   
2. **그래프 생성**:
   - `n-1` 개의 간선을 입력받아 양방향 그래프를 구성합니다. 각 노드 `a`와 `b`가 연결되어 있음을 `arr`에 저장합니다.

3. **BFS 수행**:
   - BFS 함수가 호출되며, 시작 노드를 큐에 넣고 방문 처리를 합니다. 큐가 비어있지 않은 동안 반복하여 현재 노드에서 연결된 모든 노드를 탐색합니다.
   - 연결된 노드 중 방문하지 않은 노드를 발견하면, 그 노드의 부모를 현재 노드로 설정하고 큐에 추가합니다. 이 과정을 통해 모든 노드를 방문하게 됩니다.

4. **결과 출력**:
   - BFS가 끝난 후, 2번 노드부터 n번 노드까지의 부모 노드를 출력합니다.

예시 입력:
```
7
1 2
1 3
2 4
2 5
3 6
3 7
```
이 경우, BFS는 다음과 같이 진행됩니다:
- 시작 노드 1에서 2, 3을 방문하고, 2의 자식으로 4, 5를 추가합니다.
- 3의 자식으로 6, 7을 추가합니다.
- 최종적으로 `ans` 리스트는 [0, 0, 1, 1, 2, 2, 3, 3]이 되어 2부터 7까지의 부모 노드를 각각 1, 1, 2, 2, 3, 3으로 출력합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n)입니다. 각 노드와 간선을 한 번씩 방문하기 때문에, 노드 수 n에 비례하여 시간 소요가 발생합니다.

---

## 코드
```python
import sys
from collections import deque
input=sys.stdin.readline

n = int(input())
visited = [False] * (n+1)
ans = [0] * (n+1)  # 각 노드의 부모 노드를 저장
arr = [[] for _ in range(n+1)]  # 그래프의 연결 관계를 저장

for i in range(n-1):
    a, b = map(int, input().split())
    arr[a].append(b)  # a에서 b로 연결
    arr[b].append(a)  # b에서 a로 연결 (양방향 그래프)

def bfs(arr, v, visited):

    q = deque([v])  # 시작 노드를 큐에 넣음
    visited[v] = True  # 시작 노드를 방문 처리
    while q:
        x = q.popleft()  # 큐에서 노드를 꺼냄
        for i in arr[x]:  # 현재 노드 x와 연결된 모든 노드 i를 확인
            if not visited[i]:  # 아직 방문하지 않은 노드라면
                ans[i] = x  # 현재 노드를 i의 부모로 설정
                q.append(i) 
                visited[i] = True 

bfs(arr, 1, visited)

for i in range(2, n+1):
    print(ans[i])

```