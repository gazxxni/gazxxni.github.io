---
layout: post
title: "[백준] 1987번 (Python)"
date: 2025-02-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1987"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1987](https://www.acmicpc.net/problem/1987)

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 DFS(깊이 우선 탐색)를 이용하여 현재 위치에서 가능한 모든 경로를 탐색하는 것입니다. 각 위치에서 방문한 알파벳을 집합에 저장하여 중복 방문을 방지하고, 최대 경로 길이를 찾는 것이 목표입니다.

### 동작 과정
1. 입력으로 주어진 행(row)과 열(column)의 크기를 받아 `arr`에 각 위치의 알파벳을 저장합니다.
2. DFS 함수는 현재 위치 `(x, y)`와 현재까지 방문한 알파벳의 수 `cnt`를 인자로 받아 호출됩니다.
3. 처음 `(0, 0)` 위치에서 DFS를 시작하며, 이 위치의 알파벳을 집합 `brr`에 추가합니다.
4. 4개의 방향(상, 하, 좌, 우)으로 이동할 수 있는지 체크하여 유효한 다음 위치 `(nx, ny)`가 범위 내에 있고, 아직 방문하지 않은 알파벳이라면 DFS를 재귀적으로 호출합니다.
5. DFS가 끝난 후, 방문한 알파벳을 집합에서 제거하여 다른 경로에 영향을 주지 않도록 합니다.
6. 모든 경로 탐색이 끝난 후, 최대 경로 길이를 출력합니다.

예시 입력:
```
2 4
CAAB
ADDC
```
- 처음 `(0, 0)`에서 'C'를 방문하고, `brr`에 {'C'}가 추가됩니다.
- 다음 가능한 위치는 `(0, 1)`, `(1, 0)`입니다.
- DFS를 통해 `(0, 1)`에서 'A'를 방문하고, `(1, 0)`에서 'A'를 방문할 수 없으므로 `(0, 2)`와 `(1, 1)`로 이동합니다.
- 이 과정을 반복하여 가능한 모든 경로를 탐색하고, 최대 방문 알파벳 수를 업데이트합니다.

### 시간 복잡도
DFS의 경우 모든 경로를 탐색하므로 최악의 경우 O(4^(r*c))입니다. 하지만 실제로는 알파벳의 종류가 26개로 제한되어 있어, 중복 방문이 없을 경우 더 효율적인 경로 탐색이 이루어집니다. 따라서 평균적으로는 O(r * c)로 볼 수 있습니다.

---

## 코드
```python
r, c = map(int, input().split())
arr = [list(input()) for _ in range(r)]
ans = 0
brr = set()
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

def dfs(x, y, cnt):
    global ans
    ans = max(ans, cnt)
    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]

        if 0 <= nx < r and 0 <= ny < c and not arr[nx][ny] in brr:
            brr.add(arr[nx][ny])
            dfs(nx, ny, cnt+1)
            brr.remove(arr[nx][ny])

brr.add(arr[0][0])
dfs(0, 0, 1)
print(ans)
```