---
layout: post
title: "[백준] 1697번 (Python)"
date: 2024-09-28
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1697"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1697](https://www.acmicpc.net/problem/1697)

---

## 풀이

### 풀이 핵심 로직
이 문제는 BFS(너비 우선 탐색)를 사용하여 동생의 위치를 최단 시간에 찾는 문제입니다. 주어진 위치 `n`에서 시작해 동생의 위치 `k`까지 이동하는데, 이동할 수 있는 방법은 `-1`, `+1`, 그리고 `*2`입니다. BFS는 가장 가까운 노드부터 탐색하기 때문에 최단 경로를 보장합니다.

### 동작 과정
1. **입력**: 예를 들어 `n=5`, `k=17`이라고 가정합니다.
2. **초기화**: `visited` 배열을 -1로 초기화하며, `queue`에 시작 위치 `n`을 추가합니다. `visited[5]`는 0으로 설정합니다.
3. **첫 번째 반복**:
   - `current = 5`를 pop합니다.
   - `current`가 `k`와 다르므로, 가능한 다음 위치 `[4, 6, 10]`을 계산합니다.
   - 이 중 `4`와 `6`은 `visited`가 -1이므로 큐에 추가하고 `visited`를 업데이트합니다. `10`도 추가합니다.
4. **두 번째 반복**:
   - `current = 4`를 pop합니다. 가능한 다음 위치는 `[3, 5, 8]`입니다.
   - `3`와 `8`을 큐에 추가합니다.
5. **계속 반복**: 이 과정을 반복하며 `current`가 `k`와 일치할 때까지 진행합니다.
6. **결과**: 결국 `current`가 `17`에 도달하면 `visited[17]`을 반환하여 최단 시간을 출력합니다.

### 시간 복잡도
BFS의 경우 각 노드를 한 번씩 방문하므로 시간 복잡도는 O(V + E)입니다. 이 문제에서는 상태 공간이 제한적이므로 최대 100,001개의 상태를 탐색하게 되어 O(N)으로 나타낼 수 있습니다. 따라서 최악의 경우 O(N)입니다.

---

## 코드
```python
from collections import deque
import sys
input = sys.stdin.readline

def bfs(n,k):
    # 방문 배열을 선언하고 -1로 초기화
    max_limit = 100001
    visited = [-1] * max_limit
    queue = deque([n])
    visited[n] = 0  # 시작점의 시간은 0

    while queue:
        current = queue.popleft()
        
        # 동생 위치에 도착하면 시간 반환
        if current == k:
            return visited[current]
        
        # 가능한 다음 이동 위치들
        for next_pos in (current - 1, current + 1, current * 2):
            if 0 <= next_pos < max_limit and visited[next_pos] == -1:
                visited[next_pos] = visited[current] + 1
                queue.append(next_pos)

# 입력
n,k = map(int, input().split())
print(bfs(n,k))


```