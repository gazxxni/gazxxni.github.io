---
layout: post
title: "[백준] 12850번 본대 산책2 (Python)"
date: 2025-09-03
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "12850", 수학, 그래프 이론, 분할 정복을 이용한 거듭제곱]
---

## 문제 링크
[https://www.acmicpc.net/problem/12850](https://www.acmicpc.net/problem/12850)

---

## 문제
숭실 대학교 정보 과학관은 유배를 당해서  캠퍼스의 길 건너편에 있다. 그래서 컴퓨터 학부 학생들은 캠퍼스를 ‘본대’ 라고 부르고 정보 과학관을 ‘정보대’ 라고 부른다. 준영이 또한 컴퓨터 학부 소속 학생이라서 정보 과학관에 박혀있으며 항상 꽃 이 활짝 핀 본 대를 선망한다. 어느 날 준영이는 본 대를 산책하기로 결심하였다. 숭실 대학교 캠퍼스 지도는 아래와 같다.



(편의 상 문제에서는 위 건물만 등장한다고 가정하자)

한 건물에서 바로 인접한 다른 건물로 이동 하는 데 1분이 걸린다. 준영이는 산책 도중에 한번도 길이나 건물에 멈춰서 머무르지 않는다. 준영이는 할 일이 많아서 딱 D분만 산책을 할 것이다. (산책을 시작 한 지 D분 일 때, 정보 과학관에 도착해야 한다.) 이때 가능한 경로의 경우의 수를 구해주자.

---

## 입력
D 가 주어진다 (1 ≤ D ≤ 1,000,000,000)

---

## 출력
가능한 경로의 수를 1,000,000,007로 나눈 나머지를 출력한다.

---

## 성능 요약
메모리: 109544 KB, 시간: 96 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 그래프를 인접 행렬로 표현하고, 주어진 시간 D분 동안의 가능한 경로의 수를 계산하는 문제입니다. 분할 정복을 이용한 행렬 거듭제곱을 통해 D분 후의 경로 수를 효율적으로 계산할 수 있습니다. 이 방법을 사용하면 경로 수를 빠르게 계산할 수 있으며, 결과는 1,000,000,007로 나눈 나머지를 출력해야 합니다.

### 동작 과정
1. **그래프 정의**: 주어진 그래프는 8개의 정점(건물)과 각 정점 간의 인접 관계를 인접 행렬로 표현합니다. 각 요소는 두 정점 간의 직접적인 경로가 있는지를 나타냅니다.
2. **입력 처리**: D 값을 입력받습니다.
3. **행렬 곱셈 구현**: `multiply` 함수를 통해 두 행렬 A와 B를 곱합니다. 이때 결과는 모듈로 연산을 통해 1,000,000,007로 나눈 나머지를 유지합니다.
4. **행렬 거듭제곱**: `cal` 함수는 재귀적으로 행렬 A를 n번 곱한 결과를 계산합니다. n이 홀수일 때와 짝수일 때를 구분하여 적절히 행렬을 곱합니다.
5. **결과 출력**: D가 주어졌을 때, `cal` 함수를 호출하여 D시간 후의 경로 수를 계산하고, 시작 정점(0번 정점)에서 정보대(0번 정점)로 돌아오는 경로 수를 출력합니다.

**예시 입력**: D = 2
- 1분 후: 가능한 경로의 수는 3 (0-1-2, 0-1-3, 0-2-1 등)
- 2분 후: 가능한 경로의 수는 8 (각 경로에서 추가로 1분 더 이동할 수 있는 경우)

최종적으로는 `result[0][0]`의 값이 D분 후에 0번 정점에 도착하는 경로의 수가 됩니다.

### 시간 복잡도
행렬 곱셈의 시간 복잡도는 O(N^3)이며, N은 그래프의 정점 수입니다. 행렬 거듭제곱을 수행하는 과정은 O(log D) 이므로, 전체 시간 복잡도는 O(N^3 * log D)로 표현됩니다. 주어진 문제에서는 N이 8로 고정되어 있으므로, 결국 O(log D)로 간주할 수 있습니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

MOD = 1_000_000_007

graph = [
    [0,1,1,0,0,0,0,0],
    [1,0,1,1,0,0,0,0],
    [1,1,0,1,1,0,0,0],
    [0,1,1,0,1,1,0,0],
    [0,0,1,1,0,1,0,1],
    [0,0,0,1,1,0,1,0],
    [0,0,0,0,0,1,0,1],
    [0,0,0,0,1,0,1,0],
]

d = int(input().strip())

def multiply(A, B):
    result = [[0] * 8 for i in range(8)]
  
    for i in range(8):
        for j in range(8):
            for k in range(8):
                result[i][j] += A[i][k] * B[k][j]
            result[i][j] %= MOD
      
    return result

def cal(A, n):
    if n == 1:
        return A
    cal2 = cal(A, n//2)
    
    if n % 2 == 0:
        return multiply(cal2, cal2)
    else:
        mul2 = multiply(cal2, cal2)
        return multiply(mul2, A)
    
result = cal(graph, d)
print(result[0][0])
```