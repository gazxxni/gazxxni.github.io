---
layout: post
title: "[백준] 1509번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1509"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1509](https://www.acmicpc.net/problem/1509)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 문자열을 회문으로 이루어진 부분 문자열로 분할하는 최소 개수를 구하는 문제입니다. 먼저, 문자열의 모든 부분 문자열이 회문인지 여부를 확인하는 2차원 배열을 만들고, 이후 동적 프로그래밍을 통해 각 인덱스에서의 최소 분할 개수를 계산합니다.

### 동작 과정
1. **입력 및 초기화**: 문자열을 입력받고, 길이에 맞춰 `isPal` 배열을 초기화합니다. `isPal[i][j]`는 문자열의 i번째 문자부터 j번째 문자까지가 회문인지 여부를 나타냅니다.
2. **회문 판별**:
   - 길이가 1인 부분 문자열은 모두 회문입니다.
   - 길이가 2인 부분 문자열은 두 문자가 같으면 회문입니다.
   - 길이가 3 이상인 부분 문자열은 양 끝의 문자가 같고, 그 사이의 부분 문자열이 회문일 때 회문입니다.
3. **동적 프로그래밍**:
   - `dp[i]`는 문자열의 0번째 문자부터 i번째 문자까지를 회문으로 분할하는 최소 개수를 저장합니다.
   - 각 인덱스 i에 대해, j가 0부터 i까지 변화하면서 `isPal[j][i]`가 True이면, `dp[i]`를 업데이트합니다. j가 0인 경우는 전체가 회문이므로 1로 설정하고, 그 외의 경우에는 이전 분할 개수에 1을 더한 값과 현재 값 중 최소를 선택합니다.
4. **출력**: 마지막 인덱스에 대한 최솟값인 `dp[n-1]`를 출력합니다.

예시 입력: "ababa"
- `isPal` 배열은 다음과 같이 업데이트됩니다:
  - `isPal[0][0]`, `isPal[1][1]`, `isPal[2][2]`, `isPal[3][3]`, `isPal[4][4]`는 모두 True (길이 1)
  - `isPal[0][1]`, `isPal[1][2]`, `isPal[3][4]`는 False, `isPal[2][3]`는 True (길이 2)
  - `isPal[0][4]`, `isPal[1][3]`는 True (길이 3 이상)
- `dp` 배열은 최종적으로 [1, 2, 1, 2, 1]이 되고, `dp[4]`는 1이므로 출력은 1입니다.

### 시간 복잡도
O(n^2) - 회문 판별과 동적 프로그래밍 계산 모두 O(n^2) 시간 복잡도를 가집니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

a = input().rstrip()
n = len(a)
isPal = [[False] * n for _ in range(n)]

for i in range(n):
    isPal[i][i] = True
    
for i in range(n-1):
    if a[i] == a[i + 1]:
        isPal[i][i + 1] = True

for length in range(3, n + 1):
    for i in range(n - length + 1):
        j = i + length - 1
        if a[i] == a[j] and isPal[i + 1][j - 1]:
            isPal[i][j] = True
            
dp = [float('inf')] * n

for i in range(n):
    for j in range(i + 1):
        if isPal[j][i]:
            if j == 0:
                dp[i] = 1
            else:
                dp[i] = min(dp[i], dp[j - 1] + 1)


print(dp[n - 1])
```