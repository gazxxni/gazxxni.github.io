---
layout: post
title: "[백준] 2606번 (Python)"
date: 2024-09-28
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2606"]
---

## 문제 링크
[https://www.acmicpc.net/problem/2606](https://www.acmicpc.net/problem/2606)

---

## 풀이

### 풀이 핵심 로직
이 문제는 컴퓨터 네트워크에서 바이러스가 퍼지는 과정을 모델링한 것으로, 깊이 우선 탐색(DFS) 또는 너비 우선 탐색(BFS)을 통해 연결된 컴퓨터들을 탐색하여 감염된 컴퓨터의 수를 세는 방식으로 해결합니다. 주어진 그래프에서 1번 컴퓨터와 연결된 모든 컴퓨터를 탐색하여 감염된 컴퓨터의 개수를 계산합니다.

### 동작 과정
1. **입력 처리**: `n` (컴퓨터 수)와 `v` (연결 수)를 입력받고, `graph`와 `visited` 리스트를 초기화합니다.
2. **그래프 생성**: 각 연결을 입력받아 `graph` 리스트에 양방향으로 연결된 컴퓨터를 추가합니다.
   - 예시: 만약 입력이 `1 2`, `1 3`이라면, `graph`는 `graph = [[], [2, 3], [1], [1], ...]` 형태가 됩니다.
3. **BFS 초기화**: 1번 컴퓨터를 방문 처리하고, 큐에 추가합니다.
4. **BFS 탐색**: 큐에서 컴퓨터를 하나씩 꺼내고, 그와 연결된 컴퓨터들을 탐색합니다. 
   - 방문하지 않은 컴퓨터는 큐에 추가하고 방문 표시를 합니다.
5. **결과 출력**: 방문한 컴퓨터 수에서 1을 빼서 감염된 컴퓨터의 수를 출력합니다. (1번 컴퓨터는 제외)

**예시 입력**:
```
7
6
1 2
1 3
2 4
2 5
3 6
3 7
```
- 이 경우, 1번 컴퓨터가 감염되면 2, 3번 컴퓨터가 감염되고, 이어서 4, 5, 6, 7번 컴퓨터까지 감염됩니다. 최종적으로 감염된 컴퓨터 수는 6입니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(V + E)입니다. 여기서 V는 컴퓨터의 수(n)이고, E는 연결의 수(v)입니다. 각 컴퓨터와 연결을 한 번씩 방문하기 때문에 이 복잡도를 가집니다.

---

## 코드
```python
from collections import deque

n=int(input())
v=int(input())

graph = [[] for i in range(n+1)] # 그래프 초기화
visited=[0]*(n+1) # 방문한 컴퓨터인지 표시

for i in range(v): # 그래프 생성
    a,b=map(int,input().split())
    graph[a]+=[b] # a에 b 연결
    graph[b]+=[a] # b에 a 연결 -> 양방향

visited[1]=1 # 1번 컴퓨터부터 시작이니 방문 표시
Q=deque([1])

while Q:
    c=Q.popleft()
    for nx in graph[c]:
        if visited[nx]==0:
            Q.append(nx)
            visited[nx]=1

print(sum(visited)-1)


```