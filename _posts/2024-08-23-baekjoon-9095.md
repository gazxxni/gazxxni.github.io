---
layout: post
title: "[백준] 9095번 (Python)"
date: 2024-08-23
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "9095"]
---

## 문제 링크
[https://www.acmicpc.net/problem/9095](https://www.acmicpc.net/problem/9095)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 숫자(n)에 대해 1, 2, 3의 합으로 만들 수 있는 경우의 수를 세는 문제입니다. 재귀적 접근을 통해 기본 경우(1, 2, 3)에 대한 값을 계산한 뒤, 그 값을 이용하여 더 큰 숫자에 대한 경우의 수를 동적 프로그래밍으로 효율적으로 구합니다.

### 동작 과정
1. 입력으로 주어진 숫자 `t` 만큼 테스트 케이스를 읽어들입니다.
2. `arr` 배열을 정의하여 인덱스에 해당하는 숫자를 만들 수 있는 경우의 수를 저장합니다. 
   - `arr[1]` = 1 (1)
   - `arr[2]` = 2 (1+1, 2)
   - `arr[3]` = 4 (1+1+1, 1+2, 2+1, 3)
3. 4부터 10까지의 값을 동적 프로그래밍 방식으로 계산합니다:
   - `arr[i] = arr[i-1] + arr[i-2] + arr[i-3]`를 통해 현재 숫자를 만들기 위해 마지막 단계에서 1, 2, 3을 더해 만드는 경우의 수를 합산합니다.
4. 각 테스트 케이스에 대해 `arr[testNum]`을 출력하여 그 숫자를 만들 수 있는 경우의 수를 출력합니다.

예시 입력:
```
3
4
7
10
```
- `4`는 `arr[4]` = `arr[3] + arr[2] + arr[1]` = `4 + 2 + 1` = `7`
- `7`은 `arr[7]` = `arr[6] + arr[5] + arr[4]` = `24 + 13 + 7` = `44`
- `10`은 `arr[10]` = `arr[9] + arr[8] + arr[7]` = `89 + 44 + 24` = `157`

출력:
```
7
44
89
```

### 시간 복잡도
이 풀이의 시간 복잡도는 O(n)입니다. (n은 10으로 고정되어 있음) 동적 프로그래밍을 통해 1부터 10까지의 경우의 수를 미리 계산하고, 각 테스트 케이스에 대해 상수 시간 O(1)으로 결과를 출력하기 때문입니다.

---

## 코드
```python
import sys

input=sys.stdin.readline
t=int(input())

arr = [0] * 11
arr[1] = 1
arr[2] = 2
arr[3] = 4

for i in range(4,11):
    arr[i] = arr[i-1] + arr[i-2] + arr[i-3]

for i in range(0,t):
    testNum = int(input())
    print(arr[testNum])

    
```