---
layout: post
title: "[백준] 15650번 (Python)"
date: 2024-11-29
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "15650"]
---

## 문제 링크
[https://www.acmicpc.net/problem/15650](https://www.acmicpc.net/problem/15650)

---

## 풀이

### 풀이 핵심 로직
이 문제는 `n`개의 숫자 중에서 중복 없이 `m`개를 선택하는 조합을 구하는 문제입니다. DFS(깊이 우선 탐색)를 사용하여 숫자를 선택하고, 선택한 숫자를 배열에 추가한 후 재귀 호출을 통해 다음 숫자를 선택합니다. 조합의 길이가 `m`에 도달하면 현재 배열을 출력하고, 마지막으로 숫자를 배열에서 제거하여 다음 조합을 시도할 수 있도록 합니다.

### 동작 과정
1. **입력**: 예를 들어, `n = 4`, `m = 2`라고 가정하면, 우리는 1, 2, 3, 4 중에서 2개의 숫자를 선택해야 합니다.
2. **초기 호출**: DFS 함수 `dfs(1)`을 호출하여 숫자 1부터 시작합니다.
3. **첫 번째 단계**:
    - `i = 1`일 때: `arr`에 1을 추가하고 `dfs(2)`를 호출합니다.
4. **두 번째 단계** (내부 호출):
    - `i = 2`일 때: `arr`에 2를 추가하고 `dfs(3)`을 호출합니다.
5. **세 번째 단계** (내부 호출):
    - `len(arr) == m` 조건이 충족되면 `arr`의 내용을 출력합니다. 예: `1 2`.
    - 이후, `arr`에서 2를 제거하고 `i = 3`으로 넘어갑니다.
6. **조합 반복**: 같은 방식으로 1과 3, 1과 4, 2와 3, 2와 4, 3과 4의 조합을 출력합니다.
7. **최종 출력**: 모든 조합이 탐색되면 종료됩니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(nCk)로, 여기서 nCk는 n개의 요소에서 k개의 요소를 선택하는 조합의 수입니다. 최악의 경우 모든 조합을 생성해야 하므로, `O(n^m)`에 가까운 복잡도를 가질 수 있습니다.

---

## 코드
```python
import sys

n, m = map(int, input().split())
arr = []

def dfs(x):
    if len(arr) == m:   # 종료 조건: arr의 길이가 m이면 현재 조합을 출력
        print(' '.join(map(str, arr)))
        return
    
    for i in range(x, n+1):   # x부터 n까지의 숫자를 순회하며 조합 생성
        if i not in arr:
            arr.append(i)
            dfs(i+1)
            arr.pop()

dfs(1)


```