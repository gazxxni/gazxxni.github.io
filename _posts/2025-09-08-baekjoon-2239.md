---
layout: post
title: "[백준] 2239번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2239"]
---

## 문제 링크
[https://www.acmicpc.net/problem/2239](https://www.acmicpc.net/problem/2239)

---

## 풀이

### 풀이 핵심 로직
이 문제는 스도쿠 퍼즐을 해결하기 위한 백트래킹 알고리즘을 사용합니다. 9x9 보드에서 비어 있는 칸에 1부터 9까지의 숫자를 넣으면서, 각 행, 열, 그리고 3x3 블록에 중복되지 않도록 조건을 체크하며 재귀적으로 탐색합니다.

### 동작 과정
1. **입력 및 초기화**: 먼저, 9x9 보드를 입력받고, 각 행, 열, 3x3 블록에 숫자가 이미 존재하는지를 저장하기 위해 각각 10개의 원소를 가진 리스트를 초기화합니다. 빈 칸의 위치는 `empties` 리스트에 저장합니다.

    예시 입력:
    ```
    530070000
    600195000
    098000060
    800060003
    400803001
    700020006
    060000280
    000419005
    000080079
    ```
   `empties` 리스트는 빈 칸의 좌표를 저장합니다.

2. **재귀 함수 dfs**: `dfs` 함수를 통해 빈 칸을 채우는 과정을 수행합니다. 함수의 인자는 현재 빈 칸의 인덱스입니다. 모든 빈 칸을 채웠을 경우, 완성된 보드를 출력하고 프로그램을 종료합니다. 

3. **숫자 선택**: 각 호출에서 현재 빈 칸에 대해 1부터 9까지의 숫자를 순차적으로 시도합니다. 숫자가 해당 행, 열, 블록에 이미 존재하지 않는 경우, 그 숫자를 해당 칸에 넣고, 행, 열, 블록의 상태를 업데이트한 후 다음 빈 칸으로 넘어갑니다.

4. **백트래킹**: 만약 특정 숫자를 넣고 나서 다음 단계에서 유효한 경우가 없다면, 마지막에 삽입한 숫자를 제거하고 원래 상태로 되돌립니다. 이 과정을 반복하면서 모든 가능성을 탐색합니다.

### 시간 복잡도
스도쿠 문제의 경우, 최악의 경우 모든 빈 칸에 대해 9개의 숫자를 시도해야 하므로 시간 복잡도는 \(O(9^k)\)입니다. 여기서 \(k\)는 빈 칸의 개수입니다. 하지만 일반적인 스도쿠의 경우, 대부분의 경우는 그보다 빠르게 해결됩니다.

---

## 코드
```python
import sys
sys.setrecursionlimit(10000)
input = sys.stdin.readline

board = [list(map(int, list(input().rstrip()))) for _ in range(9)]
row = [[0]*10 for _ in range(9)]
col = [[0]*10 for _ in range(9)]
block = [[0]*10 for _ in range(9)]
empties = []

for r in range(9):
    for c in range(9):
        num = board[r][c]
        if num == 0:
            empties.append((r, c))
        else:
            row[r][num] = col[c][num] = block[(r//3)*3 + (c//3)][num] = 1

def dfs(idx):
    if idx == len(empties):
        for r in range(9):
            print(*board[r], sep='')
        sys.exit(0)
    r, c = empties[idx]
    b = (r//3)*3 + (c//3)
    for num in range(1, 10):
        if row[r][num] == 0 and col[c][num] == 0 and block[b][num] == 0:
            board[r][c] = num
            row[r][num] = col[c][num] = block[b][num] = 1
            dfs(idx + 1)
            board[r][c] = 0
            row[r][num] = col[c][num] = block[b][num] = 0

dfs(0)

```