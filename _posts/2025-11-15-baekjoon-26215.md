---
layout: post
title: "[백준] 26215번 눈 치우기 (Python)"
date: 2025-11-15
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "26215", 구현, 그리디 알고리즘, 정렬, 시뮬레이션]
---

## 문제 링크
[https://www.acmicpc.net/problem/26215](https://www.acmicpc.net/problem/26215)

---

## 문제
지난 밤 겨울 숲에는 눈이 많이 내렸다. 당신은 숲의 주민들을 위해 눈이 오지 않는 동안 모든 집 앞의 눈을 치우고자 한다.

당신은 1분에 한 번씩 두 집을 선택해서 두 집 앞의 눈을 각각 1만큼 치우거나, 한 집을 선택해서 그 집 앞의 눈을 1만큼 치울 수 있다.

모든 집 앞의 눈을 전부 치울 때까지 걸리는 최소 시간은 얼마일까?

---

## 입력
첫 줄에 집의 수를 의미하는 정수 N$N$ (1≤N≤100$1 \leq N \leq 100$)이 주어진다.

다음 줄에는 각각의 집 앞에 쌓여 있는 눈의 양을 나타내는 정수 ai$a_{i}$ (1≤ai≤2000$1 \leq a_{i} \leq 2000$)이 주어진다.

---

## 출력
모든 집 앞의 눈을 치우는 데 최소 몇 분이 걸리는지를 출력한다. 24시간(1440분)이 넘게 걸릴 경우 -1을 출력한다.

---

## 성능 요약
메모리: 108384 KB, 시간: 88 ms

---

## 풀이

### 풀이 핵심 로직
문제는 두 집의 눈을 동시에 치우거나 한 집을 선택해 눈을 치운다는 점에서 그리디 알고리즘을 활용하여 최적의 선택을 반복하는 방식으로 해결할 수 있다. 가장 많은 눈이 쌓인 집과 그 다음으로 많은 집을 선택하여 동시에 눈을 치우는 것이 시간 절약에 도움이 되며, 이를 반복하여 모든 집의 눈을 제거하는 최소 시간을 계산한다.

### 동작 과정
1. **입력 예시**: 
   - 집의 수 N = 5
   - 각 집 앞의 눈의 양: [4, 3, 2, 1, 5]
   
2. **첫 반복**:
   - 배열 정렬: [5, 4, 3, 2, 1]
   - 5번 집과 4번 집 선택하여 눈을 제거: [4, 3, 3, 2, 1] (5 - 1, 4 - 1)
   - 총 시간: 1분
   
3. **두 번째 반복**:
   - 배열 정렬: [4, 3, 3, 2, 1]
   - 4번 집과 3번 집 선택하여 눈을 제거: [3, 2, 2, 2, 1] (4 - 1, 3 - 1)
   - 총 시간: 2분
   
4. **세 번째 반복**:
   - 배열 정렬: [3, 2, 2, 2, 1]
   - 3번 집과 2번 집 선택하여 눈을 제거: [2, 1, 1, 2, 1] (3 - 1, 2 - 1)
   - 총 시간: 3분
   
5. **이 과정을 반복하여 모든 집의 눈이 제거될 때까지 진행합니다.**
   
6. **최종적으로 소요된 시간이 1440분을 초과하는지 확인 후 출력합니다.**

### 시간 복잡도
- 각 반복에서 배열을 정렬하는데 O(N log N) 시간이 소요되며, 최대 N번 반복할 수 있으므로 시간 복잡도는 O(N^2 log N)로 나타낼 수 있다. N의 최대값이 100이므로 이 경우에도 충분히 빠르게 처리할 수 있다.

---

## 코드
```python
import sys
input = sys.stdin.readline

n = int(input())
arr = list(map(int, input().split()))

cnt = 0

while True:
    if len(arr) == 1:
        break
    
    arr.sort(reverse=True)
    arr[0] -= arr[1]
    cnt += arr[1]
    arr.pop(1)
    
cnt += arr[0]
if cnt > 1440:
    print(-1)
else:
    print(cnt)
```