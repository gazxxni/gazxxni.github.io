---
layout: post
title: "[백준] 1389번 (Python)"
date: 2024-11-23
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1389"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1389](https://www.acmicpc.net/problem/1389)

---

## 풀이

### 풀이 핵심 로직
이 문제는 그래프 이론을 활용하여 각 사람의 케빈 베이컨 수를 계산하고, 가장 작은 값을 가진 사람을 찾는 것입니다. 각 사람을 시작점으로 BFS(너비 우선 탐색)를 수행하여 모든 친구들과의 거리를 측정하고, 이를 통해 케빈 베이컨 수를 합산하여 최종적으로 가장 적은 값을 가진 사람의 인덱스를 출력합니다.

### 동작 과정
1. **입력 예시**: 
   - `n = 5`, `m = 4`
   - 친구 관계: `(1, 2), (1, 3), (2, 4), (2, 5)`

2. **그래프 생성**:
   - 주어진 입력에 따라 그래프는 다음과 같이 구성됩니다:
     ```
     1: [2, 3]
     2: [1, 4, 5]
     3: [1]
     4: [2]
     5: [2]
     ```

3. **BFS 수행**:
   - 사람 1을 시작점으로 BFS를 수행:
     - 1과 연결된 친구들(2, 3)까지의 거리는 각각 1, 1.
     - 2와 연결된 친구들(1, 4, 5)까지의 거리 추가: 4와 5까지의 거리는 2.
     - 최종적으로 1의 케빈 베이컨 수는 `0 + 1 + 1 + 2 + 2 = 6`.
   - 같은 방식으로 2, 3, 4, 5에 대해 BFS를 수행하고 각각의 케빈 베이컨 수를 구합니다.
   - 예시의 결과:
     - 1: 6
     - 2: 4
     - 3: 6
     - 4: 5
     - 5: 5

4. **최소값 찾기**:
   - 계산된 케빈 베이컨 수 중 최소값인 4를 가진 사람(2)의 인덱스(1-based)를 출력합니다.

### 시간 복잡도
BFS를 각 사람에 대해 수행하므로, 시간 복잡도는 O(n + m)입니다. 여기서 n은 사람의 수, m은 친구 관계의 수입니다. 전체적으로 O(n * (n + m))가 되지만, m은 최대 n^2이므로 최악의 경우 O(n^2)로 볼 수 있습니다.

---

## 코드
```python
import sys
from collections import deque

input=sys.stdin.readline
n,m=map(int,input().strip().split())
graph = [[] for _ in range(n+1)]  # 그래프 초기화

for i in range(m):  # 그래프 생성
    a,b=map(int,input().strip().split())
    graph[a].append(b)
    graph[b].append(a)

def bfs(graph, start):
    num=[0]*(n+1)   # start의 케빈 베이컨들
    ch[start]=1     # 시작 부분 방문표시

    Q=deque()
    Q.append(start)

    while Q:
        x=Q.popleft()
        for i in graph[x]:
            if ch[i]==0:  # 찾지 않은 친구인 경우에만
                num[i]=num[x]+1  # 한 번 거칠 때마다 + 1
                ch[i]=1  # 찾았다고 표시
                Q.append(i)
                # 또 해당 친구에서 다른 친구로 갈 수 있는 루트 찾기
                # 어차피 이미 찾은 친구는 표시되어 있으므로
                # 가장 최소값으로 찾아짐

    return sum(num)  # 케빈 베이컨 수의 합

ans=[]

for i in range(1,n+1):
    ch=[0]*(n+1)  # 이미 찾았는지 확인할 리스트
    ans.append(bfs(graph,i))

print(ans.index(min(ans))+1)  # 값이 같은 경우 index(사람의 번호)가 적은 걸로 출력
```