---
layout: post
title: "[백준] 2885번 초콜릿 식사 (Python)"
date: 2025-12-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2885", 수학, 그리디 알고리즘, 정수론, 비트마스킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/2885](https://www.acmicpc.net/problem/2885)

---

## 문제
학교 근처 편의점에 새 초콜릿이 들어왔다. 이 초콜릿은 막대 모양이고, 각 막대는 정사각형 N개로 이루어져 있다. 초콜릿의 크기(정사각형의 개수)는 항상 2의 제곱 형태이다. 즉, 1, 2, 4, 8, 16, ...개의 정사각형으로 이루어져 있다.

상근이는 점심식사로 초콜릿을 먹는다. 이때, 적어도 K개 정사각형을 먹어야 남은 수업을 졸지 않고 버틸 수 있다. 상근이의 친구 선영이도 초콜릿을 좋아한다. 선영이는 초콜릿은 돈을 주고 사기 아깝다고 생각하기 때문에, 상근이가 주는 초콜릿만 먹는다.

상근이는 막대 초콜릿를 하나 산 다음에, 정확하게 K개 정사각형이 되도록 초콜릿을 쪼갠다. K개는 자신이 먹고 남는 것은 선영이에게 준다.

막대 초콜릿은 나누기 조금 어렵게 되어 있어서, 항상 가운데로만 쪼개진다. 즉, 정사각형이 D개 있는 막대는 D/2개 막대 두 조각으로 쪼개진다.

K개 정사각형을 만들기 위해서, 최소 몇 번 초콜릿을 쪼개야 하는지와 사야하는 가장 작은 초콜릿의 크기를 구하는 프로그램을 작성하시오. 상근이는 초콜릿을 하나만 살 수 있다. 꼭 한 조각이 K개일 필요는 없고, 여러 조각에 있는 정사각형을 합쳤을 때 K개이면 된다.

---

## 입력
첫째 줄에 K가 주어진다. (1 ≤ K ≤ 1,000,000)

---

## 출력
첫째 줄에는 상근이가 구매해야하는 가장 작은 초콜릿의 크기와 최소 몇 번 쪼개야 하는지를 출력한다.

---

## 성능 요약
메모리: 108384 KB, 시간: 88 ms

---

## 풀이

### 풀이 핵심 로직
문제의 핵심은 K개의 정사각형 초콜릿을 만들기 위해 필요한 최소 크기의 초콜릿을 찾고, 이를 위해 몇 번 쪼개야 하는지를 계산하는 것입니다. 초콜릿의 크기는 항상 2의 제곱 형태로 주어지므로, K보다 크거나 같은 가장 작은 2의 제곱수를 찾아야 하며, 그 다음 K를 초콜릿 조각으로 나누면서 필요한 조각 수를 계산합니다.

### 동작 과정
1. **초콜릿 크기 결정**: 입력으로 주어진 K에 대해, K보다 크거나 같은 최소의 2의 제곱수를 찾습니다. 예를 들어, K가 10이라면 16(2^4)이 됩니다. 이 과정을 통해 `ans` 변수에 저장합니다.

2. **쪼개기 과정**: K를 초콜릿 조각으로 나누는 과정에서, 먼저 `ans` 크기를 가진 초콜릿을 가지고 시작합니다. K가 초콜릿 조각의 크기보다 작으면 초콜릿을 반으로 나누고, 나눌 때마다 카운트를 증가시킵니다. K가 초콜릿 조각의 크기보다 크거나 같으면 그 조각을 K에서 빼고 계속 진행합니다.

3. **최종 결과**: K를 모두 소모하기 위해 필요한 쪼개기 횟수를 계산한 후, 최종적으로 구매해야 하는 초콜릿의 크기와 쪼개기 횟수를 출력합니다.

#### 예시 입력과 단계별 설명
- 입력: `10`
- 초콜릿의 크기를 찾는 과정:
  - 1 → 2 → 4 → 8 → 16 (K=10보다 커지는 16이 선택됨)
  - `ans` = 16
- 초콜릿을 쪼개는 과정:
  - K=10, ans=16일 때, 16을 K에 대해 검사.
  - 10 < 16 이므로 16을 반으로 나누어 8을 얻고, 쪼개기 횟수 증가 (cnt2=1).
  - K=10 - 8 = 2
  - K=2, ans=8일 때, 8을 반으로 나누어 4를 얻고, 쪼개기 횟수 증가 (cnt2=2).
  - K=2 < 4 이므로 4를 반으로 나누어 2를 얻고, 쪼개기 횟수 증가 (cnt2=3).
  - K=2 - 2 = 0이므로 종료.

- 최종 출력: `16 3`

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(log K)입니다. 초콜릿 크기를 찾는 과정은 K의 로그에 비례하고, K를 나누는 과정 또한 최대 O(log K) 횟수로 이루어지므로 전체적으로 O(log K)로 평가할 수 있습니다.

---

## 코드
```python
k = int(input())

cnt = 0
a = 1
while True:
  if a >= k:
      break
  
  a *= 2
 

cnt2 = 0
ans = a
while k > 0:
    if k >= a:
        k -= a
    else:
        a //= 2
        cnt2 += 1
print(ans, cnt2)
```