---
layout: post
title: "[백준] 1620번 (Python)"
date: 2024-11-29
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1620"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1620](https://www.acmicpc.net/problem/1620)

---

## 풀이

### 풀이 핵심 로직
이 문제는 포켓몬의 이름과 번호 간의 양방향 매핑을 통해 효율적으로 정보를 검색하는 방식으로 해결됩니다. 입력으로 주어진 포켓몬의 이름과 번호를 딕셔너리에 저장하여, 사용자가 입력하는 이름 또는 번호에 대해 O(1) 시간 복잡도로 빠르게 결과를 반환할 수 있습니다.

### 동작 과정
1. **입력 처리**: 첫 줄에서 포켓몬의 수 `n`과 질문의 수 `m`을 입력받습니다.
2. **딕셔너리 생성**: `1`부터 `n`까지의 숫자와 해당 숫자에 대응하는 포켓몬 이름을 딕셔너리에 저장합니다. 이때, 포켓몬 이름도 키로 사용하여 숫자와 이름 간의 양방향 매핑을 완성합니다.
   - 예시: 만약 `n=3`이고 포켓몬 이름으로 "피카츄", "이상해꽃", "파이리"가 입력되면, 딕셔너리는 다음과 같이 구성됩니다:
     ```python
     {1: "피카츄", "피카츄": 1, 2: "이상해꽃", "이상해꽃": 2, 3: "파이리", "파이리": 3}
     ```
3. **질문 처리**: 다음 `m`개의 질문을 처리하면서, 입력된 문자열이 숫자인지 확인합니다. 숫자일 경우 해당 숫자로 딕셔너리에서 포켓몬 이름을 찾고, 문자열일 경우 포켓몬 이름으로 번호를 찾습니다.
   - 예시: 질문으로 "1", "이상해꽃", "3"이 들어올 경우 각각 "피카츄", "2", "파이리"가 출력됩니다.

### 시간 복잡도
전체 알고리즘의 시간 복잡도는 O(n + m)입니다. 여기서 `n`은 포켓몬의 수, `m`은 질문의 수입니다. 각 입력에 대해 딕셔너리에 저장하는 과정과 질문을 처리하는 과정은 모두 O(1) 시간이므로, 전체적으로 선형 시간 복잡도를 가집니다.

---

## 코드
```python
import sys

input = sys.stdin.readline
n, m = map(int, input().split())

dict = {}

for i in range(1, n+1):
    a = input().rstrip()
    dict[i] = a  # 양방향 매핑 필수
    dict[a] = i

for i in range(m):
    a = input().rstrip()

    if a.isdigit():   # 숫자로만 구성된 문자열인지 확인
        print(dict[int(a)])
    else:
        print(dict[a])
```