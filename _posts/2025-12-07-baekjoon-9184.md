---
layout: post
title: "[백준] 9184번 신나는 함수 실행 (Python)"
date: 2025-12-07
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, 9184, 다이나믹 프로그래밍, 재귀]
---

## 문제 링크
[https://www.acmicpc.net/problem/9184](https://www.acmicpc.net/problem/9184)

---

## 문제
재귀 호출만 생각하면 신이 난다! 아닌가요?

다음과 같은 재귀함수 w(a, b, c)가 있다.

if a  20 or b > 20 or c > 20, then w(a, b, c) returns:
    w(20, 20, 20)

if a 

위의 함수를 구현하는 것은 매우 쉽다. 하지만, 그대로 구현하면 값을 구하는데 매우 오랜 시간이 걸린다. (예를 들면, a=15, b=15, c=15)

a, b, c가 주어졌을 때, w(a, b, c)를 출력하는 프로그램을 작성하시오.

---

## 입력
입력은 세 정수 a, b, c로 이루어져 있으며, 한 줄에 하나씩 주어진다. 입력의 마지막은 -1 -1 -1로 나타내며, 세 정수가 모두 -1인 경우는 입력의 마지막을 제외하면 없다.

---

## 출력
입력으로 주어진 각각의 a, b, c에 대해서, w(a, b, c)를 출력한다.

---

## 성능 요약
메모리: 112656 KB, 시간: 460 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 세 정수 \(a\), \(b\), \(c\)에 대해 재귀적으로 정의된 함수 \(w(a, b, c)\)의 값을 계산하는 것이다. 재귀 호출이 깊어지면 시간 소모가 커지므로, 메모이제이션을 활용하여 이미 계산된 값을 저장하여 중복 계산을 피하는 방식으로 최적화한다. 특정 조건에 따라 함수의 출력을 단순화하거나 제한하는 규칙이 있다.

### 동작 과정
1. **입력 처리**: \(a\), \(b\), \(c\)의 값을 입력받고, \(-1\) \(-1\) \(-1\)이 입력될 때까지 반복한다.
2. **함수 호출**: 함수 \(w(a, b, c)\)가 호출된다. 기본 조건으로 \(a\), \(b\), \(c\)가 각각 0 이하이면 1을 반환한다.
3. **값 제한**: 만약 \(a\), \(b\), \(c\) 중 하나라도 20을 초과하면 \(w(20, 20, 20)\)을 호출하여 계산한다.
4. **메모이제이션**: \(dp[a][b][c]\)가 0이 아닐 경우, 이미 계산된 값을 반환하여 중복 계산을 방지한다.
5. **재귀 호출 및 계산**: 조건에 따라 \(a < b < c\)인 경우와 아닌 경우에 따라 \(w(a, b, c)\)를 계산한다. 이때, 필요한 하위 문제들을 재귀적으로 호출하여 값을 누적한다.
6. **출력**: 계산된 \(w(a, b, c)\)의 값을 출력한다.

**예시**:
- 입력: `1 2 3`
    - `w(1, 2, 3)` 호출
    - 해당 조건을 만족하므로 재귀 호출을 통해 값을 계산
    - 최종적으로 결과 출력: `w(1, 2, 3) = ...`

### 시간 복잡도
\(O(1)\) - 함수 \(w(a, b, c)\)는 \(a\), \(b\), \(c\)가 각각 20을 넘지 않도록 제한되므로, 가능한 모든 \(a\), \(b\), \(c\) 조합에 대해 메모이제이션을 통해 값을 저장하고 재사용함으로써 상수 시간에 처리된다.

---

## 코드
```python
def w(a, b, c):
    if a <= 0 or b <= 0 or c <= 0:
        return 1
    
    if a > 20 or b > 20 or c > 20:
        return w(20, 20, 20)
    
    if dp[a][b][c]:
        return dp[a][b][c]
    
    if a < b < c:
        dp[a][b][c] = w(a, b, c - 1) + w(a, b - 1, c- 1) - w(a, b - 1, c)
        return dp[a][b][c]
    
    dp[a][b][c] = w(a - 1, b, c) + w(a - 1, b - 1, c) + w(a - 1, b, c - 1) - w(a - 1, b - 1, c - 1)
    return dp[a][b][c]

dp = [[[0] * 21 for _ in range(21)] for _ in range(21)]

while True:
    a, b, c = map(int, input().split())

    if a == -1 and b == -1 and c == -1:
        exit()
    
    print(f'w({a}, {b}, {c}) = {w(a, b, c)}')
```