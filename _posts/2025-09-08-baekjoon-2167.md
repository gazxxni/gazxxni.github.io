---
layout: post
title: "[백준] 2167번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2167"]
---

## 문제 링크
[https://www.acmicpc.net/problem/2167](https://www.acmicpc.net/problem/2167)

---

## 풀이

### 풀이 핵심 로직
이 문제는 2차원 배열에서 주어진 두 점(i, j)과(x, y) 사이의 합을 구하는 문제입니다. 핵심 아이디어는 각 쿼리에 대해 지정된 범위 내의 모든 요소를 직접 반복문을 통해 합산하여 결과를 도출하는 것입니다.

### 동작 과정
1. **입력받기**: 먼저, n(행의 수)과 m(열의 수)을 입력받고, 그 다음 n개의 행에 대해 m개의 정수를 입력받아 2차원 배열 `arr`을 생성합니다. 마지막으로, k개의 쿼리 수를 입력받습니다.

2. **쿼리 처리**: 각 쿼리마다 다음의 과정을 수행합니다.
   - 입력된 값을 통해 범위의 시작점(i, j)과 끝점(x, y)를 결정합니다.
   - 1-based 인덱스를 사용하므로, 파이썬의 0-based 인덱스에 맞게 i-1, j-1, x, y를 조정합니다.
   - 이중 반복문을 사용하여 i-1부터 x-1까지의 행과 j-1부터 y-1까지의 열에 있는 모든 요소를 합산합니다.
   - 계산된 합을 출력합니다.

**예시 입력**:
```
3 3
1 2 3
4 5 6
7 8 9
1
1 1 2 2
```
**단계별 설명**:
- n=3, m=3인 2차원 배열 `arr`은 다음과 같습니다:
```
[
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]
```
- k=1인 쿼리를 처리: `i=1, j=1, x=2, y=2`
- 범위는 (1, 1)에서 (2, 2)까지로, 배열의 요소는 다음과 같습니다:
```
1 2
4 5
```
- 이들의 합은 1 + 2 + 4 + 5 = 12가 되어 출력됩니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(k * (x - i + 1) * (y - j + 1))입니다. 최악의 경우, 모든 쿼리가 전체 배열의 크기와 같은 범위를 요청할 수 있으므로, O(k * n * m)으로 평가할 수 있습니다.

---

## 코드
```python
n, m = map(int, input().split())
arr = [list(map(int, input().split())) for _  in range(n)]
k = int(input())

for _ in range(k):
    i, j, x, y = map(int, input().split())
    ans = 0
    
    for a in range(i - 1, x):
        for b in range(j - 1, y):
            ans += arr[a][b]
            
    print(ans)
```