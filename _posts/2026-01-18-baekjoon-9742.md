---
layout: post
title: "[백준] 9742번 순열 (Python)"
date: 2026-01-18
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "9742", 브루트포스 알고리즘, 백트래킹]
---

## 문제 링크
[https://www.acmicpc.net/problem/9742](https://www.acmicpc.net/problem/9742)

---

## 문제
집합의 순열이란 집합의 서로 다른 원소를 모두 사용해 만들 수 있는 순서이다. 예를 들어, {2,3,5}의 순열은 다음과 같다.


	2 3 5
	2 5 3
	3 2 5
	3 5 2
	5 2 3
	5 3 2


각각의 순열은 숫자로 나타낼 수 있다. 위의 순열은 사전순으로 쓰여져 있으며, 등장하는 순서를 이용해 나타낸다. 즉, 3 5 2는 위치 4에 있고, 5 3 2는 마지막 위치인 6에 있다.

{b,e,i,n}으로 만들 수 있는 순열은 다음과 같다.


	b e i n
	b e n i
	b i e n
	b i n e
	b n e i
	b n i e
	e b i n
	e b n i
	e i b n
	e i n b
	e n b i 
	e n i b
	i b e n
	i b n e
	i e b n
	i e n b
	i n b e
	i n e b
	n b e i
	n b i e
	n e b i
	n e i b
	n i b e
	n i e b


서로 다른 숫자와 문자로 이루어진 집합과 위치가 주어졌을 때, 그 집합의 순열 중 주어진 위치의 순열을 구하는 프로그램을 작성하시오.

---

## 입력
입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있다. 첫 번째 문자열은 서로 다른 숫자와 알파벳으로 이루어져 있으며, 길이는 최대 10이다. 또한, 사전순 순서대로 주어진다. 문자열 다음에는 찾아야 하는 위치가 주어지며, 이 값은 3,628,800보다 작거나 같은 자연수이다.

---

## 출력
각각의 테스트 케이스마다, 입력으로 주어진 위치에 해당하는 순열을 공백없이 출력한다. 만약, 해당하는 순열이 없는 경우에는 "No permutation"을 출력한다.

---

## 성능 요약
메모리: 380072 KB, 시간: 2080 ms

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 주어진 문자열의 순열을 사전 순으로 나열한 후, 특정 위치에 해당하는 순열을 찾아 출력하는 것입니다. 이를 위해서 입력 문자열의 길이에 따라 가능한 모든 순열을 계산하고, 각 순열을 사전 순으로 정렬한 후 직접 인덱스를 통해 원하는 순열을 선택합니다.

### 동작 과정
예를 들어, 입력으로 "b e i n 12"가 주어질 경우:
1. 문자열 "b e i n"의 길이는 4이므로 총 가능한 순열의 개수는 4! = 24개입니다.
2. 모든 순열을 생성하고, 사전 순으로 정렬합니다. 그 결과는:
   ```
   b e i n
   b e n i
   b i e n
   b i n e
   b n e i
   b n i e
   e b i n
   e b n i
   e i b n
   e i n b
   e n b i
   e n i b
   i b e n
   i b n e
   i e b n
   i e n b
   i n b e
   i n e b
   n b e i
   n b i e
   n e b i
   n e i b
   n i b e
   n i e b
   ```
3. 12번째 순열을 찾기 위해 리스트의 인덱스 11에 접근합니다(0-based index).
4. 결과는 "e n i b"가 됩니다. 따라서 출력은 `b e i n 12 = e n i b`가 됩니다.

이 과정에서 만약 찾고자 하는 위치가 총 가능한 순열의 개수보다 크면 "No permutation"을 출력합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n!), 여기서 n은 문자열의 길이입니다. 이는 모든 순열을 생성하고 정렬해야 하기 때문입니다. 하지만 입력 길이가 최대 10이므로, 현실적으로는 수행할 수 있는 범위입니다.

---

## 코드
```python
import sys, math
input = sys.stdin.readline

result = [] 
visited = [] 

def backtrack(arr, path):
    if len(path) == len(arr):
        result.append("".join(path))
        return
    
    for i in range(len(arr)):
        if not visited[i]:
            visited[i] = True
            backtrack(arr, path + [arr[i]])
            visited[i] = False

while True:
    try:
        a, b = input().split()
        b = int(b)
        a = list(a)
        n = len(a)
        total = math.factorial(n)

        if b > total:
            print(f"{''.join(a)} {b} = No permutation")
            continue

        result = []
        visited = [False] * n
        backtrack(a, [])

        result.sort()
        if b <= total // 2:
            ans = result[b-1]
        else:
            ans = result[-(total-b+1)]

        print(f"{''.join(a)} {b} = {ans}")
        
    except:
        break

```