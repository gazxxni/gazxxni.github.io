---
layout: post
title: "[백준] 12789번 도키도키 간식드리미 (Python)"
date: 2025-09-02
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "12789", 자료 구조, 스택]
---

## 문제 링크
[https://www.acmicpc.net/problem/12789](https://www.acmicpc.net/problem/12789)

---

## 문제
인하대학교 학생회에서는 중간, 기말고사 때마다 시험 공부에 지친 학우들을 위해 간식을 나눠주는 간식 드리미 행사를 실시한다. 승환이는 시험 기간이 될 때마다 간식을 받을 생각에 두근두근 설레서 시험 공부에 집중을 못 한다. 이번 중간고사에서도 역시 승환이는 설레는 가슴을 안고 간식을 받기 위해 미리 공지된 장소에 시간 맞춰 도착했다. 그런데 이게 무슨 날벼락인가! 그 곳에는 이미 모든 학생들이 모여있었고, 승환이는 마지막 번호표를 받게 되었다. 설상가상으로 몇몇 양심에 털이 난 학생들이 새치기를 거듭한 끝에 대기열의 순서마저 엉망이 되고 말았다. 간식을 나눠주고 있던 인규는 학우들의 터져 나오는 불만에 번호표 순서로만 간식을 줄 수 있다고 말했다. 

그제야 학생들이 순서대로 줄을 서려고 했지만 공간이 너무 협소해서 마음대로 이동할 수 없었다. 다행히도 대기열의 왼쪽에는 1열로 설 수 있는 공간이 존재하여 이 공간을 잘 이용하면 모두가 순서대로 간식을 받을 수 있을지도 모른다. 자칫 간식을 못 받게 될지도 모른다는 위기감을 느낀 승환이는 자신의 컴퓨터 알고리즘적 지식을 활용해 과연 모든 사람들이 순서대로 간식을 받을 수 있는지 확인하는 프로그램을 만들기로 했다. 만약 불가능 하다면 승환이는 이번 중간고사를 망치게 될 것 이고 가능하다면 힘을 얻어 중간고사를 잘 볼 수 있을지도 모른다.

사람들은 현재 1열로 줄을 서있고, 맨 앞의 사람만 이동이 가능하다. 인규는 번호표 순서대로만 통과할 수 있는 라인을 만들어 두었다. 이 라인과 대기열의 맨 앞 사람 사이에는 한 사람씩 1열이 들어갈 수 있는 공간이 있다. 현재 대기열의 사람들은 이 공간으로 올 수 있지만 반대는 불가능하다. 승환이를 도와 프로그램을 완성하라.

현재 간식 배부 공간을 그림으로 나타내면 다음과 같다.



위 예제는 다음 그림과 같이 움직였을 때 모두가 순서대로 간식을 받을 수 있다..

---

## 입력
입력의 첫째 줄에는 현재 승환이의 앞에 서 있는 학생들의 수 N(1 ≤ N ≤ 1,000,자연수)이 주어진다.

다음 줄에는 승환이 앞에 서있는 모든 학생들의 번호표(1,2,...,N) 순서가 앞에서부터 뒤 순서로 주어진다.

---

## 출력
승환이가 무사히 간식을 받을 수 있으면 "Nice"(따옴표는 제외)를 출력하고 그렇지 않다면 "Sad"(따옴표는 제외)를 출력한다.

---

## 성능 요약
메모리: 108384 KB, 시간: 88 ms

---

## 풀이

### 풀이 핵심 로직
이 문제의 핵심 아이디어는 스택 자료구조를 활용하여 학생들이 순서대로 간식을 받을 수 있는지를 판단하는 것입니다. 학생들이 이동할 수 있는 공간을 스택으로 구현하고, 현재 줄에서 나와야 할 번호와 스택의 가장 위에 있는 번호를 비교하여 간식을 받을 순서를 맞추는 방식으로 접근합니다.

### 동작 과정
우선, 입력된 학생 번호를 순서대로 처리합니다. 현재 간식 배부를 받을 번호(`idx`)는 1부터 시작합니다. 각 학생의 번호를 다음과 같이 처리합니다:

1. 학생 번호가 `idx`와 같으면, 즉시 간식을 받을 수 있으므로 `idx`를 증가시킵니다.
2. 학생 번호가 `idx`와 다르면, 이 학생 번호를 스택에 추가합니다.
3. 스택의 가장 위에 있는 번호가 `idx`와 같으면, 스택에서 해당 번호를 꺼내고 `idx`를 증가시킵니다. 이 과정을 반복하여 스택의 최상단과 `idx`를 비교합니다.

위 과정을 모든 학생에 대해 수행한 후, 스택이 비어있으면 모든 학생이 순서대로 간식을 받을 수 있다는 의미이므로 "Nice"를 출력하고, 스택에 남은 학생이 있다면 "Sad"를 출력합니다.

**예시 입력:**
```
5
4 3 1 2 5
```

**단계별 설명:**
- 초기 상태: `arr = [4, 3, 1, 2, 5]`, `brr = []`, `idx = 1`
- 1. 학생 4: `brr = [4]` (스택에 추가)
- 2. 학생 3: `brr = [4, 3]` (스택에 추가)
- 3. 학생 1: `idx`와 같으므로, `idx = 2`로 증가. 스택의 최상단(3)과 비교 → 계속 대기.
- 4. 학생 2: `idx`와 같으므로, `idx = 3`로 증가. 스택의 최상단(3)과 비교 → 꺼내고 `idx = 4`로 증가.
- 5. 학생 5: `idx`와 같으므로, `idx = 5`로 증가. 스택 비어있음 → 종료.

최종적으로 스택이 비어있으므로 "Nice" 출력.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(N)입니다. 각 학생에 대해 한 번씩 스택에 추가하거나 제거하는 연산을 하므로 전체 학생 수에 비례하는 시간 복잡도를 가집니다.

---

## 코드
```python
n = int(input())
arr = list(map(int, input().split()))

brr = []
idx = 1

for i in arr:
    if i == idx:
        idx += 1
        while brr and brr[-1] == idx:
            brr.pop()
            idx += 1
    else:
        brr.append(i)

if not brr:
    print("Nice")
else:
    print("Sad")
```