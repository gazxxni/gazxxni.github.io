---
layout: post
title: "[백준] 12850번 본대 산책2 (Python)"
date: 2026-01-16
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "12850", 수학, 그래프 이론, 분할 정복을 이용한 거듭제곱]
---

## 문제 링크
[https://www.acmicpc.net/problem/12850](https://www.acmicpc.net/problem/12850)

---

## 문제
숭실 대학교 정보 과학관은 유배를 당해서  캠퍼스의 길 건너편에 있다. 그래서 컴퓨터 학부 학생들은 캠퍼스를 ‘본대’ 라고 부르고 정보 과학관을 ‘정보대’ 라고 부른다. 준영이 또한 컴퓨터 학부 소속 학생이라서 정보 과학관에 박혀있으며 항상 꽃 이 활짝 핀 본 대를 선망한다. 어느 날 준영이는 본 대를 산책하기로 결심하였다. 숭실 대학교 캠퍼스 지도는 아래와 같다.



(편의 상 문제에서는 위 건물만 등장한다고 가정하자)

한 건물에서 바로 인접한 다른 건물로 이동 하는 데 1분이 걸린다. 준영이는 산책 도중에 한번도 길이나 건물에 멈춰서 머무르지 않는다. 준영이는 할 일이 많아서 딱 D분만 산책을 할 것이다. (산책을 시작 한 지 D분 일 때, 정보 과학관에 도착해야 한다.) 이때 가능한 경로의 경우의 수를 구해주자.

---

## 입력
D 가 주어진다 (1 ≤ D ≤ 1,000,000,000)

---

## 출력
가능한 경로의 수를 1,000,000,007로 나눈 나머지를 출력한다.

---

## 성능 요약
메모리: 109544 KB, 시간: 96 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 그래프의 인접 행렬을 이용하여 경로의 수를 계산하는 문제이다. 준영이가 본대에서 정보대까지 D분 만에 도달하는 경로의 수를 구하기 위해, 그래프의 인접 행렬을 D번 거듭제곱하여 얻은 행렬의 (0, 0) 요소가 바로 그 경로의 수를 의미한다. 이를 위해 분할 정복을 이용한 거듭제곱 알고리즘을 사용하여 효율적으로 계산한다.

### 동작 과정
1. **입력**: D가 주어지며, D는 1 이상 1,000,000,000 이하의 정수이다.
2. **그래프 정의**: 주어진 그래프는 8개의 노드(건물)로 구성되어 있으며 인접 행렬로 표현된다.
3. **행렬 거듭제곱**: D가 1일 때는 그래프의 원래 인접 행렬을 반환하고, 그 외에는 분할 정복을 통해 D/2로 나누어 계산하여 최종적으로 A^D를 얻는다.
   - 짝수일 경우: A^(D/2) * A^(D/2)
   - 홀수일 경우: A^(D/2) * A^(D/2) * A
4. **결과 출력**: 최종적으로 계산된 행렬의 (0, 0) 요소를 출력하여 본대에서 정보대까지 D분 동안의 경로 수를 구한다.

예시 입력으로 D=1인 경우:
- `result = cal(graph, 1)` 호출 후, `result[0][0]`은 0번 노드에서 0번 노드로 가는 경로의 수, 즉 0이다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(log D)이다. 각 행렬 곱셈은 O(V^3) (V는 노드의 수)이며, 여기서는 V=8이므로 상수 시간에 가까워 실질적으로 O(log D)로 동작한다.

---

## 코드
```python
import sys
input = sys.stdin.readline

MOD = 1_000_000_007

graph = [
    [0,1,1,0,0,0,0,0],
    [1,0,1,1,0,0,0,0],
    [1,1,0,1,1,0,0,0],
    [0,1,1,0,1,1,0,0],
    [0,0,1,1,0,1,0,1],
    [0,0,0,1,1,0,1,0],
    [0,0,0,0,0,1,0,1],
    [0,0,0,0,1,0,1,0],
]

d = int(input().strip())

def multiply(A, B):
    result = [[0] * 8 for i in range(8)]
  
    for i in range(8):
        for j in range(8):
            for k in range(8):
                result[i][j] += A[i][k] * B[k][j]
            result[i][j] %= MOD
      
    return result

def cal(A, n):
    if n == 1:
        return A
    cal2 = cal(A, n//2)
    
    if n % 2 == 0:
        return multiply(cal2, cal2)
    else:
        mul2 = multiply(cal2, cal2)
        return multiply(mul2, A)
    
result = cal(graph, d)
print(result[0][0])
```