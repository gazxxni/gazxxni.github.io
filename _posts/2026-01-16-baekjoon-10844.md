---
layout: post
title: "[백준] 10844번 쉬운 계단 수 (Python)"
date: 2026-01-16
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "10844", 다이나믹 프로그래밍]
---

## 문제 링크
[https://www.acmicpc.net/problem/10844](https://www.acmicpc.net/problem/10844)

---

## 문제
45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.

---

## 입력
첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

---

## 출력
첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

---

## 성능 요약
메모리: 108384 KB, 시간: 84 ms

---

## 풀이

### 풀이 핵심 로직
주어진 문제는 길이가 N인 계단 수의 개수를 구하는 것입니다. 계단 수는 인접 자릿수의 차이가 1이 되어야 하므로, 동적 프로그래밍을 이용하여 각 자릿수에 대해 가능한 계단 수의 개수를 누적해 나갑니다. DP 테이블을 사용하여 각 자릿수와 길이에 따라 가능한 경우의 수를 저장합니다.

### 동작 과정
1. **입력**: N을 입력받습니다. (예: N = 3)
2. **DP 테이블 초기화**: dp[1][2]부터 dp[1][9]까지를 1로 초기화합니다. 이는 길이가 1인 계단 수는 1부터 9까지의 숫자입니다.
   ```
   dp[1] = [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0]
   ```
3. **DP 테이블 채우기**: N이 2 이상일 때, 각 자릿수 j(1부터 9까지)에 대해 이전 길이의 가능성을 더합니다. 예를 들어, dp[i][j]는 dp[i-1][j-1]과 dp[i-1][j+1]의 합입니다.
   - i = 2일 때:
     - dp[2][1] = dp[1][2] (1의 앞은 2만 가능) = 1
     - dp[2][2] = dp[1][1] + dp[1][3] = 0 + 1 = 1
     - dp[2][3] = dp[1][2] + dp[1][4] = 1 + 1 = 2
     - ... (이런 식으로 진행)
4. **결과 계산**: N 길이의 계단 수의 총합을 구합니다. dp[N][0]은 사용하지 않으므로, dp[N][1]부터 dp[N][9]까지의 합을 구합니다.
5. **출력**: 결과를 1,000,000,000으로 나눈 나머지를 출력합니다.

### 시간 복잡도
O(N) - 여기서 N은 입력으로 주어진 수의 길이입니다. DP 테이블을 한 번 순회하면서 각 상태를 계산하므로 시간 복잡도는 선형입니다.

---

## 코드
```python
n = int(input())

dp = [[0] * 12 for _ in range(n + 1)]
dp[1][2:11] = [1] * 9

for i in range(2, n + 1):
    for j in range(1, 11):
        dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]
        
ans = sum(dp[n])
print(ans % 1000000000)
```