---
layout: post
title: "[백준] 11054번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "11054"]
---

## 문제 링크
[https://www.acmicpc.net/problem/11054](https://www.acmicpc.net/problem/11054)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 수열에서 가장 긴 바이토닉 부분 수열의 길이를 구하는 것이다. 바이토닉 부분 수열은 증가하는 부분 수열과 감소하는 부분 수열로 구성되며, 이를 위해 두 개의 동적 프로그래밍 배열을 사용하여 수열의 각 위치에서의 증가 및 감소 가능성을 계산한다.

### 동작 과정
1. **입력**: n개의 정수를 입력받아 리스트 `arr`에 저장한다.
2. **증가하는 부분 수열 계산**:
    - `dp_inc` 배열을 초기화하고, 각 원소에 대해 이전 원소들 중 자신보다 작은 원소의 `dp_inc` 값을 참조하여 증가하는 부분 수열의 최대 길이를 갱신한다.
3. **감소하는 부분 수열 계산**:
    - `dp_dec` 배열을 초기화하고, 각 원소에 대해 이후 원소들 중 자신보다 작은 원소의 `dp_dec` 값을 참조하여 감소하는 부분 수열의 최대 길이를 갱신한다.
4. **최대 바이토닉 길이 계산**:
    - 각 인덱스에서 `dp_inc[i]`와 `dp_dec[i]`의 합에서 1을 빼고, 이 값들의 최대치를 구하여 최종 결과를 출력한다.

예를 들어, 입력이 `5` (n)과 `1 2 1 3 2` (arr)일 때:
- `dp_inc`는 `[1, 2, 1, 3, 2]`로 계산된다.
- `dp_dec`는 `[2, 1, 1, 2, 1]`로 계산된다.
- 그러면 각 인덱스에서의 바이토닉 길이를 합쳐 최대값을 구하면 `5`가 된다.

### 시간 복잡도
O(n^2)  
이 알고리즘은 두 개의 중첩 for 루프를 사용하여 각 원소에 대해 모든 이전 또는 이후 원소를 탐색하기 때문에 시간 복잡도는 O(n^2)이다.

---

## 코드
```python
n = int(input())
arr = list(map(int, input().split()))

def search(n, arr):
    dp_inc = [1] * n   # 증가하는 부분 수열 (LIS)
    for i in range(n):
        for j in range(i):
            if arr[j] < arr[i]:
                dp_inc[i] = max(dp_inc[i], dp_inc[j] + 1)

    dp_dec = [1] * n   # 감소하는 부분 수열 (LDS) (역순으로 LIS 구하기)
    for i in range(n - 1, -1, -1):
        for j in range(i + 1, n):
            if arr[j] < arr[i]:
                dp_dec[i] = max(dp_dec[i], dp_dec[j] + 1)
                
    # -1을 하는 이유는 중앙에 있는 원소가 중복 포함되기 때문.
    max_length = max(dp_inc[i] + dp_dec[i] - 1 for i in range(n)) 
    
    return max_length

print(search(n, arr))
```