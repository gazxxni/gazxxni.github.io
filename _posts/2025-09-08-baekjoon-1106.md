---
layout: post
title: "[백준] 1106번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "1106"]
---

## 문제 링크
[https://www.acmicpc.net/problem/1106](https://www.acmicpc.net/problem/1106)

---

## 풀이

### 풀이 핵심 로직
이 문제는 최소 비용으로 특정 인원 수를 충족시키는 최적화 문제로, 동적 프로그래밍을 사용하여 해결합니다. 각 캠프를 통해 얻을 수 있는 인원 수와 그에 대한 비용을 활용하여, 가능한 모든 인원 수에 대해 최소 비용을 계산하고, 최종적으로 필요한 인원 수 이상을 충족하는 최소 비용을 찾습니다.

### 동작 과정
1. **입력 처리**: 첫 번째 줄에서 필요한 인원 수 `c`와 캠프 수 `n`을 입력받습니다. 이후 각 캠프의 비용과 제공하는 인원 수를 리스트 형태로 저장합니다.
   - 예시 입력:
     ```
     10 3
     100 5
     200 8
     300 10
     ```
   - 위 입력은 10명의 인원을 충족시키기 위해 3개의 캠프가 있으며, 각 캠프의 비용과 제공 인원 수를 나타냅니다.

2. **DP 배열 초기화**: `dp` 배열을 생성하여, 각 인원 수를 충족시키기 위한 최소 비용을 저장합니다. `dp[0]`은 0으로 초기화하고, 나머지는 무한대로 초기화합니다.

3. **DP 계산**: 이중 루프를 통해 각 가능한 인원 수 `i`를 계산합니다. 외부 루프는 인원 수를 1부터 `c + 100`까지 반복하며, 내부 루프는 각 캠프의 비용과 인원 수를 확인합니다. 만약 현재 인원 수 `i`에서 캠프를 이용할 수 있다면, 최소 비용을 업데이트합니다.
   - 즉, `dp[i]`는 `dp[i - people] + cost`와 비교하여 최소값을 갱신합니다.

4. **결과 출력**: 마지막으로, `dp[c:]`에서 최소 비용을 찾아 출력합니다. 이는 필요한 인원 수 `c` 이상을 충족시키는 최소 비용을 의미합니다.

### 시간 복잡도
이 알고리즘의 시간 복잡도는 O(n * M)입니다. 여기서 `n`은 캠프의 수, `M`은 최대로 고려하는 인원 수 (이 경우 `c + 100`)입니다. 캠프 수와 인원 수에 따라 DP 테이블을 채우는 과정에서 모든 조합을 고려하기 때문에 이와 같은 복잡도를 가집니다.

---

## 코드
```python
import sys
input = sys.stdin.readline

c, n = map(int, input().split())
arr = [list(map(int, input().split())) for _ in range(n)]

dp = [float('inf')] * (c + 100)
dp[0] = 0

for i in range(1, c + 100):
    for cost, people in arr:
        if i - people >= 0:
            dp[i] = min(dp[i], dp[i - people] + cost)

print(min(dp[c:]))
```