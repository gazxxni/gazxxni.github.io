---
layout: post
title: "[백준] 2018번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2018"]
---

## 문제 링크
[https://www.acmicpc.net/problem/2018](https://www.acmicpc.net/problem/2018)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 정수 \( n \)을 연속된 자연수의 합으로 표현할 수 있는 경우의 수를 찾는 것입니다. 두 개의 포인터(`start`, `end`)를 사용하여 현재 구간의 합 `total`을 조절하면서 \( n \)과 비교하여 합이 작으면 오른쪽 포인터를 증가시키고, 크면 왼쪽 포인터를 증가시키며 카운팅합니다.

### 동작 과정
예를 들어, 입력이 \( n = 15 \)일 때의 단계별 설명은 다음과 같습니다.

1. **초기화**: `start = 1`, `end = 1`, `total = 1`, `cnt = 0`
2. **첫 번째 반복**: 
   - `total (1) < n (15)`, `end`를 2로 증가시켜 `total`을 3으로 업데이트
3. **두 번째 반복**: 
   - `total (3) < n (15)`, `end`를 3으로 증가시켜 `total`을 6으로 업데이트
4. **세 번째 반복**: 
   - `total (6) < n (15)`, `end`를 4로 증가시켜 `total`을 10으로 업데이트
5. **네 번째 반복**: 
   - `total (10) < n (15)`, `end`를 5로 증가시켜 `total`을 15로 업데이트
6. **다섯 번째 반복**: 
   - `total (15) == n (15)`, `cnt`를 1 증가시키고 `end`를 6으로 증가시켜 `total`을 21로 업데이트
7. **여섯 번째 반복**:
   - `total (21) > n (15)`, `start`를 2로 증가시켜 `total`을 20으로 업데이트
8. **이후 반복**:
   - `total`이 계속 \( n \)과 비교되며 `start`와 `end`가 조정되면서 카운트가 계속 업데이트됩니다.
9. **종료**: 루프가 끝나면 `cnt + 1` (자기 자신을 포함) 결과를 출력합니다.

결과적으로, 15는 연속된 자연수의 합으로 표현될 수 있는 경우의 수가 4개입니다: (15), (7+8), (4+5+6), (1+2+3+4+5).

### 시간 복잡도
이 알고리즘은 두 개의 포인터를 사용하여 \( n \)에 도달할 때까지 반복하므로, 최악의 경우 \( O(n) \)의 시간 복잡도를 가집니다. 실제로는 더 적은 반복으로 종료될 가능성이 높습니다.

---

## 코드
```python
n = int(input())
start, end = 1, 1
cnt, total = 0, 1

while end != n:
    if total < n:  # 합이 n보다 작으면 뒤에 수 추가
        end += 1
        total += end
    elif total > n:  # 합이 n보다 크면 앞에 수 빼기
        total -= start
        start += 1
    else:  # 합이 n과 같으면
        cnt += 1
        end += 1
        total += end

print(cnt + 1)  # 자기 자신도 포함
```