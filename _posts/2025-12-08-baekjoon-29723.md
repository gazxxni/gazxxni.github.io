---
layout: post
title: "[백준] 29723번 브실이의 입시전략 (Python)"
date: 2025-12-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "29723", 자료 구조, 정렬, 집합과 맵, 해시를 사용한 집합과 맵]
---

## 문제 링크
[https://www.acmicpc.net/problem/29723](https://www.acmicpc.net/problem/29723)

---

## 문제
올해 고3인 브실이는 세계 최고의 명문 대학 브실대학(브론즈실버대학)에 가기 위해서 자신의 현재 점수를 토대로 입시 전략을 세우려고 한다. 브실대학에서는 특정 과목들의 성적의 합을 통해 서류 전형의 합격여부를 결정한다고 한다. 그러나 브실대학에서는 어떤 과목이 서류 평가에 반영되는지 모두 알려주지 않고 일부만 알려주는 사악한 학교다. 브실대학에서 요구하는 과목 수와 반영된다고 공개된 과목들이 주어질 때, 브실이가 얻을 수 있는 최소 점수와 최대 점수를 구해보자.

단, 공개된 과목과 비공개된 과목은 브실이가 수강한 과목에 모두 포함되어 있으며, 과목은 중복되지 않는다.

---

## 입력
첫 번째 줄에 브실이가 수강한 과목 수 N$N$과 브실대학에서 요구하는 과목 수 M$M$, 그리고 브실대학에서 공개한 과목 수 K$K$가 공백으로 구분되어 주어진다. (1≤K≤M≤N≤10000)$(1 \le K \le M \le N \le 10\,000)$ 

그다음 N$N$줄에 걸쳐 브실이가 수강한 과목 이름 si$s_i$과 정수 점수 pi$p_i$가 공백으로 구분되어 주어진다. si$s_i$는 영어 소문자로만 이루어져 있다. (3≤|si|≤20;$(3 \le |s_i| \le 20;$ 0≤pi≤100)$0 \le p_i \le 100)$ 

그다음 K$K$줄에 걸쳐 브실대학에서 공개한 과목 이름 ti$t_i$가 주어진다. ti$t_i$는 영어 소문자로만 이루어져 있다. (3≤|ti|≤20)$(3 \le |t_i| \le 20)$

---

## 출력
브실이가 얻을 수 있는 최소 점수와 최대 점수를 공백으로 구분하여 출력한다.

---

## 성능 요약
메모리: 115020 KB, 시간: 156 ms

---

## 풀이

### 풀이 핵심 로직
브실이가 수강한 과목의 점수와 브실대학에서 공개한 과목의 점수를 이용하여 가능한 최소 점수와 최대 점수를 계산합니다. 공개된 과목의 점수를 먼저 합산한 뒤, 남은 과목들 중에서 최소 점수를 추가하기 위해 가장 낮은 점수 K개를 선택하고, 최대 점수를 위해 가장 높은 점수 M-K개를 선택하여 최종 점수를 구합니다.

### 동작 과정
1. 입력을 통해 브실이가 수강한 과목 수 N, 요구하는 과목 수 M, 공개된 과목 수 K를 받습니다.
2. 각 과목에 대한 점수를 딕셔너리 형태로 저장합니다. 예를 들어, `math 90`, `science 80`인 경우, `{'math': 90, 'science': 80}`과 같이 저장됩니다.
3. 공개된 과목 K개에 대해 점수를 합산하고, 이 과목들은 딕셔너리에서 삭제합니다.
    - 예시 입력:
        ```
        5 3 2
        math 90
        science 80
        english 70
        history 60
        art 50
        science
        english
        ```
    - 공개된 과목 `science`와 `english`의 점수를 합산하여 150을 계산합니다.
4. 남은 과목들 중에서 최소 M-K 과목의 점수를 추가하여 최소 점수를 구하고, 최대 M-K 과목의 점수를 추가하여 최대 점수를 구합니다.
    - 남은 과목은 `{'math': 90, 'history': 60, 'art': 50}`입니다.
    - 최소 점수를 위해 점수가 낮은 과목 1개를 선택하여 `min_ans = 150 + 50 = 200`이 되고, 최대 점수를 위해 점수가 높은 과목 1개를 선택하여 `max_ans = 150 + 90 = 240`이 됩니다.
5. 최종적으로 최소 점수와 최대 점수를 출력합니다.

### 시간 복잡도
이 알고리즘은 O(N log N)입니다. 과목 정보를 딕셔너리에 저장하는 과정은 O(N)이고, 남은 과목들을 정렬하는 과정이 O(N log N)입니다. 따라서 전체 시간 복잡도는 O(N log N)입니다.

---

## 코드
```python
from collections import defaultdict

n, m, k = map(int, input().split())
dic = defaultdict(int)

for _ in range(n):
    s, p = map(str, input().split())
    dic[s] = int(p)

ans = 0
for _ in range(k):
    t = input().rstrip()
    ans += dic[t]
    
    dic.pop(t)

dic = sorted(dic.items(), key=lambda item: item[1])
m -= k

max_ans = ans
min_ans = ans
if m > 0:
    a = dic[:m]
    min_ans += sum(item[1] for item in a)
    
    b = dic[-m:]
    max_ans += sum(item[1] for item in b)
    
print(min_ans, max_ans)

```