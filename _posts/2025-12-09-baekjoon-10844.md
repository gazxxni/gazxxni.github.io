---
layout: post
title: "[백준] 10844번 쉬운 계단 수 (Python)"
date: 2025-12-09
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "10844", 다이나믹 프로그래밍]
---

## 문제 링크
[https://www.acmicpc.net/problem/10844](https://www.acmicpc.net/problem/10844)

---

## 문제
45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.

---

## 입력
첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

---

## 출력
첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

---

## 성능 요약
메모리: 108384 KB, 시간: 84 ms

---

## 풀이

### 풀이 핵심 로직
문제는 길이가 N인 "계단 수"의 개수를 구하는 것으로, 인접한 자리의 차이가 1인 수를 의미합니다. 다이나믹 프로그래밍을 사용하여 각 자리수에 가능한 계단 수의 개수를 저장하고, 이전 자리수에서 가능한 수의 조합을 통해 현재 자리수의 계단 수 개수를 계산합니다.

### 동작 과정
1. **초기화**: `dp` 배열을 생성하여 `dp[i][j]`가 길이 `i`의 수에서 마지막 자리수가 `j`인 계단 수의 개수를 저장하도록 합니다. 배열의 크기는 `(n+1) x 12`로 설정하여 1부터 11까지의 숫자를 인덱스로 사용합니다. 0으로 시작하는 수는 계단수가 아니므로, `dp[1][2:11]`을 1로 초기화합니다.

2. **상태 전이**: 각 자리수 `i`에 대해, 마지막 자리수가 `j`일 때는 이전 자리수에서 마지막 자리수가 `j-1` 및 `j+1`인 경우에서 파생됩니다. 즉, `dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]`로 상태를 전이합니다. 단, 유효한 자리수 범위(1~10) 내에서만 계산합니다.

3. **결과 계산**: 길이가 N인 계단 수의 총합은 `sum(dp[n])`으로 구할 수 있으며, 이 값을 1,000,000,000으로 나눈 나머지를 출력합니다.

#### 예시 입력
- 입력: `N = 2`
- 초기 `dp` 배열:
  ```
  dp[1][2] = 1
  dp[1][3] = 1
  dp[1][4] = 1
  ...
  dp[1][9] = 1
  dp[1][10] = 1
  ```

- 2자리 수를 계산:
  - `dp[2][1] = dp[1][0] + dp[1][2]` → 0 + 1 = 1
  - `dp[2][2] = dp[1][1] + dp[1][3]` → 0 + 1 = 1
  - `dp[2][3] = dp[1][2] + dp[1][4]` → 1 + 1 = 2
  - ...
  - `dp[2][9] = dp[1][8] + dp[1][10]` → 1 + 0 = 1
  - `dp[2][10] = dp[1][9]` → 1

- 최종 `dp[2]` 배열:
  ```
  dp[2][1] = 1
  dp[2][2] = 1
  dp[2][3] = 2
  dp[2][4] = 3
  dp[2][5] = 4
  ...
  dp[2][10] = 1
  ```

- 결과: `sum(dp[2])` = 1 + 1 + 2 + 3 + 4 + 4 + 3 + 2 + 1 = 20

### 시간 복잡도
O(N), 여기서 N은 주어진 수의 길이입니다. 이 알고리즘은 이중 루프를 사용하지만, 두 번째 루프는 10까지의 상수 시간 내에서 수행되므로 전체 시간 복잡도는 N에 비례합니다.

---

## 코드
```python
n = int(input())

dp = [[0] * 12 for _ in range(n + 1)]
dp[1][2:11] = [1] * 9

for i in range(2, n + 1):
    for j in range(1, 11):
        dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]
        
ans = sum(dp[n])
print(ans % 1000000000)
```