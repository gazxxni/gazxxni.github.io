---
layout: post
title: "[백준] 2638번 (Python)"
date: 2025-09-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2638"]
---

## 문제 링크
[https://www.acmicpc.net/problem/2638](https://www.acmicpc.net/problem/2638)

---

## 풀이

### 풀이 핵심 로직
이 문제는 치즈가 녹는 과정을 시뮬레이션하여 녹는 데 걸리는 시간을 계산하는 것입니다. BFS(너비 우선 탐색)를 사용하여 외부 공기와 접촉하는 치즈 조각을 찾아내고, 두 개 이상의 외부 공기와 접촉한 치즈는 녹는 것으로 설정합니다. 이를 반복하여 모든 치즈가 녹을 때까지 시간을 측정합니다.

### 동작 과정
1. **입력 예시**:
   ```
   3 5
   0 0 0 0 0
   0 1 1 1 0
   0 0 0 0 0
   ```
   여기서 `0`은 빈 공간, `1`은 치즈를 나타냅니다.

2. **초기 상태**:
   ```
   board = [
       [0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]
   ]
   ```

3. **BFS 시작**:
   - `(0, 0)`에서 BFS를 시작하여 외부 공기와 접촉한 모든 빈 공간을 탐색합니다.
   - 치즈 조각에 접촉한 외부 공기 개수를 `contact` 배열에 기록합니다.

4. **치즈 녹이기**:
   - BFS 탐색 후, `contact` 배열을 이용해 두 개 이상의 외부 공기와 접촉한 치즈는 `0`으로 바꾸어 녹입니다.

5. **시간 측정**:
   - 이 과정을 반복하여 모든 치즈가 녹을 때까지 시간을 증가시킵니다.

6. **최종 출력**:
   - 모든 치즈가 녹는 데 걸린 시간을 출력합니다.

### 시간 복잡도
시간 복잡도는 O(n * m)입니다. 여기서 n은 행의 수, m은 열의 수입니다. BFS 탐색과 치즈 상태 확인을 각각 n * m의 시간에 수행하므로 전체적으로 O(n * m)입니다.

---

## 코드
```python
import sys
from collections import deque
input = sys.stdin.readline

n, m = map(int, input().split())
board = [list(map(int, input().split())) for _ in range(n)]
directions = [(1, 0), (-1, 0), (0, -1), (0, 1)]

def bfs():
    visited = [[0] * m for _ in range(n)]
    q = deque()
    q.append((0, 0))
    visited[0][0] = 1

    contact = [[0] * m for _ in range(n)]

    while q:
        x, y = q.popleft()

        for dx, dy in directions:
            nx, ny = x + dx, y + dy

            if 0 <= nx < n and 0 <= ny < m:
                if board[nx][ny] == 0 and not visited[nx][ny]:
                    visited[nx][ny] = 1
                    q.append((nx, ny))
                elif board[nx][ny] == 1:
                    contact[nx][ny] += 1

    melted = False
    for i in range(n):
        for j in range(m):
            if board[i][j] == 1 and contact[i][j] >= 2:
                board[i][j] = 0
                melted = True

    return melted

def all_melted():
    for i in range(n):
        for j in range(m):
            if board[i][j] == 1:
                return False
    return True

time = 0
while not all_melted():
    if bfs():
        time += 1

print(time)

```