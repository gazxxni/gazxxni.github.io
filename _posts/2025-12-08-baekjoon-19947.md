---
layout: post
title: "[백준] 19947번 투자의 귀재 배주형 (Python)"
date: 2025-12-08
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "19947", 다이나믹 프로그래밍, 브루트포스 알고리즘]
---

## 문제 링크
[https://www.acmicpc.net/problem/19947](https://www.acmicpc.net/problem/19947)

---

## 문제
2020년에 학교로 복학한 주형이는 월세를 마련하기 위해서 군 적금을 깨고 복리 투자를 하려고 한다.

주형이가 하려는 투자에는 3가지 방법의 투자 방식이 있다. 


	1년마다 5%의 이율을 얻는 투자 (A)
	3년마다 20%의 이율을 얻는 투자 (B)
	5년마다 35%의 이율을 얻는 투자 (C)


투자를 할 때에는 다음과 같은 주의점이 있다.


	투자의 기한(1년, 3년, 5년)을 채우는 시점에 이율이 반영되며, 그 사이에는 돈이 늘어나지 않는다.
	투자 방식은 매년 바꿀 수 있다.
	매번 이율은 소수점 이하를 버림 해서 받는다.


예를 들어서, 지금 가진 돈이 11111원이면, A 방식이면 1년 후에 555원, B 방식이면 3년 후에 2,222원, C 방식이면 5년 후에 3,888원을 이자로 받을 수 있다. 만약 C 방식으로 투자했지만 4년이 지난 시점이라면 받을 수 있는 이자는 0원이다.

주형이의 초기 비용이 H원일 때, Y년이 지난 시점에 가장 많은 금액을 얻을 수 있는 투자 패턴을 분석하고 그 금액을 출력하자.

---

## 입력
첫째 줄에 초기 비용 H와 투자 기간 Y가 주어진다.

모든 입력은 정수로 주어진다.

---

## 출력
가장 많은 이득을 얻었을 때의 총 자산을 소수점을 모두 버리고 정수로 출력한다.

---

## 성능 요약
메모리: 108384 KB, 시간: 88 ms

---

## 풀이

### 풀이 핵심 로직
이 문제는 동적 프로그래밍을 이용하여 주어진 투자 기간 동안 최대 자산을 계산하는 문제입니다. 매년, 3년마다, 5년마다 적용되는 이율을 고려하여 가능한 모든 투자 방법을 탐색하며 최대 자산을 업데이트해 나갑니다. 각 시점에서의 자산은 이전 시점의 자산에 이율을 반영하여 계산하며, 소수점 이하는 버림 처리합니다.

### 동작 과정
예를 들어, 초기 비용 H가 10000원이고, 투자 기간 Y가 7년인 경우를 살펴보겠습니다.

1. **초기 설정**: dp 배열을 초기화합니다. dp[0] = 10000, 나머지 dp[i]는 0으로 초기화합니다.
   
   ```
   dp = [10000, 0, 0, 0, 0, 0, 0, 0]
   ```

2. **1년 후 (i=1)**: A 방식으로 투자하면 10000 * 1.05 = 10500원이 됩니다. 따라서,
   
   ```
   dp[1] = int(10000 * 1.05) = 10500
   ```
   
   ```
   dp = [10000, 10500, 0, 0, 0, 0, 0, 0]
   ```

3. **2년 후 (i=2)**: A 방식으로 계속 투자하면 10500 * 1.05 = 11025원이 됩니다. 따라서,
   
   ```
   dp[2] = int(10500 * 1.05) = 11025
   ```
   
   ```
   dp = [10000, 10500, 11025, 0, 0, 0, 0, 0]
   ```

4. **3년 후 (i=3)**: A 방식을 계속 사용하여 11025 * 1.05 = 11576원이 되고, B 방식을 사용하면 10000 * 1.2 = 12000원이 됩니다. 더 큰 값을 선택하므로,
   
   ```
   dp[3] = int(max(11025 * 1.05, 10000 * 1.2)) = 12000
   ```
   
   ```
   dp = [10000, 10500, 11025, 12000, 0, 0, 0, 0]
   ```

5. **4년 후 (i=4)**: A 방식으로 12000 * 1.05 = 12600원이 됩니다. B 방식은 사용할 수 없고 C 방식도 사용할 수 없습니다. 따라서,
   
   ```
   dp[4] = int(12000 * 1.05) = 12600
   ```
   
   ```
   dp = [10000, 10500, 11025, 12000, 12600, 0, 0, 0]
   ```

6. **5년 후 (i=5)**: A 방식으로 계속하면 12600 * 1.05 = 13230원이 되고, B 방식은 사용할 수 없고 C 방식으로 10000 * 1.35 = 13500원이 됩니다. 따라서,
   
   ```
   dp[5] = int(max(12600 * 1.05, 10000 * 1.35)) = 13500
   ```
   
   ```
   dp = [10000, 10500, 11025, 12000, 12600, 13500, 0, 0]
   ```

7. **6년 후 (i=6)**: A 방식으로 13500 * 1.05 = 14175원이 되고, B 방식은 사용할 수 없고 C 방식은 사용할 수 없습니다. 따라서,
   
   ```
   dp[6] = int(13500 * 1.05) = 14175
   ```
   
   ```
   dp = [10000, 10500, 11025, 12000, 12600, 13500, 14175, 0]
   ```

8. **7년 후 (i=7)**: A 방식으로 14175 * 1.05 = 14883.75가 되며, B와 C 방식은 사용할 수 없습니다. 따라서,
   
   ```
   dp[7] = int(14175 * 1.05) = 14883
   ```
   
   ```
   dp = [10000, 10500, 11025, 12000, 12600, 13500, 14175, 14883]
   ```

최종적으로 dp[7]의 값인 14883을 출력합니다.

### 시간 복잡도

---

## 코드
```python
h,y = map(int,input().split())
dp = [0 for _ in range(y+1)]
dp[0] = h

for i in range(1,y+1):
	if i >= 5:
		dp[i] = int(max(dp[i-1]*1.05, dp[i-3]*1.2, dp[i-5]*1.35))
	elif i >= 3:
		dp[i] = int(max(dp[i-1]*1.05, dp[i-3]*1.2))
	else:
		dp[i] = int(dp[i-1]*1.05)

print(dp[y])
```