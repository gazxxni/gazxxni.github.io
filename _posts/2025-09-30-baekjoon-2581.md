---
layout: post
title: "[백준] 2581번 (Python)"
date: 2025-09-30
categories: [Algorithm, Baekjoon]
tags: [python, algorithm, baekjoon, "2581"]
---

## 문제 링크
[https://www.acmicpc.net/problem/2581](https://www.acmicpc.net/problem/2581)

---

## 풀이

### 풀이 핵심 로직
이 문제는 주어진 범위 내의 소수를 찾고, 그 소수들의 합과 최솟값을 구하는 것이다. 에라토스테네스의 체 알고리즘을 사용하여 2부터 n까지의 소수를 효과적으로 찾고, 그 중 m 이상인 소수들을 필터링하여 결과를 계산한다.

### 동작 과정
1. **입력 받기**: m과 n을 입력받는다.
2. **소수 리스트 초기화**: 0부터 10000까지의 숫자를 True로 초기화한 배열 `arr`를 생성하고, 0과 1은 False로 설정하여 소수가 아님을 나타낸다.
3. **에라토스테네스의 체**: 2부터 √n까지 반복하면서, 현재 숫자가 True인 경우 그 배수들을 False로 설정하여 소수를 찾는다.
4. **소수 합산 및 최솟값 찾기**:
   - 초기값으로 `cnt`와 `ans`를 0으로 설정한다.
   - m부터 n까지 반복하면서, 현재 숫자가 True인 경우(즉, 소수인 경우) `cnt`에 추가하고, `ans`가 0일 때 현재 숫자를 `ans`에 저장하여 최솟값을 찾는다.
5. **결과 출력**: 만약 `ans`가 여전히 0이라면 소수가 없는 것이므로 -1을 출력하고, 그렇지 않다면 소수의 합과 최솟값을 출력한다.

**예시 입력**:
```
60
100
```

**단계별 설명**:
- m = 60, n = 100으로 입력받는다.
- 소수 리스트를 초기화하여 `arr`가 `[False, False, True, True, ..., True]`가 된다.
- 에라토스테네스의 체를 적용하여 60 ~ 100 사이의 소수를 찾는다.
- 61, 67, 71, 73, 79, 83, 89, 97과 같은 소수들을 발견하여 `cnt`에 합산하고, `ans`에 첫 번째 소수인 61을 저장한다.
- 최종적으로, 소수의 합인 552와 최솟값인 61을 출력한다.

### 시간 복잡도
시간 복잡도는 O(n log log n)이다. 이는 에라토스테네스의 체 알고리즘의 소수를 찾는 과정에서 발생하는 시간 복잡도로, n까지의 소수를 찾는 데에 효율적이다.

---

## 코드
```python
m = int(input())
n = int(input())

arr = [True] * 10001
arr[0], arr[1] = False, False

for i in range(2, int(n ** 0.5) + 1): 
    if arr[i]:
        for j in range(i * i, n + 1, i):
            arr[j] = False
             
cnt = 0
ans = 0
for i in range(m, n + 1):
    if arr[i]:
        cnt += i
        if ans == 0:
            ans = i

if ans == 0:
    print(-1)
else:
    print(cnt)
    print(ans)
```